\section*{Appendix}

Note that \elpiIn{(a infix b) c d} de-sugars to \elpiIn{(infix) a b c d}.

\section{The memory}

\begin{elpicode}
  kind address type.
  type addr nat -> address.

  typeabbrev (mem A) (list (option A)).

  type get nat -> mem A -> A -> o.
  get z (some Y :: _) Y.
  get (s N) (_ :: L) X :- get N L X.

  type alloc-aux nat -> mem A -> mem A -> o.
  alloc-aux z [] [none] :- !.
  alloc-aux z L L.
  alloc-aux (s N) [] [none | M] :- alloc-aux N [] M.
  alloc-aux (s N) [X | L] [X | M] :- alloc-aux N L M.

  type alloc address -> mem A -> mem A -> o.
  alloc (addr A as Ad) Mem1 Mem2 :- unset? Ad Mem1, 
    alloc-aux A Mem1 Mem2.

  type new-aux mem A -> nat -> mem A -> o.
  new-aux [] z [none].
  new-aux [A | As] (s N) [A | Bs] :- new-aux As N Bs.

  type new mem A -> address -> mem A -> o.
  new Mem1 (addr Ad) Mem2 :- new-aux Mem1 Ad Mem2.

  type set? address -> mem A -> A -> o.
  set? (addr A) Mem Val :- get A Mem Val.

  type unset? address -> mem A -> o.
  unset? Addr Mem :- not (set? Addr Mem _).

  type assign-aux nat -> mem A -> A -> mem A -> o.
  assign-aux z (none :: L) Y (some Y :: L).
  assign-aux (s N) (X :: L) Y (X :: L1) :- assign-aux N L Y L1.

  type assign address -> mem A -> A -> mem A -> o.
  assign (addr A) Mem1 Val Mem2 :- assign-aux A Mem1 Val Mem2.
\end{elpicode}

\section{The object language}

\begin{elpicode}
~\PYG{k+kd}{type} \PYG{n+nf}{(\Eo)} \PYG{k+kt}{ftm -> ftm -> o}~.                           ~($\customlabel{pred:fequal}{\Eo}$)~
fapp A ~\Eo~fapp B :- map ~(\Eo)~ A B.
flam F ~\Eo~flam G :- pi x\ x ~\Eo~x => F x ~\Eo~G x.
fcon C ~\Eo~fcon C.
fuva N ~\Eo~fuva N.
flam F ~\Eo~T :-                                       ~($\customlabel{clause:eta1}{\eta_l}$)~
  pi x\ beta T [x] (R x), x ~\Eo~x => F x ~\Eo~R x.
T ~\Eo~flam F :-                                       ~($\customlabel{clause:eta2}{\eta_r}$)~
  pi x\ beta T [x] (R x), x ~\Eo~x => R x ~\Eo~F x.
fapp [flam X | L] ~\Eo~T :- beta (flam X) L R, R ~\Eo~T. ~($\customlabel{clause:beta1}{\beta_l}$)~
T ~\Eo~fapp [flam X | L] :- beta (flam X) L R, T ~\Eo~R. ~($\customlabel{clause:beta2}{\beta_r}$)~

type beta fm -> list fm -> fm -> o.
beta A [] A.
beta (flam F) [H | L] R :- subst F H B,
  beta B L R. % since F could be x\app[x|_] and H be lam _ 
beta (fapp A) L (fapp X) :- append A L X.
beta (fuva N) L (fapp [fuva N | L]).
beta (fcon H) L (fapp [fcon H | L]).

type subst (fm -> fm) -> fm -> fm -> o.
subst F H B :- napp (F H) B. % since (F H) may generate (app[app _|_])

type napp fm -> fm -> o.
napp (fcon C) (fcon C).
napp (flam F) (flam G) :- pi x\ napp x x => napp (F x) (G x).
napp (fapp[fapp L|M]) R :- !, append L M N, napp (fapp N) R.
napp (fapp[X]) R :- !, napp X R.
napp (fapp A) (fapp B) :- map napp A B.
napp (fuva N) (fuva N).
\end{elpicode}

\section{The meta language}
% \begin{figure*}
\begin{elpicode}
  typeabbrev subst list (option assignment).

  kind inctx type -> type.
  type abs (tm -> inctx A) -> inctx A.
  type val A -> inctx A.

  typeabbrev assignment (inctx tm).

  kind tm  type.
  type app list tm -> tm.
  type lam (tm -> tm) -> tm.
  type con string -> tm.
  type uva  address -> list tm -> tm.

  type (==l) tm -> tm -> subst -> subst ->  o.
  % congruence
  ((app L1) ==l (app L2)) S S1 :- fold2 (==l) L1 L2 S S1.
  ((lam F1) ==l (lam F2)) S S1 :- 
    pi x\ copy x x => ((F1 x) ==l (F2 x)) S S1.
  ((con X) ==l (con X)) S S.
  % set variables
  ((uva N Args) ==l T) S S1 :- 
    mem.set? N S F,!, move F Args T1, (T1 ==l T) S S1.
  (T ==l (uva N Args)) S S1 :- 
    mem.set? N S F,!, move F Args T1, (T ==l T1) S S1.
  % flex-flex
  ((uva M A1) ==l (uva N A2)) S1 S2 :- !, 
    pattern-fragment A1, pattern-fragment A2, 
    prune! M A1 N A2 S1 S2.
  ((uva N Args) ==l T) S S1 :- not_occ N S T, pattern-fragment Args, 
    bind T Args T1, mem.assign N S T1 S1.
  % variable assigment
  (T ==l (uva N Args)) S S1 :- not_occ N S T, pattern-fragment Args, 
    bind T Args T1, mem.assign N S T1 S1.
  (N ==l N) S S :- name N.

  % Note: We suppose the scopes to always be in PF
  type prune! address -> list ho.tm -> address -> 
              list ho.tm -> subst -> subst -> o.
  prune! N A  N A  S S :- !.
  prune! M A  N A  S1 S2 :- !, bind (uva M A) A Ass, 
    mem.assign N S1 Ass S2.
  prune! N A1 N A2 S1 S3 :- !,
    std.assert!(len A1 {len A2}) "Not typechecking", !,
    mem.new S1 W S2, prune-same-variable W A1 A2 [] Ass,
    mem.assign N S2 Ass S3.
  prune! N A1 M A2 S1 S4 :- !,
    mem.new S1 W S2, prune-diff-variables W A1 A2 Ass1 Ass2, 
    mem.assign N S2 Ass1 S3,
    mem.assign M S3 Ass2 S4. 

  type prune-same-variable address -> list tm -> list tm -> 
                            list tm -> assignment -> o.
  prune-same-variable N [] [] ACC (val (uva N Args)) :- 
    std.rev ACC Args.
  prune-same-variable N [X|XS] [X|YS] ACC (abs F) :- 
    pi x\ prune-same-variable N XS YS [x|ACC] (F x).
  prune-same-variable N [_|XS] [_|YS] ACC (abs F) :- 
    pi x\ prune-same-variable N XS YS ACC (F x).

  type prune-build-ass1 address -> list tm -> 
                        list bool -> assignment -> o.
  prune-build-ass1 N Acc [] (val (uva N Args)) :- 
    std.rev Acc Args.
  prune-build-ass1 N Acc [tt|L] (abs T) :- 
    pi x\ prune-build-ass1 N [x|Acc] L (T x).
  prune-build-ass1 N Acc [ff|L] (abs T) :- 
    pi x\ prune-build-ass1 N Acc L (T x).

  type build-order list nat -> list tm -> list tm -> o.
  build-order L T R :-
    len L Len, list-init Len z 
      (p\r\ sigma Index Elt\ index L p Index, nth Index T r) R.

  type prune-build-ass2 address -> list tm -> list bool -> 
                      list nat -> assignment -> o.
  prune-build-ass2 N Acc [] Pos (val (uva N Args)) :- 
    std.rev Acc Acc', build-order Pos Acc' Args.
  prune-build-ass2 N Acc [tt|L] Pos (abs T) :- 
    pi x\ prune-build-ass2 N [x|Acc] L Pos (T x).
  prune-build-ass2 N Acc [ff|L] Pos (abs T) :- 
    pi x\ prune-build-ass2 N Acc L Pos (T x).

  type keep list A -> A -> bool -> o.
  keep L A tt :- mem L A, !.
  keep _ _ ff.

  type prune-diff-variables address -> list tm -> list tm -> 
                            assignment -> assignment -> o.
  prune-diff-variables N Args1 Args2 Ass1 Ass2 :-
    std.map Args1 (keep Args2) Bits1, 
    prune-build-ass1 N [] Bits1 Ass1,
    std.map Args2 (keep Args1) Bits2, 
    std.filter Args1 (mem Args2) ToKeep1,
    std.filter Args2 (mem Args1) ToKeep2,
    std.map ToKeep2 (index ToKeep1) Pos,
    prune-build-ass2 N [] Bits2 Pos Ass2.

  type move assignment -> list tm -> tm -> o.
  move (abs Bo)        [H|L] R :- move (Bo H) L R.
  move (val A)         []    A :- !.
  move (val (uva N A)) L     (uva N X) :- std.append A L X.

  type beta tm -> list tm -> tm -> o.
  beta A [] A.
  beta (lam Bo) [H | L] R :- beta (Bo H) L R.
  beta (app A) L (app X) :- std.append A L X.
  beta (uva N A) L (uva N A') :- std.append A L A'.
  beta (con H) L (app [con H | L]).

  type not_occ_aux address -> subst -> tm -> o.
  not_occ_aux N S (uva M _) :- mem.unset? M S, not (N = M).
  not_occ_aux N S (uva M Args) :- mem.set? M S F, 
    move F Args T, not_occ_aux N S T.
  not_occ_aux N S (app L) :- forall1 (not_occ_aux N S) L.
  not_occ_aux N S (lam F) :- pi x\ not_occ_aux N S (F x).
  not_occ_aux _ _ (con _).
  not_occ_aux _ _ X :- name X.
  
  type not_occ  address -> subst -> tm -> o.
  not_occ N _ (uva N _).
  not_occ N S (uva M Args) :- mem.set? M S F, 
    move F Args T, not_occ N S T.
  not_occ N S (uva M Args) :- mem.unset? M S, 
    std.forall Args (not_occ_aux N S).
  not_occ _ _ (con _).
  not_occ N S (app L) :- not_occ_aux N S (app L).
  not_occ N S (lam L) :- pi x\ not_occ N S (L x).
  not_occ _ _ X :- name X.

  type copy tm -> tm -> o.
  copy (app L)   (app L') :- forall2 copy L L'.
  copy (lam T)   (lam T') :- pi x\ copy x x => copy (T x) (T' x).
  copy (uva N L) (uva N L') :- forall2 copy L L'.
  copy (con C)   (con C).
  copy N N :- name N.

  type bind tm -> list tm -> assignment -> o.
  bind T [] (val T') :- copy T T'.
  bind T [X | TL] (abs T') :- pi x\ copy X x => bind T TL (T' x).

  type deref subst -> tm -> tm -> o.
  deref S X _ :- (var S; var X), halt "flex deref".
  deref H (uva N L)  X         :- mem.set? N H T, 
    move T L X', !, deref H X' X.
  deref H (app L)   (app L1)   :- forall2 (deref H) L L1.
  deref _ (con X)   (con X).
  deref H (uva X L) (uva X L1) :- mem.unset? X H, 
    forall2 (deref H) L L1.
  deref H (lam F)   (lam G)    :- pi x\ deref H (F x) (G x).
  deref _ N         N          :- name N.

  type deref-assmt subst -> assignment -> assignment -> o.
  deref-assmt S (abs T) (abs R) :- pi x\ deref-assmt S (T x) (R x).
  deref-assmt S (val T) (val R) :- deref S T R.

\section{The compiler}

\begin{elpicode}
  type use-binder fo.fm -> fo.fm -> o.
  use-binder N N.
  use-binder N (fo.fapp L) :- exists (use-binder N) L.
  use-binder N (fo.flam B) :- pi x\ use-binder N (B x).

  type maybe-eta fo.fm -> fo.fm -> list fo.fm -> o.
  maybe-eta N (fo.fapp[fo.fuva _|Args]) _ :- !,
    exists (x\ maybe-eta-of [] N x) Args, !. 
  maybe-eta N (fo.flam B) L :- !, pi x\ maybe-eta N (B x) [x | L].
  maybe-eta _ (fo.fapp [fo.fcon _|Args]) L :-
    split-last-n {len L} Args First Last,
    forall1 (x\ forall1 (y\ not (use-binder x y)) First) L,
    forall2 (maybe-eta-of []) {std.rev L} Last.

  type maybe-eta-of list fo.fm -> fo.fm -> fo.fm -> o.
  maybe-eta-of _ N N :- !.
  maybe-eta-of L N (fo.fapp[fo.fuva _|Args]) :- !, 
    % Head is flex -> if N is in Args, we can have eta
    forall1 (x\ exists (maybe-eta-of [] x) Args) [N|L]. 
  maybe-eta-of L N (fo.flam B) :- !, 
    pi x\ maybe-eta-of [x | L] N (B x).
  maybe-eta-of L N (fo.fapp [N|Args]) :-
    % Head is rigid -> to be an eta we consider also L
    last-n {len L} Args R,
    forall2 (maybe-eta-of []) R {std.rev L}.

  type locale ho.tm -> o.
  type get-scope-aux ho.tm -> list ho.tm -> o.
  get-scope-aux (ho.con _) [].
  get-scope-aux (ho.uva _ L) L1 :- 
    forall2 get-scope-aux L R,
    flatten R L1.
  get-scope-aux (ho.lam B) L1 :- 
    pi x\ locale x => get-scope-aux (B x) L1.
  get-scope-aux (ho.app L) L1 :- 
    forall2 get-scope-aux L R,
    flatten R L1.
  get-scope-aux X [X] :- name X, not (locale X).
  get-scope-aux X [] :- name X, (locale X).

  type get-scope ho.tm -> list ho.tm -> o.
  get-scope T Scope :- names N,
    get-scope-aux T ScopeDuplicata,
    std.filter N (mem ScopeDuplicata) Scope.

  type close-links (ho.tm -> links) -> links -> o.
  close-links (_\[]) [].
  close-links (v\[L|XS v]) [L|YS] :- !, close-links XS YS.
  close-links (v\[(L v)|XS v]) [ho.abs L|YS] :- !, 
    close-links XS YS.

  type comp-lam (fo.fm -> fo.fm) -> (ho.tm -> ho.tm) -> 
    mappings -> mappings -> links -> links -> ho.subst -> 
      ho.subst -> o.
  comp-lam F F1 Mappings1 Mappings2 L L2 S S1 :-
    pi x y\ (pi M L S\ comp x y M M L L S S) => 
      comp (F x) (F1 y) Mappings1 Mappings2 L (L1 y) S S1, 
        close-links L1 L2.

  type comp fo.fm -> ho.tm -> mappings -> mappings -> links -> 
    links -> ho.subst -> ho.subst -> o.
  comp (fo.fcon X) (ho.con X)        Map1 Map1 L1 L1 S1 S1.
  comp (fo.flam F) (ho.uva E0 Scope) Map1 Map2 L1 L3 S1 S3 :-
    (pi x\ maybe-eta x (F x) [x]), !,
    mem.new S1 E0 S2,
    comp-lam F F1 Map1 Map2 L1 L2 S2 S3,
    (pi x\ locale x => get-scope (F1 x) Scope), 
    NewLink = ho.val(link-eta (ho.uva E0 Scope) (ho.lam F1)), 
    L3 = [NewLink| L2].
  comp (fo.flam F) (ho.lam F1)       Map1 Map2 L1 L2 S1 S2 :- 
    comp-lam F F1 Map1 Map2 L1 L2 S1 S2.
  comp (fo.fuva N) (ho.uva M []) Map1 Map2 L L S S1 :- 
    alloc Map1 Map2 (fv N) (hv M (arity z)) S S1.
  comp (fo.fapp [fo.fuva N|Ag]) (ho.uva M' Scope) Map1 Map3 L1 L3 S1 S4 :- !,
    split-pf Ag PF NPF,
    forall2 (x\y\ comp x y _ _ _ _ _ _) PF PF1,
    fold6 comp NPF NPF1 Map1 Map2 L1 L2 S1 S2,
    len PF Arity, 
    alloc Map2 Map3 (fv N) (hv M (arity Arity)) S2 S3,
    if (NPF = []) 
      (Scope = PF1, M' = M, S3 = S4, L2 = L3)
      (get-scope (ho.app {std.append PF1 NPF1}) Scope, 
        mem.new S3 M' S4,
        L3 = [@val-link-beta (ho.uva M' Scope) (ho.app[ho.uva M PF1 | NPF1]) | L2]).
  comp (fo.fapp A) (ho.app A1) Map1 Map2 L1 L2 S1 S2 :- 
    fold6 comp A A1 Map1 Map2 L1 L2 S1 S2.

  type make-eta-link-aux nat -> address -> address -> 
    list ho.tm -> links -> ho.subst -> ho.subst -> o.
  make-eta-link-aux z Ad1 Ad2 Scope1 L H1 H1  :-
    std.rev Scope1 Scope, eta-expand (ho.uva Ad2 Scope) @one T1,
    L = [@val-link-eta (ho.uva Ad1 Scope) T1].
  make-eta-link-aux (s N) Ad1 Ad2 Scope1 L H1 H3 :-
    std.rev Scope1 Scope, mem.new H1 Ad H2, 
    eta-expand (ho.uva Ad Scope) @one T2,
    (pi x\ make-eta-link-aux N Ad Ad2 [x|Scope1] (L1 x) H2 H3),
    close-links L1 L2,
    L = [@val-link-eta (ho.uva Ad1 Scope) T2 | L2].

  type make-eta-link nat -> nat -> address -> address -> 
          list ho.tm -> links -> ho.subst -> ho.subst -> o.
  make-eta-link (s N) z Ad1 Ad2 Vars L H H1 :- 
    make-eta-link-aux N Ad2 Ad1 Vars L H H1.
  make-eta-link z (s N) Ad1 Ad2 Vars L H H1 :- 
    make-eta-link-aux N Ad1 Ad2 Vars L H H1.
  make-eta-link (s N) (s M) Ad1 Ad2 Vars Links H H1 :-
    (pi x\ make-eta-link N M Ad1 Ad2 [x|Vars] (L x) H H1),
    close-links L Links.

  type deduplicate-mappings mappings -> mappings -> 
          ho.subst -> ho.subst -> links -> links -> o.
  deduplicate-mappings [] [] H H L L.
  deduplicate-mappings [(mapping (fv O) (hv M (arity LenM)) as X1) | Map1] Map2 H1 H3 L1 L3 :-
    take-list Map1 (mapping (fv O) (hv M' (arity LenM'))) _, !,
    make-eta-link LenM LenM' M M' [] New H1 H2,
    std.append New L1 L2,
    deduplicate-mappings Map1 Map2 H2 H3 L2 L3.
  deduplicate-mappings [A|As] [A|Bs] H1 H2 L1 L2 :- 
    deduplicate-mappings As Bs H1 H2 L1 L2, !.
\end{elpicode}

\section{The progress function}

\begin{elpicode}
  
  macro @one :- s z.

  type contract-rigid list ho.tm -> ho.tm -> ho.tm -> o.
  contract-rigid L (ho.lam F) T :- 
    pi x\ contract-rigid [x|L] (F x) T. % also checks H Prefix does not see x
  contract-rigid L (ho.app [H|Args]) T :- 
    std.rev L LRev, std.appendR Prefix LRev Args,
    if (Prefix = []) (T = H) (T = ho.app [H|Prefix]).

  type progress-eta-link ho.tm -> ho.tm -> ho.subst -> ho.subst -> links -> o.
  progress-eta-link (ho.app _ as T) (ho.lam x\ _ as T1) H H1 [] :- !, 
    ({eta-expand T @one} ==l T1) H H1.
  progress-eta-link (ho.con _ as T) (ho.lam x\ _ as T1) H H1 [] :- !, 
    ({eta-expand T @one} ==l T1) H H1.
  progress-eta-link (ho.lam _ as T) T1 H H1 [] :- !, 
    (T ==l T1) H H1.
  progress-eta-link (ho.uva _ _ as X) T H H1 [] :- 
    contract-rigid [] T T1, !, (X ==l T1) H H1.
  progress-eta-link (ho.uva Ad _ as T1) T2 H H [@val-link-eta T1 T2] :- !, 
    if (ho.not_occ Ad H T2) true fail.

  type is-in-pf ho.tm -> o.
  is-in-pf (ho.app [ho.uva _ _ | _]) :- !, fail.
  is-in-pf (ho.lam B) :- !, pi x\ is-in-pf (B x).
  is-in-pf (ho.con _).
  is-in-pf (ho.app L) :- forall1 is-in-pf L.
  is-in-pf N :- name N.
  is-in-pf (ho.uva _ L) :- pattern-fragment L.

  type arity ho.tm -> nat -> o.
  arity (ho.con _) z.
  arity (ho.app L) A :- len L A.

  type occur-check-err ho.tm -> ho.tm -> ho.subst -> o.
  occur-check-err (ho.con _) _ _ :- !.
  occur-check-err (ho.app _) _ _ :- !.
  occur-check-err (ho.lam _) _ _ :- !.
  occur-check-err (ho.uva Ad _) T S :-
    not (ho.not_occ Ad S T).

  type progress-beta-link-aux ho.tm -> ho.tm -> 
          ho.subst -> ho.subst -> links -> o.
  progress-beta-link-aux T1 T2 S1 S2 [] :-  is-in-pf T2, !,
    (T1 ==l T2) S1 S2.
  progress-beta-link-aux T1 T2 S S [@val-link-beta T1 T2] :- !.

  type progress-beta-link ho.tm -> ho.tm -> ho.subst -> 
        ho.subst -> links -> o.
  progress-beta-link T (ho.app[ho.uva V Scope | L] as T2) S S2 [@val-link-beta T T2] :- 
    arity T Arity, len L ArgsNb, ArgsNb >n Arity, !,
    minus ArgsNb Arity Diff, mem.new S V1 S1,
    eta-expand (ho.uva V1 Scope) Diff T1,
    ((ho.uva V Scope) ==l T1) S1 S2.

  progress-beta-link (ho.uva _ _ as T) (ho.app[ho.uva Ad1 Scope1 | L1] as T1) S1 S3 NewLinks :-
    std.append Scope1 L1 Scope1L,
    split-pf Scope1L Scope2 L2,
    not (Scope1 = Scope2), !,
    mem.new S1 Ad2 S2,
    len Scope1 Scope1Len,
    len Scope2 Scope2Len,
    make-eta-link Scope1Len Scope2Len Ad1 Ad2 [] LinkEta S2 S3,
    if (L2 = []) (NewLinks = LinkEta, T2 = ho.uva Ad2 Scope2) 
      (T2 = ho.app [ho.uva Ad2 Scope2 | L2], 
      NewLinks = [@val-link-beta T T2 | LinkEta]).

  progress-beta-link T1 (ho.app[ho.uva _ _ | _] as T2) _ _ _ :- 
    not (T1 = ho.uva _ _), !, fail.

  progress-beta-link (ho.uva _ _ as T) (ho.app[ho.uva _ _ | _] as T2) S1 _ _ :- 
    occur-check-err T T2 S1, !, fail.

  progress-beta-link T1 (ho.app[ho.uva _ _ | _] as T2) H H [@val-link-beta T1 T2] :- !.

  progress-beta-link T1 (ho.app [Hd | Tl]) S1 S2 B :-
    ho.beta Hd Tl T3, 
    progress-beta-link-aux T1 T3 S1 S2 B.

  type solve-link-abs link -> links -> ho.subst -> ho.subst -> o.
  solve-link-abs (ho.abs X) R H H1 :- 
    pi x\ ho.copy x x => (pi S\ ho.deref S x x) => 
      solve-link-abs (X x) (R' x) H H1,
    close-links R' R.

  solve-link-abs (@val-link-eta A B) NewLinks S S1 :- !,
    progress-eta-link A B S S1 NewLinks.

  solve-link-abs (@val-link-beta A B) NewLinks S S1 :- !,
    progress-beta-link A B S S1 NewLinks.

  type take-link link -> links -> link -> links -> o.
  take-link A [B|XS] B XS :- link-abs-same-lhs A B, !.
  take-link A [L|XS] B [L|YS] :- take-link A XS B YS.

  type link-abs-same-lhs link -> link -> o.
  link-abs-same-lhs (ho.abs F) B :- 
    pi x\ link-abs-same-lhs (F x) B.
  link-abs-same-lhs A (ho.abs G) :- 
    pi x\ link-abs-same-lhs A (G x).
  link-abs-same-lhs (@val-link-eta (ho.uva N _) _) (@val-link-eta (ho.uva N _) _).

  type same-link-eta link -> link -> ho.subst -> ho.subst -> o.
  same-link-eta (ho.abs F) B H H1 :- !, pi x\ same-link-eta (F x) B H H1.
  same-link-eta A (ho.abs G) H H1 :- !, pi x\ same-link-eta A (G x) H H1.
  same-link-eta (@val-link-eta (ho.uva N S1) A)
                (@val-link-eta (ho.uva N S2) B) H H1 :-
    std.map2 S1 S2 (x\y\r\ r = ho.copy x y) Perm,
    Perm => ho.copy A A',
    (A' ==l B) H H1.

  type solve-links links -> links -> ho.subst -> ho.subst -> o.
  solve-links [] [] X X.
  solve-links [A|L1] [A|L3] S S2 :- take-link A L1 B L2, !,
    same-link-eta A B S S1, 
    solve-links L2 L3 S1 S2.
  solve-links [L0|L1] L3 S S2 :- deref-link S L0 L,
    solve-link-abs L R S S1, !,
    solve-links L1 L2 S1 S2, std.append R L2 L3.
\end{elpicode}

\section{The decompiler}

\section{Auxiliary functions}

\begin{elpicode}
  type fold4 (A -> A1 -> B -> B -> C -> C -> o) -> list A -> list A1 -> B -> B -> C -> C -> o.
  fold4 _ [] [] A A B B.
  fold4 F [X|XS] [Y|YS] A A1 B B1 :- F X Y A A0 B B0, fold4 F XS YS A0 A1 B0 B1.
  
  type len list A -> nat -> o.
  len [] z.
  len [_|L] (s X) :- len L X.
  
  \end{elpicode}
  