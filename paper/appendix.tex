\section*{Appendix}

Note that \elpiIn{(a infix b) c d} de-sugars to \elpiIn{(infix) a b c d}.

\section{The memory}

\input{code/mem}

\section{The meta language}
% \begin{figure*}
\begin{elpicode}
  typeabbrev subst list (option assignment).

  kind inctx type -> type.
  type abs (tm -> inctx A) -> inctx A.
  type val A -> inctx A.

  typeabbrev assignment (inctx tm).

  kind tm  type.
  type app list tm -> tm.
  type lam (tm -> tm) -> tm.
  type con string -> tm.
  type uva  address -> list tm -> tm.

  type (==l) tm -> tm -> subst -> subst ->  o.
  % congruence
  ((app L1) ==l (app L2)) S S1 :- fold2 (==l) L1 L2 S S1.
  ((lam F1) ==l (lam F2)) S S1 :- 
    pi x\ copy x x => ((F1 x) ==l (F2 x)) S S1.
  ((con X) ==l (con X)) S S.
  % set variables
  ((uva N Args) ==l T) S S1 :- 
    mem.set? N S F,!, move F Args T1, (T1 ==l T) S S1.
  (T ==l (uva N Args)) S S1 :- 
    mem.set? N S F,!, move F Args T1, (T ==l T1) S S1.
  % flex-flex
  ((uva M A1) ==l (uva N A2)) S1 S2 :- !, 
    pattern-fragment A1, pattern-fragment A2, 
    prune! M A1 N A2 S1 S2.
  ((uva N Args) ==l T) S S1 :- not_occ N S T, pattern-fragment Args, 
    bind T Args T1, mem.assign N S T1 S1.
  % variable assigment
  (T ==l (uva N Args)) S S1 :- not_occ N S T, pattern-fragment Args, 
    bind T Args T1, mem.assign N S T1 S1.
  (N ==l N) S S :- name N.

  % Note: We suppose the scopes to always be in PF
  type prune! address -> list ho.tm -> address -> 
              list ho.tm -> subst -> subst -> o.
  prune! N A  N A  S S :- !.
  prune! M A  N A  S1 S2 :- !, bind (uva M A) A Ass, 
    mem.assign N S1 Ass S2.
  prune! N A1 N A2 S1 S3 :- !,
    std.assert!(len A1 {len A2}) "Not typechecking", !,
    mem.new S1 W S2, prune-same-variable W A1 A2 [] Ass,
    mem.assign N S2 Ass S3.
  prune! N A1 M A2 S1 S4 :- !,
    mem.new S1 W S2, prune-diff-variables W A1 A2 Ass1 Ass2, 
    mem.assign N S2 Ass1 S3,
    mem.assign M S3 Ass2 S4. 

  type prune-same-variable address -> list tm -> list tm -> 
                            list tm -> assignment -> o.
  prune-same-variable N [] [] ACC (val (uva N Args)) :- 
    std.rev ACC Args.
  prune-same-variable N [X|XS] [X|YS] ACC (abs F) :- 
    pi x\ prune-same-variable N XS YS [x|ACC] (F x).
  prune-same-variable N [_|XS] [_|YS] ACC (abs F) :- 
    pi x\ prune-same-variable N XS YS ACC (F x).

  type prune-build-ass1 address -> list tm -> 
                        list bool -> assignment -> o.
  prune-build-ass1 N Acc [] (val (uva N Args)) :- 
    std.rev Acc Args.
  prune-build-ass1 N Acc [tt|L] (abs T) :- 
    pi x\ prune-build-ass1 N [x|Acc] L (T x).
  prune-build-ass1 N Acc [ff|L] (abs T) :- 
    pi x\ prune-build-ass1 N Acc L (T x).

  type build-order list nat -> list tm -> list tm -> o.
  build-order L T R :-
    len L Len, list-init Len z 
      (p\r\ sigma Index Elt\ index L p Index, nth Index T r) R.

  type prune-build-ass2 address -> list tm -> list bool -> 
                      list nat -> assignment -> o.
  prune-build-ass2 N Acc [] Pos (val (uva N Args)) :- 
    std.rev Acc Acc', build-order Pos Acc' Args.
  prune-build-ass2 N Acc [tt|L] Pos (abs T) :- 
    pi x\ prune-build-ass2 N [x|Acc] L Pos (T x).
  prune-build-ass2 N Acc [ff|L] Pos (abs T) :- 
    pi x\ prune-build-ass2 N Acc L Pos (T x).

  type keep list A -> A -> bool -> o.
  keep L A tt :- mem L A, !.
  keep _ _ ff.

  type prune-diff-variables address -> list tm -> list tm -> 
                            assignment -> assignment -> o.
  prune-diff-variables N Args1 Args2 Ass1 Ass2 :-
    std.map Args1 (keep Args2) Bits1, 
    prune-build-ass1 N [] Bits1 Ass1,
    std.map Args2 (keep Args1) Bits2, 
    std.filter Args1 (mem Args2) ToKeep1,
    std.filter Args2 (mem Args1) ToKeep2,
    std.map ToKeep2 (index ToKeep1) Pos,
    prune-build-ass2 N [] Bits2 Pos Ass2.

  type move assignment -> list tm -> tm -> o.
  move (abs Bo)        [H|L] R :- move (Bo H) L R.
  move (val A)         []    A :- !.
  move (val (uva N A)) L     (uva N X) :- append A L X.

  type beta tm -> list tm -> tm -> o.
  beta A [] A.
  beta (lam Bo) [H | L] R :- beta (Bo H) L R.
  beta (app A) L (app X) :- append A L X.
  beta (uva N A) L (uva N A') :- append A L A'.
  beta (con H) L (app [con H | L]).

  type not_occ_aux address -> subst -> tm -> o.
  not_occ_aux N S (uva M _) :- mem.unset? M S, not (N = M).
  not_occ_aux N S (uva M Args) :- mem.set? M S F, 
    move F Args T, not_occ_aux N S T.
  not_occ_aux N S (app L) :- forall1 (not_occ_aux N S) L.
  not_occ_aux N S (lam F) :- pi x\ not_occ_aux N S (F x).
  not_occ_aux _ _ (con _).
  not_occ_aux _ _ X :- name X.
  
  type not_occ  address -> subst -> tm -> o.
  not_occ N _ (uva N _).
  not_occ N S (uva M Args) :- mem.set? M S F, 
    move F Args T, not_occ N S T.
  not_occ N S (uva M Args) :- mem.unset? M S, 
    std.forall Args (not_occ_aux N S).
  not_occ _ _ (con _).
  not_occ N S (app L) :- not_occ_aux N S (app L).
  not_occ N S (lam L) :- pi x\ not_occ N S (L x).
  not_occ _ _ X :- name X.

  type copy tm -> tm -> o.
  copy (app L)   (app L') :- forall2 copy L L'.
  copy (lam T)   (lam T') :- pi x\ copy x x => copy (T x) (T' x).
  copy (uva N L) (uva N L') :- forall2 copy L L'.
  copy (con C)   (con C).
  copy N N :- name N.

  type bind tm -> list tm -> assignment -> o.
  bind T [] (val T') :- copy T T'.
  bind T [X | TL] (abs T') :- pi x\ copy X x => bind T TL (T' x).

  type deref subst -> tm -> tm -> o.
  deref S X _ :- (var S; var X), halt "flex deref".
  deref H (uva N L)  X         :- mem.set? N H T, 
    move T L X', !, deref H X' X.
  deref H (app L)   (app L1)   :- forall2 (deref H) L L1.
  deref _ (con X)   (con X).
  deref H (uva X L) (uva X L1) :- mem.unset? X H, 
    forall2 (deref H) L L1.
  deref H (lam F)   (lam G)    :- pi x\ deref H (F x) (G x).
  deref _ N         N          :- name N.

  type deref-assmt subst -> assignment -> assignment -> o.
  deref-assmt S (abs T) (abs R) :- pi x\ deref-assmt S (T x) (R x).
  deref-assmt S (val T) (val R) :- deref S T R.
\end{elpicode}
\section{The compiler}

\input{code/comp}

\section{The progress function}

\begin{elpicode}
  
  macro @one :- s z.

  type contract-rigid list ho.tm -> ho.tm -> ho.tm -> o.
  contract-rigid L (ho.lam F) T :- 
    pi x\ contract-rigid [x|L] (F x) T. % also checks H Prefix does not see x
  contract-rigid L (ho.app [H|Args]) T :- 
    std.rev L LRev, append Prefix LRev Args,
    if (Prefix = []) (T = H) (T = ho.app [H|Prefix]).

  type progress-eta-link ho.tm -> ho.tm -> ho.subst -> ho.subst -> links -> o.
  progress-eta-link (ho.app _ as T) (ho.lam x\ _ as T1) H H1 [] :- !, 
    ({eta-expand T @one} ==l T1) H H1.
  progress-eta-link (ho.con _ as T) (ho.lam x\ _ as T1) H H1 [] :- !, 
    ({eta-expand T @one} ==l T1) H H1.
  progress-eta-link (ho.lam _ as T) T1 H H1 [] :- !, 
    (T ==l T1) H H1.
  progress-eta-link (ho.uva _ _ as X) T H H1 [] :- 
    contract-rigid [] T T1, !, (X ==l T1) H H1.
  progress-eta-link (ho.uva Ad _ as T1) T2 H H [@val-link-eta T1 T2] :- !, 
    if (ho.not_occ Ad H T2) true fail.

  type is-in-pf ho.tm -> o.
  is-in-pf (ho.app [ho.uva _ _ | _]) :- !, fail.
  is-in-pf (ho.lam B) :- !, pi x\ is-in-pf (B x).
  is-in-pf (ho.con _).
  is-in-pf (ho.app L) :- forall1 is-in-pf L.
  is-in-pf N :- name N.
  is-in-pf (ho.uva _ L) :- pattern-fragment L.

  type arity ho.tm -> nat -> o.
  arity (ho.con _) z.
  arity (ho.app L) A :- len L A.

  type occur-check-err ho.tm -> ho.tm -> ho.subst -> o.
  occur-check-err (ho.con _) _ _ :- !.
  occur-check-err (ho.app _) _ _ :- !.
  occur-check-err (ho.lam _) _ _ :- !.
  occur-check-err (ho.uva Ad _) T S :-
    not (ho.not_occ Ad S T).

  type progress-beta-link-aux ho.tm -> ho.tm -> 
          ho.subst -> ho.subst -> links -> o.
  progress-beta-link-aux T1 T2 S1 S2 [] :-  is-in-pf T2, !,
    (T1 ==l T2) S1 S2.
  progress-beta-link-aux T1 T2 S S [@val-link-beta T1 T2] :- !.

  type progress-beta-link ho.tm -> ho.tm -> ho.subst -> 
        ho.subst -> links -> o.
  progress-beta-link T (ho.app[ho.uva V Scope | L] as T2) S S2 [@val-link-beta T T2] :- 
    arity T Arity, len L ArgsNb, ArgsNb >n Arity, !,
    minus ArgsNb Arity Diff, mem.new S V1 S1,
    eta-expand (ho.uva V1 Scope) Diff T1,
    ((ho.uva V Scope) ==l T1) S1 S2.

  progress-beta-link (ho.uva _ _ as T) (ho.app[ho.uva Ad1 Scope1 | L1] as T1) S1 S3 NewLinks :-
    append Scope1 L1 Scope1L,
    pattern-fragment-prefix Scope1L Scope2 L2,
    not (Scope1 = Scope2), !,
    mem.new S1 Ad2 S2,
    len Scope1 Scope1Len,
    len Scope2 Scope2Len,
    make-eta-link Scope1Len Scope2Len Ad1 Ad2 [] LinkEta S2 S3,
    if (L2 = []) (NewLinks = LinkEta, T2 = ho.uva Ad2 Scope2) 
      (T2 = ho.app [ho.uva Ad2 Scope2 | L2], 
      NewLinks = [@val-link-beta T T2 | LinkEta]).

  progress-beta-link T1 (ho.app[ho.uva _ _ | _] as T2) _ _ _ :- 
    not (T1 = ho.uva _ _), !, fail.

  progress-beta-link (ho.uva _ _ as T) (ho.app[ho.uva _ _ | _] as T2) S1 _ _ :- 
    occur-check-err T T2 S1, !, fail.

  progress-beta-link T1 (ho.app[ho.uva _ _ | _] as T2) H H [@val-link-beta T1 T2] :- !.

  progress-beta-link T1 (ho.app [Hd | Tl]) S1 S2 B :-
    ho.beta Hd Tl T3, 
    progress-beta-link-aux T1 T3 S1 S2 B.

  type solve-link-abs link -> links -> ho.subst -> ho.subst -> o.
  solve-link-abs (ho.abs X) R H H1 :- 
    pi x\ ho.copy x x => (pi S\ ho.deref S x x) => 
      solve-link-abs (X x) (R' x) H H1,
    close-links R' R.

  solve-link-abs (@val-link-eta A B) NewLinks S S1 :- !,
    progress-eta-link A B S S1 NewLinks.

  solve-link-abs (@val-link-beta A B) NewLinks S S1 :- !,
    progress-beta-link A B S S1 NewLinks.

  type take-link link -> links -> link -> links -> o.
  take-link A [B|XS] B XS :- link-abs-same-lhs A B, !.
  take-link A [L|XS] B [L|YS] :- take-link A XS B YS.

  type link-abs-same-lhs link -> link -> o.
  link-abs-same-lhs (ho.abs F) B :- 
    pi x\ link-abs-same-lhs (F x) B.
  link-abs-same-lhs A (ho.abs G) :- 
    pi x\ link-abs-same-lhs A (G x).
  link-abs-same-lhs (@val-link-eta (ho.uva N _) _) (@val-link-eta (ho.uva N _) _).

  type same-link-eta link -> link -> ho.subst -> ho.subst -> o.
  same-link-eta (ho.abs F) B H H1 :- !, pi x\ same-link-eta (F x) B H H1.
  same-link-eta A (ho.abs G) H H1 :- !, pi x\ same-link-eta A (G x) H H1.
  same-link-eta (@val-link-eta (ho.uva N S1) A)
                (@val-link-eta (ho.uva N S2) B) H H1 :-
    std.map2 S1 S2 (x\y\r\ r = ho.copy x y) Perm,
    Perm => ho.copy A A',
    (A' ==l B) H H1.

  type solve-links links -> links -> ho.subst -> ho.subst -> o.
  solve-links [] [] X X.
  solve-links [A|L1] [A|L3] S S2 :- take-link A L1 B L2, !,
    same-link-eta A B S S1, 
    solve-links L2 L3 S1 S2.
  solve-links [L0|L1] L3 S S2 :- deref-link S L0 L,
    solve-link-abs L R S S1, !,
    solve-links L1 L2 S1 S2, append R L2 L3.
\end{elpicode}

\section{The decompiler}

\begin{elpicode}
  
  type abs->lam ho.assignment -> ho.tm -> o.
  abs->lam (ho.abs T) (ho.lam R)  :- !, pi x\ abs->lam (T x) (R x).
  abs->lam (ho.val A) A.

  type commit-links-aux link -> ho.subst -> ho.subst -> o.
  commit-links-aux (@val-link-eta T1 T2) H1 H2 :- 
    ho.deref H1 T1 T1', ho.deref H1 T2 T2',
    (T1' ==l T2') H1 H2.
  commit-links-aux (@val-link-beta T1 T2) H1 H2 :- 
    ho.deref H1 T1 T1', ho.deref H1 T2 T2',
    (T1' ==l T2') H1 H2.
  commit-links-aux (ho.abs B) H H1 :- 
    pi x\ commit-links-aux (B x) H H1.

  type commit-links links -> links -> ho.subst -> ho.subst -> o.
  commit-links [] [] H H.
  commit-links [Abs | Links] L H H2 :- 
    commit-links-aux Abs H H1, !, commit-links Links L H1 H2.

  type decompl-subst mappings -> mappings -> ho.subst -> 
    fo.subst -> fo.subst -> o.
  decompl-subst _ [A|_] _ _ _ :- fail.
  decompl-subst _ [] _ F F.
  decompl-subst Map [mapping (fv VO) (hv VM _)|Tl] H F F2 :- 
    mem.set? VM H T, !, 
    ho.deref-assmt H T TTT,
    abs->lam TTT T', tm->fm Map T' T1, 
    fo.eta-contract T1 T2, mem.assign VO F T2 F1,
    decompl-subst Map Tl H F1 F2. 
  decompl-subst Map [mapping _ (hv VM _)|Tl] H F F2 :- 
    mem.unset? VM H, decompl-subst Map Tl H F F2.

  type tm->fm mappings -> ho.tm -> fo.fm -> o.
  tm->fm _ (ho.con C)  (fo.fcon C).
  tm->fm L (ho.lam B1) (fo.flam B2) :- 
    pi x y\ tm->fm _ x y => tm->fm L (B1 x) (B2 y).
  tm->fm L (ho.app L1) T :- forall2 (tm->fm L) L1 [Hd|Tl], 
    fo.mk-app Hd Tl T.
  tm->fm L (ho.uva VM TL) T :- mem L (mapping (fv VO) (hv VM _)), 
    forall2 (tm->fm L) TL T1, fo.mk-app (fo.fuva VO) T1 T.

  type add-new-mappings-aux ho.subst -> list ho.tm -> mappings -> 
        mappings ->  fo.subst -> fo.subst -> o.
  add-new-mappings-aux _ [] _ [] S S.
  add-new-mappings-aux H [T|Ts] L L2 S S2 :- 
    add-new-mappings H T L L1 S S1, 
    add-new-mappings-aux H Ts L1 L2 S1 S2.

  type add-new-mappings ho.subst -> ho.tm -> mappings -> 
      mappings ->  fo.subst -> fo.subst -> o.
  add-new-mappings _ (ho.uva N _) Map [] F1 F1 :- 
    mem Map (mapping _ (hv N _)), !.
  add-new-mappings H (ho.uva N L) Map [Map1 | MapL] F1 F3 :-
    mem.new F1 M F2,
    len L Arity, Map1 = mapping (fv M) (hv N (arity Arity)),
    add-new-mappings H (ho.app L) [Map1 | Map] MapL F2 F3.
  add-new-mappings H (ho.lam B) Map NewMap F1 F2 :- 
    pi x\ add-new-mappings H (B x) Map NewMap F1 F2.
  add-new-mappings H (ho.app L) Map NewMap F1 F3 :- 
    add-new-mappings-aux H L Map NewMap F1 F3.
  add-new-mappings _ (ho.con _) _ [] F F :- !.
  add-new-mappings _ N _ [] F F :- name N.

  type complete-mapping-under-ass ho.subst -> ho.assignment -> 
    mappings -> mappings ->  fo.subst -> fo.subst -> o.
  complete-mapping-under-ass H (ho.val Val) Map1 Map2 F1 F2 :- 
    add-new-mappings H Val Map1 Map2 F1 F2.
  complete-mapping-under-ass H (ho.abs Abs) Map1 Map2 F1 F2 :- 
    pi x\ complete-mapping-under-ass H (Abs x) Map1 Map2 F1 F2.

  type complete-mapping ho.subst -> ho.subst ->   
    mappings -> mappings -> fo.subst -> fo.subst -> o.
  complete-mapping _ [] L L F F.
  complete-mapping H [none | Tl] L1 L2 F1 F2 :-   
    complete-mapping H Tl L1 L2 F1 F2.
  complete-mapping H [some T0 | Tl] L1 L3 F1 F3 :-
    ho.deref-assmt H T0 T,
    complete-mapping-under-ass H T L1 L2 F1 F2, 
    append L1 L2 LAll,
    complete-mapping H Tl LAll L3 F2 F3.

  type decompile mappings -> links -> ho.subst -> 
    fo.subst -> fo.subst -> o.
  decompile Map1 L HO FO FO2 :- 
    commit-links L L1_ HO HO1, !,
    complete-mapping HO1 HO1 Map1 Map2 FO FO1,
    decompl-subst Map2 Map2 HO1 FO1 FO2.
\end{elpicode}

\section{Auxiliary functions}

\begin{elpicode}
  type fold4 (A -> A1 -> B -> B -> C -> C -> o) -> list A -> 
    list A1 -> B -> B -> C -> C -> o.
  fold4 _ [] [] A A B B.
  fold4 F [X|XS] [Y|YS] A A1 B B1 :- F X Y A A0 B B0, 
    fold4 F XS YS A0 A1 B0 B1.
  
  type len list A -> nat -> o.
  len [] z.
  len [_|L] (s X) :- len L X.
  
  \end{elpicode}
  