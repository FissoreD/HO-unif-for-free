\section*{Appendix}

Note that \elpiIn{(a infix b) c d} de-sugars to \elpiIn{(infix) a b c d}.

\section{The memory}

\input{code/mem}

\section{The meta language}
% \begin{figure*}
\begin{elpicode}
  typeabbrev subst list (option assignment).

  kind inctx type -> type.
  type abs (tm -> inctx A) -> inctx A.
  type val A -> inctx A.

  typeabbrev assignment (inctx tm).

  kind tm  type.
  type app list tm -> tm.
  type lam (tm -> tm) -> tm.
  type con string -> tm.
  type uva  address -> list tm -> tm.

  type (==l) tm -> tm -> subst -> subst ->  o.
  % congruence
  ((app L1) ==l (app L2)) S S1 :- fold2 (==l) L1 L2 S S1.
  ((lam F1) ==l (lam F2)) S S1 :- 
    pi x\ copy x x => ((F1 x) ==l (F2 x)) S S1.
  ((con X) ==l (con X)) S S.
  % set variables
  ((uva N Args) ==l T) S S1 :- 
    mem.set? N S F,!, move F Args T1, (T1 ==l T) S S1.
  (T ==l (uva N Args)) S S1 :- 
    mem.set? N S F,!, move F Args T1, (T ==l T1) S S1.
  % flex-flex
  ((uva M A1) ==l (uva N A2)) S1 S2 :- !, 
    pattern-fragment A1, pattern-fragment A2, 
    prune! M A1 N A2 S1 S2.
  ((uva N Args) ==l T) S S1 :- not_occ N S T, pattern-fragment Args, 
    bind T Args T1, mem.assign N S T1 S1.
  % variable assigment
  (T ==l (uva N Args)) S S1 :- not_occ N S T, pattern-fragment Args, 
    bind T Args T1, mem.assign N S T1 S1.
  (N ==l N) S S :- name N.

  % Note: We suppose the scopes to always be in PF
  type prune! address -> list ho.tm -> address -> 
              list ho.tm -> subst -> subst -> o.
  prune! N A  N A  S S :- !.
  prune! M A  N A  S1 S2 :- !, bind (uva M A) A Ass, 
    mem.assign N S1 Ass S2.
  prune! N A1 N A2 S1 S3 :- !,
    std.assert!(len A1 {len A2}) "Not typechecking", !,
    mem.new S1 W S2, prune-same-variable W A1 A2 [] Ass,
    mem.assign N S2 Ass S3.
  prune! N A1 M A2 S1 S4 :- !,
    mem.new S1 W S2, prune-diff-variables W A1 A2 Ass1 Ass2, 
    mem.assign N S2 Ass1 S3,
    mem.assign M S3 Ass2 S4. 

  type prune-same-variable address -> list tm -> list tm -> 
                            list tm -> assignment -> o.
  prune-same-variable N [] [] ACC (val (uva N Args)) :- 
    std.rev ACC Args.
  prune-same-variable N [X|XS] [X|YS] ACC (abs F) :- 
    pi x\ prune-same-variable N XS YS [x|ACC] (F x).
  prune-same-variable N [_|XS] [_|YS] ACC (abs F) :- 
    pi x\ prune-same-variable N XS YS ACC (F x).

  type prune-build-ass1 address -> list tm -> 
                        list bool -> assignment -> o.
  prune-build-ass1 N Acc [] (val (uva N Args)) :- 
    std.rev Acc Args.
  prune-build-ass1 N Acc [tt|L] (abs T) :- 
    pi x\ prune-build-ass1 N [x|Acc] L (T x).
  prune-build-ass1 N Acc [ff|L] (abs T) :- 
    pi x\ prune-build-ass1 N Acc L (T x).

  type build-order list nat -> list tm -> list tm -> o.
  build-order L T R :-
    len L Len, list-init Len z 
      (p\r\ sigma Index Elt\ index L p Index, nth Index T r) R.

  type prune-build-ass2 address -> list tm -> list bool -> 
                      list nat -> assignment -> o.
  prune-build-ass2 N Acc [] Pos (val (uva N Args)) :- 
    std.rev Acc Acc', build-order Pos Acc' Args.
  prune-build-ass2 N Acc [tt|L] Pos (abs T) :- 
    pi x\ prune-build-ass2 N [x|Acc] L Pos (T x).
  prune-build-ass2 N Acc [ff|L] Pos (abs T) :- 
    pi x\ prune-build-ass2 N Acc L Pos (T x).

  type keep list A -> A -> bool -> o.
  keep L A tt :- mem L A, !.
  keep _ _ ff.

  type prune-diff-variables address -> list tm -> list tm -> 
                            assignment -> assignment -> o.
  prune-diff-variables N Args1 Args2 Ass1 Ass2 :-
    std.map Args1 (keep Args2) Bits1, 
    prune-build-ass1 N [] Bits1 Ass1,
    std.map Args2 (keep Args1) Bits2, 
    std.filter Args1 (mem Args2) ToKeep1,
    std.filter Args2 (mem Args1) ToKeep2,
    std.map ToKeep2 (index ToKeep1) Pos,
    prune-build-ass2 N [] Bits2 Pos Ass2.

  type move assignment -> list tm -> tm -> o.
  move (abs Bo)        [H|L] R :- move (Bo H) L R.
  move (val A)         []    A :- !.
  move (val (uva N A)) L     (uva N X) :- append A L X.

  type beta tm -> list tm -> tm -> o.
  beta A [] A.
  beta (lam Bo) [H | L] R :- beta (Bo H) L R.
  beta (app A) L (app X) :- append A L X.
  beta (uva N A) L (uva N A') :- append A L A'.
  beta (con H) L (app [con H | L]).

  type not_occ_aux address -> subst -> tm -> o.
  not_occ_aux N S (uva M _) :- mem.unset? M S, not (N = M).
  not_occ_aux N S (uva M Args) :- mem.set? M S F, 
    move F Args T, not_occ_aux N S T.
  not_occ_aux N S (app L) :- forall1 (not_occ_aux N S) L.
  not_occ_aux N S (lam F) :- pi x\ not_occ_aux N S (F x).
  not_occ_aux _ _ (con _).
  not_occ_aux _ _ X :- name X.
  
  type not_occ  address -> subst -> tm -> o.
  not_occ N _ (uva N _).
  not_occ N S (uva M Args) :- mem.set? M S F, 
    move F Args T, not_occ N S T.
  not_occ N S (uva M Args) :- mem.unset? M S, 
    std.forall Args (not_occ_aux N S).
  not_occ _ _ (con _).
  not_occ N S (app L) :- not_occ_aux N S (app L).
  not_occ N S (lam L) :- pi x\ not_occ N S (L x).
  not_occ _ _ X :- name X.

  type copy tm -> tm -> o.
  copy (app L)   (app L') :- forall2 copy L L'.
  copy (lam T)   (lam T') :- pi x\ copy x x => copy (T x) (T' x).
  copy (uva N L) (uva N L') :- forall2 copy L L'.
  copy (con C)   (con C).
  copy N N :- name N.

  type bind tm -> list tm -> assignment -> o.
  bind T [] (val T') :- copy T T'.
  bind T [X | TL] (abs T') :- pi x\ copy X x => bind T TL (T' x).

  type deref subst -> tm -> tm -> o.
  deref S X _ :- (var S; var X), halt "flex deref".
  deref H (uva N L)  X         :- mem.set? N H T, 
    move T L X', !, deref H X' X.
  deref H (app L)   (app L1)   :- forall2 (deref H) L L1.
  deref _ (con X)   (con X).
  deref H (uva X L) (uva X L1) :- mem.unset? X H, 
    forall2 (deref H) L L1.
  deref H (lam F)   (lam G)    :- pi x\ deref H (F x) (G x).
  deref _ N         N          :- name N.

  type deref-assmt subst -> assignment -> assignment -> o.
  deref-assmt S (abs T) (abs R) :- pi x\ deref-assmt S (T x) (R x).
  deref-assmt S (val T) (val R) :- deref S T R.
\end{elpicode}
\section{The compiler}

\begin{elpicode}
  type use-binder fo.fm -> fo.fm -> o.
  use-binder N N.
  use-binder N (fo.fapp L) :- exists (use-binder N) L.
  use-binder N (fo.flam B) :- pi x\ use-binder N (B x).

  type maybe-eta fo.fm -> fo.fm -> list fo.fm -> o.
  maybe-eta N (fo.fapp[fo.fuva _|Args]) _ :- !,
    exists (x\ maybe-eta-of [] N x) Args, !. 
  maybe-eta N (fo.flam B) L :- !, pi x\ maybe-eta N (B x) [x | L].
  maybe-eta _ (fo.fapp [fo.fcon _|Args]) L :-
    split-last-n {len L} Args First Last,
    forall1 (x\ forall1 (y\ not (use-binder x y)) First) L,
    forall2 (maybe-eta-of []) {std.rev L} Last.

  type maybe-eta-of list fo.fm -> fo.fm -> fo.fm -> o.
  maybe-eta-of _ N N :- !.
  maybe-eta-of L N (fo.fapp[fo.fuva _|Args]) :- !, 
    % Head is flex -> if N is in Args, we can have eta
    forall1 (x\ exists (maybe-eta-of [] x) Args) [N|L]. 
  maybe-eta-of L N (fo.flam B) :- !, 
    pi x\ maybe-eta-of [x | L] N (B x).
  maybe-eta-of L N (fo.fapp [N|Args]) :-
    % Head is rigid -> to be an eta we consider also L
    last-n {len L} Args R,
    forall2 (maybe-eta-of []) R {std.rev L}.

  type locally-bound ho.tm -> o.
  type get-scope-aux ho.tm -> list ho.tm -> o.
  get-scope-aux (ho.con _) [].
  get-scope-aux (ho.uva _ L) L1 :- 
    forall2 get-scope-aux L R,
    flatten R L1.
  get-scope-aux (ho.lam B) L1 :- 
    pi x\ locally-bound x => get-scope-aux (B x) L1.
  get-scope-aux (ho.app L) L1 :- 
    forall2 get-scope-aux L R,
    flatten R L1.
  get-scope-aux X [X] :- name X, not (locally-bound X).
  get-scope-aux X [] :- name X, (locally-bound X).

  type get-scope ho.tm -> list ho.tm -> o.
  get-scope T Scope :- names N,
    get-scope-aux T ScopeDuplicata,
    std.filter N (mem ScopeDuplicata) Scope.

  type close-links (ho.tm -> links) -> links -> o.
  close-links (_\[]) [].
  close-links (v\[L|XS v]) [L|YS] :- !, close-links XS YS.
  close-links (v\[(L v)|XS v]) [ho.abs L|YS] :- !, 
    close-links XS YS.

  type comp-lam (fo.fm -> fo.fm) -> (ho.tm -> ho.tm) -> 
    mappings -> mappings -> links -> links -> ho.subst -> 
      ho.subst -> o.
  comp-lam F F1 Mappings1 Mappings2 L L2 S S1 :-
    pi x y\ (pi M L S\ comp x y M M L L S S) => 
      comp (F x) (F1 y) Mappings1 Mappings2 L (L1 y) S S1, 
        close-links L1 L2.

  type comp fo.fm -> ho.tm -> mappings -> mappings -> links -> 
    links -> ho.subst -> ho.subst -> o.
  comp (fo.fcon X) (ho.con X)        Map1 Map1 L1 L1 S1 S1.
  comp (fo.flam F) (ho.uva E0 Scope) Map1 Map2 L1 L3 S1 S3 :-
    (pi x\ maybe-eta x (F x) [x]), !,
      mem.new S1 E0 S2,
      comp-lam F F1 Map1 Map2 L1 L2 S2 S3,
      (pi x\ locally-bound x => get-scope (F1 x) Scope), 
      NewLink = ho.val(link-eta (ho.uva E0 Scope) (ho.lam F1)), 
      L3 = [NewLink| L2].
  comp (fo.flam F) (ho.lam F1)       Map1 Map2 L1 L2 S1 S2 :- 
    comp-lam F F1 Map1 Map2 L1 L2 S1 S2.
  comp (fo.fuva N) (ho.uva M []) Map1 Map2 L L S S1 :- 
    alloc Map1 Map2 (fv N) (hv M (arity z)) S S1.
  comp (fo.fapp [fo.fuva N|Ag]) (ho.uva M Scope) Map1 Map2 L1 L1 S1 S2 :-
    pattern-fragment Ag, !,
      fold6 comp Ag Scope Map1 Map1 L1 L1 S1 S1,
      len Ag Arity, 
      alloc Map1 Map2 (fv N) (hv M (arity Arity)) S1 S2.
  comp (fo.fapp [fo.fuva N|Ag]) (ho.uva M' Scope) Map1 Map3 L1 L3 S1 S4 :- !,
    pattern-fragment-prefix Ag PF NPF,
      fold6 comp PF PF1 Map1 Map1 L1 L1 S1 S1,
      fold6 comp NPF NPF1 Map1 Map2 L1 L2 S1 S2,
      len PF Arity, 
      alloc Map2 Map3 (fv N) (hv M (arity Arity)) S2 S3,
      get-scope (ho.app {append PF1 NPF1}) Scope, 
      mem.new S3 M' S4,
      L3 = [@val-link-beta (ho.uva M' Scope) (ho.app[ho.uva M PF1 | NPF1]) | L2].
  comp (fo.fapp A) (ho.app A1) Map1 Map2 L1 L2 S1 S2 :- 
    fold6 comp A A1 Map1 Map2 L1 L2 S1 S2.
  
  type make-eta-link-aux nat -> address -> address -> 
    list ho.tm -> links -> ho.subst -> ho.subst -> o.
  make-eta-link-aux z Ad1 Ad2 Scope1 L H1 H1  :-
    std.rev Scope1 Scope, eta-expand (ho.uva Ad2 Scope) @one T1,
    L = [@val-link-eta (ho.uva Ad1 Scope) T1].
  make-eta-link-aux (s N) Ad1 Ad2 Scope1 L H1 H3 :-
    std.rev Scope1 Scope, mem.new H1 Ad H2, 
    eta-expand (ho.uva Ad Scope) @one T2,
    (pi x\ make-eta-link-aux N Ad Ad2 [x|Scope1] (L1 x) H2 H3),
    close-links L1 L2,
    L = [@val-link-eta (ho.uva Ad1 Scope) T2 | L2].

  type make-eta-link nat -> nat -> address -> address -> 
          list ho.tm -> links -> ho.subst -> ho.subst -> o.
  make-eta-link (s N) z Ad1 Ad2 Vars L H H1 :- 
    make-eta-link-aux N Ad2 Ad1 Vars L H H1.
  make-eta-link z (s N) Ad1 Ad2 Vars L H H1 :- 
    make-eta-link-aux N Ad1 Ad2 Vars L H H1.
  make-eta-link (s N) (s M) Ad1 Ad2 Vars Links H H1 :-
    (pi x\ make-eta-link N M Ad1 Ad2 [x|Vars] (L x) H H1),
    close-links L Links.

  type deduplicate-mappings mappings -> mappings -> 
          ho.subst -> ho.subst -> links -> links -> o.
  deduplicate-mappings [] [] H H L L.
  deduplicate-mappings [(mapping (fv O) (hv M (arity LenM)) as X1) | Map1] Map2 H1 H3 L1 L3 :-
    take-list Map1 (mapping (fv O) (hv M' (arity LenM'))) _, !,
    make-eta-link LenM LenM' M M' [] New H1 H2,
    append New L1 L2,
    deduplicate-mappings Map1 Map2 H2 H3 L2 L3.
  deduplicate-mappings [A|As] [A|Bs] H1 H2 L1 L2 :- 
    deduplicate-mappings As Bs H1 H2 L1 L2, !.
\end{elpicode}

\section{The progress function}

\begin{elpicode}
  
  macro @one :- s z.

  type contract-rigid list ho.tm -> ho.tm -> ho.tm -> o.
  contract-rigid L (ho.lam F) T :- 
    pi x\ contract-rigid [x|L] (F x) T. % also checks H Prefix does not see x
  contract-rigid L (ho.app [H|Args]) T :- 
    std.rev L LRev, append Prefix LRev Args,
    if (Prefix = []) (T = H) (T = ho.app [H|Prefix]).

  type progress-eta-link ho.tm -> ho.tm -> ho.subst -> ho.subst -> links -> o.
  progress-eta-link (ho.app _ as T) (ho.lam x\ _ as T1) H H1 [] :- !, 
    ({eta-expand T @one} ==l T1) H H1.
  progress-eta-link (ho.con _ as T) (ho.lam x\ _ as T1) H H1 [] :- !, 
    ({eta-expand T @one} ==l T1) H H1.
  progress-eta-link (ho.lam _ as T) T1 H H1 [] :- !, 
    (T ==l T1) H H1.
  progress-eta-link (ho.uva _ _ as X) T H H1 [] :- 
    contract-rigid [] T T1, !, (X ==l T1) H H1.
  progress-eta-link (ho.uva Ad _ as T1) T2 H H [@val-link-eta T1 T2] :- !, 
    if (ho.not_occ Ad H T2) true fail.

  type is-in-pf ho.tm -> o.
  is-in-pf (ho.app [ho.uva _ _ | _]) :- !, fail.
  is-in-pf (ho.lam B) :- !, pi x\ is-in-pf (B x).
  is-in-pf (ho.con _).
  is-in-pf (ho.app L) :- forall1 is-in-pf L.
  is-in-pf N :- name N.
  is-in-pf (ho.uva _ L) :- pattern-fragment L.

  type arity ho.tm -> nat -> o.
  arity (ho.con _) z.
  arity (ho.app L) A :- len L A.

  type occur-check-err ho.tm -> ho.tm -> ho.subst -> o.
  occur-check-err (ho.con _) _ _ :- !.
  occur-check-err (ho.app _) _ _ :- !.
  occur-check-err (ho.lam _) _ _ :- !.
  occur-check-err (ho.uva Ad _) T S :-
    not (ho.not_occ Ad S T).

  type progress-beta-link-aux ho.tm -> ho.tm -> 
          ho.subst -> ho.subst -> links -> o.
  progress-beta-link-aux T1 T2 S1 S2 [] :-  is-in-pf T2, !,
    (T1 ==l T2) S1 S2.
  progress-beta-link-aux T1 T2 S S [@val-link-beta T1 T2] :- !.

  type progress-beta-link ho.tm -> ho.tm -> ho.subst -> 
        ho.subst -> links -> o.
  progress-beta-link T (ho.app[ho.uva V Scope | L] as T2) S S2 [@val-link-beta T T2] :- 
    arity T Arity, len L ArgsNb, ArgsNb >n Arity, !,
    minus ArgsNb Arity Diff, mem.new S V1 S1,
    eta-expand (ho.uva V1 Scope) Diff T1,
    ((ho.uva V Scope) ==l T1) S1 S2.

  progress-beta-link (ho.uva _ _ as T) (ho.app[ho.uva Ad1 Scope1 | L1] as T1) S1 S3 NewLinks :-
    append Scope1 L1 Scope1L,
    pattern-fragment-prefix Scope1L Scope2 L2,
    not (Scope1 = Scope2), !,
    mem.new S1 Ad2 S2,
    len Scope1 Scope1Len,
    len Scope2 Scope2Len,
    make-eta-link Scope1Len Scope2Len Ad1 Ad2 [] LinkEta S2 S3,
    if (L2 = []) (NewLinks = LinkEta, T2 = ho.uva Ad2 Scope2) 
      (T2 = ho.app [ho.uva Ad2 Scope2 | L2], 
      NewLinks = [@val-link-beta T T2 | LinkEta]).

  progress-beta-link T1 (ho.app[ho.uva _ _ | _] as T2) _ _ _ :- 
    not (T1 = ho.uva _ _), !, fail.

  progress-beta-link (ho.uva _ _ as T) (ho.app[ho.uva _ _ | _] as T2) S1 _ _ :- 
    occur-check-err T T2 S1, !, fail.

  progress-beta-link T1 (ho.app[ho.uva _ _ | _] as T2) H H [@val-link-beta T1 T2] :- !.

  progress-beta-link T1 (ho.app [Hd | Tl]) S1 S2 B :-
    ho.beta Hd Tl T3, 
    progress-beta-link-aux T1 T3 S1 S2 B.

  type solve-link-abs link -> links -> ho.subst -> ho.subst -> o.
  solve-link-abs (ho.abs X) R H H1 :- 
    pi x\ ho.copy x x => (pi S\ ho.deref S x x) => 
      solve-link-abs (X x) (R' x) H H1,
    close-links R' R.

  solve-link-abs (@val-link-eta A B) NewLinks S S1 :- !,
    progress-eta-link A B S S1 NewLinks.

  solve-link-abs (@val-link-beta A B) NewLinks S S1 :- !,
    progress-beta-link A B S S1 NewLinks.

  type take-link link -> links -> link -> links -> o.
  take-link A [B|XS] B XS :- link-abs-same-lhs A B, !.
  take-link A [L|XS] B [L|YS] :- take-link A XS B YS.

  type link-abs-same-lhs link -> link -> o.
  link-abs-same-lhs (ho.abs F) B :- 
    pi x\ link-abs-same-lhs (F x) B.
  link-abs-same-lhs A (ho.abs G) :- 
    pi x\ link-abs-same-lhs A (G x).
  link-abs-same-lhs (@val-link-eta (ho.uva N _) _) (@val-link-eta (ho.uva N _) _).

  type same-link-eta link -> link -> ho.subst -> ho.subst -> o.
  same-link-eta (ho.abs F) B H H1 :- !, pi x\ same-link-eta (F x) B H H1.
  same-link-eta A (ho.abs G) H H1 :- !, pi x\ same-link-eta A (G x) H H1.
  same-link-eta (@val-link-eta (ho.uva N S1) A)
                (@val-link-eta (ho.uva N S2) B) H H1 :-
    std.map2 S1 S2 (x\y\r\ r = ho.copy x y) Perm,
    Perm => ho.copy A A',
    (A' ==l B) H H1.

  type solve-links links -> links -> ho.subst -> ho.subst -> o.
  solve-links [] [] X X.
  solve-links [A|L1] [A|L3] S S2 :- take-link A L1 B L2, !,
    same-link-eta A B S S1, 
    solve-links L2 L3 S1 S2.
  solve-links [L0|L1] L3 S S2 :- deref-link S L0 L,
    solve-link-abs L R S S1, !,
    solve-links L1 L2 S1 S2, append R L2 L3.
\end{elpicode}

\section{The decompiler}

\begin{elpicode}
  
  type abs->lam ho.assignment -> ho.tm -> o.
  abs->lam (ho.abs T) (ho.lam R)  :- !, pi x\ abs->lam (T x) (R x).
  abs->lam (ho.val A) A.

  type commit-links-aux link -> ho.subst -> ho.subst -> o.
  commit-links-aux (@val-link-eta T1 T2) H1 H2 :- 
    ho.deref H1 T1 T1', ho.deref H1 T2 T2',
    (T1' ==l T2') H1 H2.
  commit-links-aux (@val-link-beta T1 T2) H1 H2 :- 
    ho.deref H1 T1 T1', ho.deref H1 T2 T2',
    (T1' ==l T2') H1 H2.
  commit-links-aux (ho.abs B) H H1 :- 
    pi x\ commit-links-aux (B x) H H1.

  type commit-links links -> links -> ho.subst -> ho.subst -> o.
  commit-links [] [] H H.
  commit-links [Abs | Links] L H H2 :- 
    commit-links-aux Abs H H1, !, commit-links Links L H1 H2.

  type decompl-subst mappings -> mappings -> ho.subst -> 
    fo.subst -> fo.subst -> o.
  decompl-subst _ [A|_] _ _ _ :- fail.
  decompl-subst _ [] _ F F.
  decompl-subst Map [mapping (fv VO) (hv VM _)|Tl] H F F2 :- 
    mem.set? VM H T, !, 
    ho.deref-assmt H T TTT,
    abs->lam TTT T', tm->fm Map T' T1, 
    fo.eta-contract T1 T2, mem.assign VO F T2 F1,
    decompl-subst Map Tl H F1 F2. 
  decompl-subst Map [mapping _ (hv VM _)|Tl] H F F2 :- 
    mem.unset? VM H, decompl-subst Map Tl H F F2.

  type tm->fm mappings -> ho.tm -> fo.fm -> o.
  tm->fm _ (ho.con C)  (fo.fcon C).
  tm->fm L (ho.lam B1) (fo.flam B2) :- 
    pi x y\ tm->fm _ x y => tm->fm L (B1 x) (B2 y).
  tm->fm L (ho.app L1) T :- forall2 (tm->fm L) L1 [Hd|Tl], 
    fo.mk-app Hd Tl T.
  tm->fm L (ho.uva VM TL) T :- mem L (mapping (fv VO) (hv VM _)), 
    forall2 (tm->fm L) TL T1, fo.mk-app (fo.fuva VO) T1 T.

  type add-new-mappings-aux ho.subst -> list ho.tm -> mappings -> 
        mappings ->  fo.subst -> fo.subst -> o.
  add-new-mappings-aux _ [] _ [] S S.
  add-new-mappings-aux H [T|Ts] L L2 S S2 :- 
    add-new-mappings H T L L1 S S1, 
    add-new-mappings-aux H Ts L1 L2 S1 S2.

  type add-new-mappings ho.subst -> ho.tm -> mappings -> 
      mappings ->  fo.subst -> fo.subst -> o.
  add-new-mappings _ (ho.uva N _) Map [] F1 F1 :- 
    mem Map (mapping _ (hv N _)), !.
  add-new-mappings H (ho.uva N L) Map [Map1 | MapL] F1 F3 :-
    mem.new F1 M F2,
    len L Arity, Map1 = mapping (fv M) (hv N (arity Arity)),
    add-new-mappings H (ho.app L) [Map1 | Map] MapL F2 F3.
  add-new-mappings H (ho.lam B) Map NewMap F1 F2 :- 
    pi x\ add-new-mappings H (B x) Map NewMap F1 F2.
  add-new-mappings H (ho.app L) Map NewMap F1 F3 :- 
    add-new-mappings-aux H L Map NewMap F1 F3.
  add-new-mappings _ (ho.con _) _ [] F F :- !.
  add-new-mappings _ N _ [] F F :- name N.

  type complete-mapping-under-ass ho.subst -> ho.assignment -> 
    mappings -> mappings ->  fo.subst -> fo.subst -> o.
  complete-mapping-under-ass H (ho.val Val) Map1 Map2 F1 F2 :- 
    add-new-mappings H Val Map1 Map2 F1 F2.
  complete-mapping-under-ass H (ho.abs Abs) Map1 Map2 F1 F2 :- 
    pi x\ complete-mapping-under-ass H (Abs x) Map1 Map2 F1 F2.

  type complete-mapping ho.subst -> ho.subst ->   
    mappings -> mappings -> fo.subst -> fo.subst -> o.
  complete-mapping _ [] L L F F.
  complete-mapping H [none | Tl] L1 L2 F1 F2 :-   
    complete-mapping H Tl L1 L2 F1 F2.
  complete-mapping H [some T0 | Tl] L1 L3 F1 F3 :-
    ho.deref-assmt H T0 T,
    complete-mapping-under-ass H T L1 L2 F1 F2, 
    append L1 L2 LAll,
    complete-mapping H Tl LAll L3 F2 F3.

  type decompile mappings -> links -> ho.subst -> 
    fo.subst -> fo.subst -> o.
  decompile Map1 L HO FO FO2 :- 
    commit-links L L1_ HO HO1, !,
    complete-mapping HO1 HO1 Map1 Map2 FO FO1,
    decompl-subst Map2 Map2 HO1 FO1 FO2.
\end{elpicode}

\section{Auxiliary functions}

\begin{elpicode}
  type fold4 (A -> A1 -> B -> B -> C -> C -> o) -> list A -> 
    list A1 -> B -> B -> C -> C -> o.
  fold4 _ [] [] A A B B.
  fold4 F [X|XS] [Y|YS] A A1 B B1 :- F X Y A A0 B B0, 
    fold4 F XS YS A0 A1 B0 B1.
  
  type len list A -> nat -> o.
  len [] z.
  len [_|L] (s X) :- len L X.
  
  \end{elpicode}
  