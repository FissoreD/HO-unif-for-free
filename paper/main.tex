\documentclass[sigconf,natbib=false,review]{acmart}
\usepackage[]{biblatex}

\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}
\addbibresource{bib.bib}

\usepackage{myTools}
\usepackage{macros}

% TODO: set this fields
%\setcopyright{cc}
%\setcctype{by}
\copyrightyear{2024}
\acmYear{XXXX 2024}
\acmBooktitle{YYY}
\acmDOI{ZZZZZZZZZZZZ}    


% \xspaceaddexceptions{]\}}

\def\elpi{\proglang{elpi}}
\def\coqelpi{\proglang{coq-elpi}}
\def\lambdaprolog{\proglang{$\lambda$-prolog}}
\def\coq{\proglang{coq}}

\newcommand{\library}[1]{\textit{#1}\xspace}
\def\stdpp{\library{stdpp}}
\def\iris{\library{iris}}

\newcommand*{\acronym}[1]{\texttt{#1}\xspace}

\def\ol{\acronym{ol}} % object language
\def\ml{\acronym{ml}} % meta language
\def\lf{\acronym{lf}} % logical framework
\def\ho{\acronym{ho}} % higher order
\def\Forall{$\forall$}

\newcommand{\EqualRel}{\ensuremath{=}}
\newcommand{\nEqualRel}{\ensuremath{\new}}
\newcommand{\UnifRel}{\ensuremath{\simeq}}
\newcommand{\nUnifRel}{\ensuremath{\not\simeq}}

\newcommand{\Uo}{\ensuremath{\UnifRel_o}\xspace}
\newcommand{\nUo}{\ensuremath{\nUnifRel_o}\xspace}
\newcommand{\Eo}{\ensuremath{\EqualRel_o}\xspace}
\newcommand{\nEo}{\ensuremath{\nEqualRel_o}\xspace}

\newcommand{\Ue}{\ensuremath{\UnifRel_\lambda}\xspace}
\newcommand{\nUe}{\ensuremath{\nUnifRel_\lambda}\xspace}
\newcommand{\Ee}{\ensuremath{\EqualRel_\lambda}\xspace}
\newcommand{\nEe}{\ensuremath{\nEqualRel_\lambda}\xspace}
\newcommand{\llambda}{\ensuremath{\mathcal{L}_\lambda}\xspace}

\newcommand{\linkbeta}{\texttt{link-}\ensuremath{\beta}\xspace}
\newcommand{\linketa}{\texttt{link-}\ensuremath{\eta}\xspace}

\newcommand{\Fo}{\ensuremath{\mathcal{F}_{\!o}\xspace}} % space non va
\newcommand{\Ho}{\ensuremath{\mathcal{H}_o}\xspace}

\newcommand*{\eqtau}{\ensuremath{\mathrel{\overset{\mathrm{\tau}}{=}}}}

\newcommand{\linketaM}[3]{\texttt{#1 |- #2 =$\eta$= #3}}
\newcommand{\linkbetaM}[3]{\texttt{#1 |- #2 =$\beta$= #3}}

\begin{document}

\title{HO unification from object language to meta language} 

\author{Enrico Tassi}
\email{enrico.tassi@inria.fr}
\affiliation{%
  \institution{Université Côte d'Azur, Inria}
  % \city{Nice}
  \country{France}}

\author{Davide Fissore}
\email{davide.fissore@inria.fr}
\affiliation{%
  \institution{Université Côte d'Azur, Inria}
  % \city{Nice}
  \country{France}}

\begin{abstract}
  Specifying and implementing a logic from scratch requires significant effort.
  Logical Frameworks and Higher Order Logic Programming Languages provide
  dedicated, high-level Meta Languages (ML) to facilitate this task in two
  key ways: 1) variable binding and substitution are simplified when ML binders
  represent object logic ones; 2) proof construction, and even proof search, is
  greatly simplified by leveraging the unification procedure provided by the ML.
  Notable examples of ML are Elf~\cite{elf}, Twelf~\cite{twelf},
  $\lambda$Prolog~\cite{miller_nadathur_2012} and
  Isabelle~\cite{10.1007/978-3-540-71067-7_7}
  which have been utilized to implement various formal systems such as
  First Order Logic~\cite{felty88cade},
  Set Theory~\cite{10.1007/BF00881873},
  Higher Order Logic~\cite{books/sp/NipkowPW02}, and even the Calculus of
  Constuctions~\cite{felty93lics}.
  
  The object logic we are interested in is Coq's~\cite{Coq-refman}
  Dependent Type Theory (DTT),
  for which we aim to implement a unification procedure \Uo using the ML
  Elpi~\cite{dunchev15lpar}, a dialect of $\lambda$Prolog.
  Elpi's equational theory comprises
  $\eta\beta$ equivalence and comes equipped with a
  higher order unification procedure \Ue restricted to the pattern
  fragment~\cite{miller92jsc}.
  We want \Uo to be as powerful as \Ue but on the object logic DTT.
  Elpi also comes with an encoding for DTT that works well
  for meta-programming~\cite{tassi:hal-01637063,tassi:hal-01897468,gregoire:hal-03800154,newtc}.
  Unfortunately this encoding, which we refer to as \Fo,
  ``underuses'' \Ue by restricting it to first-order unification problems only. 
  To address this issue, we propose a better-behaved encoding, \Ho,
  demonstrate how to map unification problems in \Fo{}
  to related problems in \Ho, and illustrate
  how to map back the unifiers found by \Ue, effectively implementing
   \Uo on top of \Ue for the encoding \Fo.
   
  We apply this technique to the implementation of a type-class~\cite{wadler89}
  solver for Coq~\cite{Coq-refman}.
  Type-class solvers are proof search procedures based on
  unification that back-chain designated lemmas, providing essential
  automation to widely used 
  Coq libraries such as Stdpp/Iris~\cite{JUNG_KREBBERS_JOURDAN_BIZJAK_BIRKEDAL_DREYER_2018}
  and TLC~\cite{10.1007/978-3-642-14052-5_15}. These two libraries
  constitute our test bed.
\end{abstract} 

\keywords{Logic Programming, Meta-Programming, Higher-Order Unification, Proof Automation}

\maketitle

\section{Introduction}
\label{sec:intro}

Specifying and implementing a logic from scratch requires significant effort.
Logical Frameworks and Higher Order Logic Programming Languages provide
dedicated, high-level Meta Languages (ML) to facilitate this task in two
key ways: 1) variable binding and substitution are simplified when ML binders
represent object logic ones; 2) proof construction, and even proof search, is
greatly simplified by leveraging the unification procedure provided by the ML.
Notable examples of ML are Elf~\cite{elf}, Twelf~\cite{twelf},
$\lambda$Prolog~\cite{miller_nadathur_2012} and
Isabelle~\cite{10.1007/978-3-540-71067-7_7}
which have been utilized to implement various formal systems such as
First Order Logic~\cite{felty88cade},
Set Theory~\cite{10.1007/BF00881873},
Higher Order Logic~\cite{books/sp/NipkowPW02}, and even the Calculus of
Constuctions~\cite{felty93lics}.

The object logic we are interested in is Coq's~\cite{Coq-refman}
Dependent Type Theory (DTT), and we want to code a type-class~\cite{wadler89}
solver for Coq~\cite{Coq-refman} using the Coq-Elpi~\cite{tassi:hal-01637063}
meta programming framework.
Type-class solvers are unification based proof search procedures
that combine a set of designated lemmas in order to providing essential
automation to widely used Coq libraries.

As the running example we take the \coqIn{Decide} type class,
from the Stdpp~\cite{JUNG_KREBBERS_JOURDAN_BIZJAK_BIRKEDAL_DREYER_2018}
library. The class identifies predicates equipped with a decision procedure.
The following three designated lemmas (called \coqIn{Instances} in the
type-class jargon) state that: 1) the type \coqIn{fin n}, of natural numbers
smaller than \coqIn{n} is finite; 2) the predicate \coqIn{nfact n nf},
linking a natural number \coqIn{n} to its prime factors \coqIn{nf}, is decidable;
3) the universal closure of a predicate has a decision procedure if the
predicate has and if its domain is finite.

\begin{coqcode}
Instance fin_fin n : Finite (fin n).              (* r1 *)
Instance nfact_dec n nf : Decision (nfact n nf).  (* r2 *)
Instance forall_dec A P : Finite A ~$\to$~             (* r3 *)
  ~$\forall$~x:A, Decision (P x) ~$\to$~ Decision (~$\forall$~x:A, P x).
\end{coqcode}

\noindent Under this context of instances a type-class solver is able to prove
the following statement automatically by back-chaining.

\begin{coqcode}
  Check _ : Decision (forall y: fin 7, nfact y 3).       ~\customlabel{goal:g}{(g)}~
\end{coqcode}

\noindent
The encoding of DTT provided by Elpi, that we will discuss at length later in
section~\ref{sec:encodings,sec:lang-spec} and ~\ref{}, is an Higher Order Abstract
Syntax (HOAS) datatype \elpiIn{tm} featuring (among others) the following
constructors:

\begin{elpicode}
type lam  tm -> (tm -> tm) -> tm.     % lambda abstraction
type app  list tm -> tm.              % n-ary application
type all  tm -> (tm -> tm) -> tm.     % forall quantifier
type con  string -> tm.               % constants
\end{elpicode}

\noindent
Following standard $\lambda$Prolog~\cite{miller_nadathur_2012}
the concrete syntax to abstract, at the meta level, an expression
\elpiIn{e} over a variable \elpiIn{x}
is <<\elpiIn{x\ e}>>, and square brackets denote a list of
terms separated by comma. As an example we show the encoding of the Coq term
<<\coqIn{~$\forall$~y:t, nfact y 3}>>:

\begin{elpicode}
all (con"t") y\ app[con"nfact", y, con"3"]
\end{elpicode}

\noindent
We now illustrate the encoding of the three instances above as higher-order
logic-programming rules: capital letters denote rule
parameters; \elpiIn{:-} separates the rule's head from the premises;
\elpiIn{pi w\ p} introduces a fresh nominal constant \elpiIn{w}
for the premise \elpiIn{p}.

\begin{elpicode}
finite (app[con"fin", N]).                            ~\customlabel{clause:r1}{(r1)}~
decision (app [con"nfact", N, NF]).                   ~\customlabel{clause:r2}{(r2)}~
decision (all A x\ app[P, x]) :- finite A,            ~\customlabel{clause:r3}{(r3)}~
  pi w\ decision (app[P, w]).
\end{elpicode}

\noindent
Unfortunately this translation of rule \ref{clause:r3} uses the
predicate \coqIn{P} as a first order term: for the meta
language its type is \elpiIn{tm}.
If we try to backchain the rule \ref{clause:r3} on the encoding of the goal
\ref{goal:g} given below
  
\begin{elpicode}
decision (all (app[con"fin", con"7"]) y\                 
  app[con"nfact", y, con"3"]).
\end{elpicode}

\noindent
we obtain an unsolvable unification problem \ref{problem:p}:
the two lists of terms have different lengths!
%The root cause is that
%\ref{problem:p} is an higher order in DTT, but becomes
%first order in the meta language due to the ``naive'' encoding.

\begin{elpicode}
app[con"nfact", y, con"3"] = app[P, y]                 ~\customlabel{problem:p}{(p)}~
\end{elpicode}

\noindent
In this paper we study a more sophisticated encoding of Coq terms allowing
us to rephrase the problematic rule \ref{clause:r3} as follows:

\begin{elpicode}
decision (all A x\ Pm x) :- link Pm P A, finite A,   ~\customlabel{clause:r3a}{(r3a)}~
  pi x\ decision (app[P, x]).
\end{elpicode}

\noindent
Since \elpiIn{Pm} is an higher-order unification variable
of type \elpiIn{tm -> tm},
with \elpiIn{x}
in its scope, the unification problem \ref{problem:pa}
admits one solution:

\begin{elpicode}
app[con"nfact", y, con"3"] = Pm y                     ~\customlabel{problem:pa}{(p')}~
Pm = x\ app[con"nfact", x, con"3"]     % assignment for Pm
A = app[con"fin", con"7"]              % assignment for A
\end{elpicode}
  
\noindent
After unifying the head of rule \ref{clause:r3a} with the goal, Elpi runs
the premise <<\elpiIn{link Pm A P}>> that is in charge of bringing the
assignment for \elpiIn{Pm} back to the domain \elpiIn{tm} of Coq terms:

\begin{elpicode}
P = lam A a\ app[con"nfact", a, con"3"]
\end{elpicode}

\noindent
This simple example is sufficient to show that the encoding we seek
is not trivial and does not only concern the head of rules, but the entire sequence
of unification problems that constitute the execution of a logic program.
In fact
the solution for \elpiIn{P} above generates a
(Coq) $\beta$-redex in the second premise (the predicate
under the \elpiIn{pi w\ }\hspace{-0.4em}):

\begin{elpicode}
decision (app[lam A (a\ app[con"nfact", a, con"3"]), w])
\end{elpicode}

\noindent
In turn this redex prevents the rule \ref{clause:r2} to backchain properly since
the following unification problem has no solution:

\begin{elpicode}
app[lam A (a\ app[con"nfact", a, con"3"]), x] =
app[con"nfact", N, NF]
\end{elpicode}
\noindent
~\\
The root cause of the problems we sketched in the running example
is that the unification procedure \Ue of the meta language is not aware
of the equational theory of the object logic, even if both theories
include $\eta\beta$-conversion and admit most general
unifiers for unification problems in the pattern fragment \llambda~\cite{miller92jsc}.

\paragraph{Contributions}
In this paper we discuss alternative encodings of Coq in
Elpi (Section~\ref{sec:encodings}), then we identify a minimal language \Fo{}
in which the problems sketched here can be fully described.
We then detail an encoding \elpiIn{comp} from \Fo{} to \Ho (the language of
the meta language) and a decoding \elpiIn{decomp} to relate the unifiers
bla bla.. TODO citare Teyjus.

\section{Problem statement} %%%%%%%%%%%%%%%%%%%%%%
\label{sec:encodings}

The equational theory of Coq's Dependent Type Theory is very rich. In
addition to the usual $\eta\beta$-equivalence for functions, terms (hence types)
are compared up to proposition unfolding and fixpoint unrolling. Still,
for efficiency and predictability reasons, most form of automatic proof search
employ a unification procedure that captures a simpler one,
just $\eta\beta$, and that solves higher-order problems
restricted to the pattern fragment $\llambda$~\cite{miller92jsc}.
We call this unification procedure \Uo{}.

The equational theory of the meta language Elpi that we want to use to
implement a form of proof automation is strikingly similar, since it
it comprises $\eta\beta$ (for the meta language functions), and the
unification procedure \Ue{} solves higher-order problems in
$\llambda$.

In spite of the similarity the link between \Ue{} and \Uo{} is not trivial,
since the abstraction and application term constructors
the two unification procedures deal with are different. For example

\begin{tabular}{lcl}
\elpiIn{x\ f x} & \Ue{} & \elpiIn{f}\\
\elpiIn{lam A x\ app[con"f", x]} & \Uo{} & \elpiIn{con"f"}\\
\elpiIn{lam A x\ app[con"f", x]} & \nUe{} & \elpiIn{con"f"} \\
\elpiIn{P x} & \Ue{} & \elpiIn{x}\\
\elpiIn{app[P, x]} & \Uo{} & \elpiIn{x}\\
\elpiIn{app[P, x]} & \nUe{} & \elpiIn{x}\\
\end{tabular}

\noindent
One could ignore this similarity, and ``just'' describe the object language
unification procedure in the meta language, that is crafting a \elpiIn{unif}
predicate to be used as follows in rule \ref{clause:r3}:

\begin{elpicode}
decision X :- unif X (all A x\ app[P, x]), finite A,
  pi x\ decision (app[P, x]).
\end{elpicode}

\noindent
This choice would underuse the logic programming engine provided by
the metalanguage since by removing any datum from the head of rules
indexing degenerates. Moreover the unification procedure built in the
meta language is likely to be faster than one implemented in it,
especially if the meta language is interpreted as Elpi is. 
  
To state precisely the problem we solve we need a \Fo{} representation
of DTT terms and a \Ho one.
We call \Eo the equality over ground terms in \Fo,
\Ee the equality over ground terms in \Ho,
\Uo the unification procedure we want to implement and
\Ue the one provided by the meta language.
TODO extend \Eo and \Ee with reflexivity on uvars.

\newcommand{\specunif}[3]{
  #3_i \in \llambda \Rightarrow %
    \exists \rho, %
      \rho #3_1 #1 \rho #3_2  %
        \Leftrightarrow #3_1 #2 #3_2 \mapsto \rho' \subseteq \rho 
}


\newcommand{\unifcorrect}[3]{
  % \forall \rho #3_1 #3_2, %
    % \{#3_1, #3_2\} \subseteq \llambda \Rightarrow %
    #3_i \in \llambda \Rightarrow
      #3_1 #2 #3_2 \mapsto \rho
        \Rightarrow 
          \rho #3_1 #1 \rho #3_2  %
}

\newcommand{\unifcomplete}[3]{
  % \forall #3_1 #3_2, %
    % \{#3_1, #3_2\} \subseteq \llambda \Rightarrow %
    #3_i \in \llambda \Rightarrow
      % \forall \rho, %
        \rho #3_1 #1 \rho #3_2  %
          \Rightarrow \exists \rho', #3_1 #2 #3_2 \mapsto \rho' \land \rho' \subseteq \rho 
}

We write $t_1 \Ue t_2 \mapsto \sigma$ when $t_1$ and $t_2$ unify
with substitution $\sigma$; we write $\sigma t$ for the application of
the substitution to $t$, and $\sigma X = \{ \sigma t | t \in X\}$ when
$X$ is a set; we write $\sigma \subseteq \sigma'$ when $\sigma$ is more
general than $\sigma'$. We assume that the unification of our meta
language is correct:
%
\begin{gather}
  \unifcorrect{\Ee}{\Ue}{t} \label{prop:correct-ml}\\
  \unifcomplete{\Ee}{\Ue}{t}
\end{gather}

\newcommand{\C}[4]{\ensuremath{\langle #1 \rangle}\mapsto(#2,#3,#4)}
\newcommand{\D}[4]{\ensuremath{\langle #1,#2,#3 \rangle^{-1}\mapsto #4}}

We illustrate a compilation $\C{s}{t}{m}{l}$ that
maps a term $s$ in \Fo{} to a term $t$ in \Ho, a variable mapping $m$ and
list of links $l$.
The variable map connects unification variables in \Ho with variables
in \Fo{} and is used to ``decompile'' the assignment,
$\D{\sigma}{m}{l}{\rho}$. Links represent problematic sub-terms which
are linked to the unification variable that stands in their place in the
compiled term. These links are checked for or progress XXX improve....

We represent a logic program \emph{run} in \Fo as
a list \emph{steps} $p$ of length $\mathcal{N}$. Each made of a
unification problem between terms $\mathcal{S}_{p_l}$ and
$\mathcal{S}_{p_r}$ taken from the set of all terms $\mathcal{S}$.
The composition of these steps starting from the
empty substitution $\rho_0$ produces the final
substitution $\rho_\mathcal{N}$.
\footnote{If the same rule is used multiple time in a run we
just consider as many copies as needed of the terms composing the
rules, with fresh unification variables each time}
The initial here $\rho_0$ is the empty substitution
%
\newcommand{\progress}{\ensuremath{\mathrm{check}}\xspace}
\newcommand{\fstep}{\ensuremath{\mathrm{fstep}}\xspace}
\newcommand{\hstep}{\ensuremath{\mathrm{hstep}}\xspace}
\newcommand{\frun}{\ensuremath{\mathrm{frun}}\xspace}
\newcommand{\hrun}{\ensuremath{\mathrm{hrun}}\xspace}
\newcommand{\stepF}[4]{\ensuremath{\fstep(#1,#2,#3) \mapsto #4}}
\newcommand{\stepFD}[5]{%
\ensuremath{#3 #1_{#2_l} \Uo #3 #1_{#2_r} \mapsto #4 \land #5 = #3 \cup #4}}
\newcommand{\stepH}[5]{\ensuremath{\hstep(#1,#2,#3,#4) \mapsto #5}}
\newcommand{\stepHD}[6]{\ensuremath{%
#3 #1_{#2_l} \Ue #3 #1_{#2_r} \mapsto #4 \land \progress(#6,#3 \cup #4) \mapsto #5}}
\newcommand{\runF}[3]{\ensuremath{\frun(#1,#2) \mapsto #3_{#2}}}
\newcommand{\runFD}[2]{\ensuremath{%
\bigwedge_{p = 1}^{#2} \stepF{#1}{p}{\rho_{p-1}}{\rho_{p}}}}
\newcommand{\runH}[3]{\ensuremath{\hrun(#1,#2) \mapsto #3_{#2}}}
\newcommand{\runHD}[3]{\ensuremath{%
\bigwedge_{p = 1}^{#2} \stepH{#1}{p}{\sigma_{p-1}}{#3}{\sigma_{p}}}}
\newcommand{\deff}{\ensuremath{\stackrel{{\scriptscriptstyle def}}{=\!=\!\!\!=}}}
$$
\begin{array}{l}
\stepF{\mathcal{S}}{p}{\rho}{\rho''}
\deff
\stepFD{\mathcal{S}}{p}{\rho}{\rho'}{\rho''}\vspace{2pt}\\
\runF{\mathcal{S}}{\mathcal{N}}{\rho}
\deff
\runFD{\mathcal{S}}{\mathcal{N}}
\end{array}
$$

We simulate each run in \Fo{} with a run in \Ho as follows.
Note that $\sigma_0$ is the empty substitution.
$$
\begin{array}{l}
\stepH{\mathcal{T}}{p}{\sigma}{\mathbb{L}}{\sigma''} \deff\vspace{2pt}\\
  \qquad\stepHD{\mathcal{T}}{p}{\sigma}{\sigma'}{\sigma''}{\mathbb{L}}\vspace{2pt}\\
\runH{\mathcal{S}}{\mathcal{N}}{\rho} \deff \vspace{2pt}\\
  \qquad \mathcal{T} \times \mathbb{M} \times \mathbb{L} = \{ (t_j,m_j,l_j) | s_j \in \mathcal{S}, \C{s_j}{t_j}{m_j}{l_j} \}\vspace{2pt}\\
  \qquad \runHD{\mathcal{T}}{\mathcal{N}}{\mathbb{L}}\vspace{2pt}\\
  \qquad \D{\sigma_{\mathcal{N}}}{\mathbb{M}}{\mathbb{L}}{\rho_{\mathcal{N}}}
\end{array}
$$

\noindent
Here \hstep{} is made of two sub-steps: a call to \Ue (on the compiled
terms) and a call to \progress{} on the set of links. We claim the following:

\begin{proposition}[Simulation]\label{prop:sumul}
$\forall \mathcal{S}, \forall \mathcal{N}$
$$
  \runF{\mathcal{S}}{\mathcal{N}}{\rho}
  \Leftrightarrow
  \runH{\mathcal{S}}{\mathcal{N}}{\rho}
$$
\end{proposition}

\noindent
That is, the two executions give the same result. Moreover:

\begin{proposition}[Simulation fidelity]\label{prop:fidelity}
In the context of~ \hrun, if $~\mathcal{T} \subseteq \llambda$ we have that
$\forall p \in 1 \ldots \mathcal{N}$
$$
\stepF{\mathcal{S}}{p}{\rho_{p-1}}{\rho_p}
\Leftrightarrow
\stepH{\mathcal{T}}{p}{\sigma_{p-1}}{\mathbb{L}}{\sigma_p}
$$
\end{proposition}
\noindent
In particular this property guarantees that a \emph{failure} in the \Fo{} run
is matched by a failure in \Ho{} \emph{at the same step}. We consider this
property very important from a practical point of view since it guarantees
that the execution traces are strongly related and in turn this enables a user
to debug a logic program in \Fo{} by looking at its execution trace in
\Ho{}.

XXX permuting hrun does not change the final result if check dooes not fail eagerly

XXX if we want to apply heuristics, we can apply them in decomp to avoid committing to
a non MGU too early


We can define $s_1 \Uo{} s_2$ by specializing the code of \hrun{} to
$\mathcal{S} = \{ s_1, s_2 \}$ as follows:
%
$$
\begin{array}{l}
s_1 \Uo s_2 \mapsto \rho \deff \vspace{2pt}\\
\quad\C{s_1}{t_1}{m_1}{l_1} \land \C{s_2}{t_2}{m_2}{l_2}\vspace{2pt}\\
\quad    t_1 \Ue t_2 \mapsto \sigma' \land
    \progress~(\{l_1,l_2\},\sigma') \mapsto \sigma'' \land\vspace{2pt}\\
\quad \D{\sigma''}{\{m_1,m_2\}}{\{l_1,l_2\}}{\rho}
\end{array}
$$

\begin{proposition}[Properties of \Uo{}]
\begin{gather}
  \unifcorrect{\Eo}{\Uo}{s}\label{prop:correct}\\
\unifcomplete{\Eo}{\Uo}{s}\label{prop:complete}\\
% \forall \rho'\rho, 
  \rho s_1 \Eo \rho s_2 \Rightarrow
  \rho' \subseteq \rho \Rightarrow
  \rho's_i \in \llambda \Rightarrow
  \rho' s_1 \Uo \rho' s_2 \label{prop:simulation}
\end{gather}
\end{proposition}

Properties \ref{prop:correct} and \ref{prop:complete} state, respectively, that
in \llambda the implementation of \Uo is correct, complete and returns the most
general unifier.

Property \ref{prop:simulation} states that \Uo, hence our compilation scheme,
is resilient to unification problems outside \llambda solved by
a third party. We believe this property is of practical interest since we
want the user to be able to add heuristics via hand written rules
to the ones obtained by our compilation scheme. A Typical example
is the following problem \ref{problem:q} that is outside \llambda:

\begin{elpicode}
app [F, con"a"] = app[con"f", con"a", con"a"]          ~\customlabel{problem:q}{(q)}~
F = lam x\ app[con"f",x,x]                             ~\customlabel{heuristic:h}{(h)}~
\end{elpicode}

\noindent
Instead of rejecting it our scheme accepts it and guarantees that if
\ref{heuristic:h} is given (after the compilation part of the scheme, as
a run time hint) then ...


\subsection{The intuition in a nutshell}
\label{sec:nutshell}
A term $s$ is compiled in a term $t$ where any
``problematic'' subterm $p$ is replaced by a fresh unification variable $h$
and an accessory link that represent a suspended unification problem
$h \Ue p$. As a result \Ue is ``well behaved'' on $t$, meaning it does not
contradict \Eo (as it would do on ``problematic'' terms).
We now define ``problematic'' and ``well behaved'' more formally.

\newcommand{\maybeeta}{\ensuremath{\Diamond\eta}\xspace}
\newcommand{\maybebeta}{\ensuremath{\Diamond\beta}\xspace}
\begin{definition}[\maybeeta]
  $\maybeeta = \{ t ~|~ \exists \rho, \rho t ~\mathrm{is~an~eta~expansion} \}$
\end{definition}

\noindent
An example of term $t$ in \maybeeta{} is
$\lambda x.\lambda y.F~y~x$
since the substitution
$\rho = \{ F \mapsto \lambda a.\lambda b.fba\}$
makes $\rho t = \lambda x.\lambda y.f x y$
that is the eta long form of $f$.

\begin{definition}[\maybebeta]
  $\maybebeta = \{ X t_1 \ldots t_n ~|~ X t_1 \ldots t_n \not\in \llambda \}$.
\end{definition}

\noindent
An example of $t$ in \maybebeta{} is $F a$ for a constant $a$. Note however tha
an oracle could provide an assignment $\rho = \{ F \mapsto \lambda x.x\}$
that makes the resulting term fall outside of \maybebeta. 

\newcommand{\subterm}[1]{\ensuremath{\mathcal{P}(#1)}}
\begin{definition}[Subterm \subterm{t}]
$$
\begin{array}{l}
t \in \subterm{t}\\
t = f t_1\ldots t_n \Rightarrow \subterm{t_i} \subseteq \subterm{t} \land f \in \subterm{t}\\
t = \lambda x.t' \Rightarrow \subterm{t'} \subseteq \subterm{t}\\
\end{array}
$$
\end{definition}

\noindent
We write $\subterm{X} = \bigcup_{t\in X} \subterm{t}$.

\newcommand{\wellb}{\ensuremath{\mathcal{W}}}
\begin{definition}[Well behaved set]
Given a set of terms $X \subseteq \Ho{}$,
$$
\wellb(X) \Leftrightarrow \forall t \in \subterm{X}, t \not\in (\maybebeta{} ~\cup~ \maybeeta{})
$$
\end{definition}

\noindent

\begin{proposition}[\wellb{}-preservation]\label{prop:nf}
$\forall \mathcal{T}, \forall \mathbb{L}, \forall p, \forall \sigma, \forall \sigma'$
$$
\wellb(\sigma\mathcal{T}) \land
\stepH{\mathcal{T}}{p}{\sigma}{\mathbb{L}}{\sigma'}
\Rightarrow \wellb(\sigma' \mathcal{T})
$$
\end{proposition}

\noindent
A less formal way to state \ref{prop:nf} is that \hstep{} never
``commits'' an unneeded $\lambda$-abstraction in $\sigma$ (a $\lambda$
that could be erased by an $\eta$-contraction),
nor puts in $\sigma$ a flexible application outside \llambda{} (an application
node that could be erased by a $\beta$-reduction).

Note that proposition \ref{prop:nf} does not hold for \Uo{} since
decompilation can introduce (actually restore) terms in
\maybeeta or \maybebeta that were move out of the way (put in $\mathbb{L}$)
by compilation.

\section{Alternative encodings and related work}

Paper \cite{10.1145/2966268.2966272} introduces semi-shallow.

Our encoding of DTT may look ``semi shallow'' since we use the meta-language
lambda abstraction but not its application (for the terms of type \elpiIn{tm}).
A fully shallow encoding unfortunately does not fit our use case, although
it would make the running example work:

\begin{elpicode}
finite (fin N).
decision (nfact N NF).
decision (all A x\ P x) :- finite A, pi x\ decision (P x).
\end{elpicode}

\noindent
There are two reasons for dismissing this encoding. The first one is that
in DTT it is not always possible to adopt it since the type system
of the meta language is too weak to accommodate terms with a variable arity,
like the following example:

\begin{coqcode}
Fixpoint arr T n := if n is S m then T -> arr T m else T.
Definition sum n : arr nat n := ...
Check sum 2   7 8   : nat.
Check sum 3   7 8 9 : nat.
\end{coqcode}

\noindent
The second reason is the encoding for Coq is used for meta programming the
system, hence it must accommodate the manipulation of terms that are now
know in advance (not even defined in Coq) without using introspection
primitives such as Prologs's \texttt{functor} and \texttt{arg}.

In the literature we could find a few related encoding of DTT.
TODO In~\cite{felty93lics} is related and make the
discrepancy between the types of ML and DTT visible. In this case
one needs 4 application nodes. Moreover the objective is an encoding
of terms, proofs, not proof search. Also note the conv predicate,
akin to the unif we rule out.

TODO This other paper~\cite{10.1007/978-3-031-38499-8_25} should also be cited.

None of the encodings above provide a solution to our problem.

\section{Preliminaries: \Fo{} and \Ho}
\label{sec:lang-spec}

In order to reason about unification we provide a description of the
\Fo{} and \Ho languages where unification variables
are first class terms, i.e. they have a concrete syntax. We keep these languages
minimal, for example, we omit the \elpiIn{all} quantifier of DTT we used
in the example in Section~\ref{sec:intro} together with the type notation of
terms carried by the \elpiIn{lam} constructor. 
%
\setlength{\abovecaptionskip}{0pt}
\setlength{\belowcaptionskip}{-13pt}

\begin{figure}[H]
  \begin{tabular}{ll}
  \begin{minipage}{0.21\textwidth}
  \begin{elpicodetab}
kind fm type.
type fapp list fm -> fm.
type flam (fm -> fm) -> fm.
type fcon string -> fm.
type fuva nat -> fm.
\end{elpicodetab}
  \end{minipage}
  &
  \begin{minipage}{0.24\textwidth}
  \begin{elpicodetab}
kind tm type.
type app list tm -> tm.
type lam (tm -> tm) -> tm.
type con string -> tm.
type uva nat -> list tm -> tm.
  \end{elpicodetab}
  \end{minipage}
  \end{tabular}
  \caption{\Fo{} and \Ho language}\vspace{0.3em}
  \label{code:common-terms}
  \Description[code:common-terms]{code:common-terms}
\end{figure}

\noindent
In the case of \Fo{} unification variables \elpiIn{fuva} have no explicit scope:
the arguments of an higher order unification variable are via the \elpiIn{fapp}
constructor. For example in the statement of the instance \coqIn{forall_dec} the
term \coqIn{P x} is represented as \elpiIn{fapp[fuva N, x]}, where \elpiIn{N} is
a memory address and \elpiIn{x} is a bound variable.

In \Ho the representation of \coqIn{P x} is instead \elpiIn{uva N [x]}.
We say that the unification variable \elpiIn{uva N L} is in \llambda iff
\elpiIn{distinct L} holds.

\begin{elpicode}
type distinct list A -> o.
distinct [].
distinct [X|XS] :- name X, not(mem X XS), distinct XS.
\end{elpicode}

\noindent
The \elpiIn{name} builtin predicate tests if a term is a bound variable.
\footnote{one could always load name x for every x under a pi and get rid of the name builtin}
The
compiler~\ref{sec:xxx} needs to support terms outside \llambda for practical
reasons, so we don't assume all out terms are in \llambda but rather test. \textbf{\textcolor{red}{what?? }}

In both languages unification variables are identified by a natural number,
which can be seen as a memory address. The memory and its associated
operations are described below:

\begin{elpicode}
typeabbrev memory A (list (option A)).
type set?   nat -> memory A -> A -> o.
type unset? nat -> memory A -> o.
type assign nat -> memory A -> A -> memory A -> o.
\end{elpicode}

\noindent 
If a memory cell is \elpiIn{none}, then the corresponding unification variable
is not set. \elpiIn{assign} sets an unset cell to the given value.

Since in \Ho unification variables have a scope, their solution needs to be
abstracted over it in order to enable the instantiation of a single
solution to different scopes. On the contrary solutions to \Fo variables
are plain terms.

\begin{elpicode}
  typeabbrev fsubst (memory ftm).
  kind assmt type.
  type abs (tm -> assmt) -> assmt.
  type val tm -> assmt.
  typeabbrev subst (memory assmt).
\end{elpicode}

\noindent
We call \elpiIn{fsubst} the memory of \Fo{}, while we call \elpiIn{subst}
the one of \Ho.
Both have the invariant that they are not cyclic, TODO explain.
Other invariant: the terms in ho\_subst never contains eta and beta expansion

\subsection{Notations}

We use math mode for \Ho.

\begin{tabular}{ll}
  $\lambda x.\lambda y.F_{x y}$ & \elpiIn{lam x\ lam y\ uva F [x, y]} \\
  $f~ a$ &  \elpiIn{app[con "f", con "a"]}\\
  $\lambda x.F_{x} ~ a$ & \elpiIn{lam x\ app[uva F [x], con "a"]} \\
  $\lambda x.F_{x} ~ x$ & \elpiIn{lam x\ app[uva F [x], x]} \\
\end{tabular}

\subsection{Equational theory and Unification}

here we give the functions/signatures to express the properties 3-5 in the problem
statement

Together with the description of the terms of the language, we need some
auxiliary functions to perform operations like term equality, unification,
dereferencing. There predicates are supposed to be implemented in the OL and the
ML following respectively their specification. In the following few paragraphs
we give a brief proposition of them.

\paragraph{Term dereferencing: $\rho s$ and $\sigma t$}

Since in our encoding we explicitly carry a substitution we need to
define the operation that applies it to a term. Its proposition
takes care to normalize (flatten) applications, for example
it turns
\elpiIn{(app [app [con"f",con"a"],con"b"])}
into
\elpiIn{(app [con"f",con"a",con"b"])}.


dereference variables of the two languages. This is particularly useful to check
if two terms in the OL (resp. in the ML) are equal. The constructors
representing rigid terms, namely \elpiIn{app}, \elpiIn{lam} and \elpiIn{con},
make the dereferencing procedure to recurse over the their subterms. The code
below display this behavior for the dereferencing performed by the OL:

\begin{elpicode}
type fder fsubst -> fm -> fm -> o.
fder S (fapp A) (fapp B) :- map (fder S) A B.
fder S (flam F) (flam G) :- 
  pi x\ fder S x x => fder S (F x) (G x).
fder _ (fcon C) (fcon C).
fder S (fuva N) R :- set? N S T, fder S T R.
fder S (fuva N) (fuva N) :- unset? N S.

type fderef fsubst -> fm -> fm -> o.                 ~($\customlabel{pred:fder}{\rho s}$)~
fderef S T R :- fder S T T', napp T' R.

type napp fm -> fm -> o.
\end{elpicode}

\noindent
TODO explain napp.
We use the cut operator to keep the code compact. It is possible to rewrite
the rule for application traversal so that it is mutually exclusive with the
first one, but that requires a rather verbose analysis of the head of \elpiIn{A}.

The corresponding code for \Ho is similar, we only show the last two rules that
differ in a substantial way:

\begin{elpicode}
type deref subst -> tm -> tm -> o.                   ~($\customlabel{pred:deref}{\sigma t}$)~
deref S (app A) (app B) :- map (deref S) A B.
deref S (lam F) (lam G) :- 
  pi x\ deref S x x => deref S (F x) (G x).
deref _ (con C) (con C).
deref S (uva N A) R :- set? N S F, move F A T, deref S T R.
deref S (uva N A) (uva N B) :- unset? N S, map (deref S) A B.
type move assignment -> list tm -> tm -> o.
move (abs Bo)        [H|L] R :- move (Bo H) L R.
move (val A)         []    A :- !.
move (val (uva N A)) L     (uva N X) :- append A L X.
\end{elpicode}

\noindent
TODO: no need to napp, see the beta section.
Note that when the substitution \elpiIn{S} maps a unification variable
\elpiIn{N} to an assignment \elpiIn{F} we ....

TODO: invariant: variables in subst are always fully applied, and length of scope is the
arity of the HO variable. 

Important!!!
A different reasoning is to be addressed to the variables of the ML. Firstly, a
meta variable cannot appear in the \elpiIn{app} node as the first element of the
list, we will explain why in \cref{sec:compilation}

\begin{elpicode}
  ~\PYG{k+kd}{type} \PYG{n+nf}{(\Eo)} \PYG{k+kt}{ftm -> ftm -> o}~.                           ~($\customlabel{pred:fequal}{\Eo}$)~
  fapp A ~\Eo~fapp B :- map ~(\Eo)~ A B.
  flam F ~\Eo~flam G :- pi x\ x ~\Eo~x => F x ~\Eo~G x.
  fcon C ~\Eo~fcon C.
  fuva N ~\Eo~fuva N.
  flam F ~\Eo~T :-                                       ~($\customlabel{clause:eta1}{\eta_l}$)~
    pi x\ beta T [x] (R x), x ~\Eo~x => F x ~\Eo~R x.
  T ~\Eo~flam F :-                                       ~($\customlabel{clause:eta2}{\eta_r}$)~
    pi x\ beta T [x] (R x), x ~\Eo~x => R x ~\Eo~F x.
  fapp [flam X | L] ~\Eo~T :- beta (flam X) L R, R ~\Eo~T. ~($\customlabel{clause:beta1}{\beta_l}$)~
  T ~\Eo~fapp [flam X | L] :- beta (flam X) L R, T ~\Eo~R. ~($\customlabel{clause:beta2}{\beta_r}$)~
\end{elpicode}

\begin{figure}
  \begin{elpicode}
    ~\PYG{k+kd}{type} \PYG{n+nf}{(\Ee)} \PYG{k+kt}{tm -> tm -> o}~.
    app A ~\Ee~fapp B :- map ~(\Ee)~ A B.
    lam F ~\Ee~flam G :- pi x\ x ~\Ee~x => F x ~\Ee~G x.
    con C ~\Ee~fcon C.
    uva N A ~\Ee~fuva N B :- map ~(\Ee)~ A B.
  \end{elpicode}
  \caption{Equal predicate ML}
  \label{code:eq-pred-meta}
  \Description[code:equal-pred-meta]{code:equal-pred-meta}
\end{figure}

\paragraph{Term equality: \Eo vs. \Ee} We can test if two terms are equal
following the equational theory of the language being considered. In
\cref{code:eq-pred} we provide an implementation of the \Eo predicate. The first
four rules check if the two terms are equal regarding the structure of the
current node, that is, two terms are equal if they have same head and if
recursively each subterm is two by two equal. Moreover, since the theory of the
OL accepts $\eta$- and $\beta$-equivalence, then we implement the corresponding
rules.

\noindent
The equality relation for the ML, accepts $\eta\beta$-equivalence between terms
of the ML. Recall that \elpiIn{abs x\ f x}, is a valid $\eta$ expansion of the
function \elpiIn{f} and that \elpiIn{lam x\ app[f, x]} is not that equivalent to
\elpiIn{f} at meta level. However, since we are interested in using the
unification procure of the ML, by \cref{prop:correct-ml}, we can use the
\Ue relation to test, when needed if two terms are equal in the ML.

\paragraph{Term unification: \Uo vs. \Ue} 
The last but not least important relation we should take care of before
presenting our full algorithm aiming to unify terms of the OL in the ML and
provide the substitution produced in the ML to the OL, is term unification. This
procedure is a more powerful version of the equal predicate, since unification
checks if two terms can be equal be assigning unification variables. In our
representation, variable assignment (or refinement) is performed by modifying
the corresponding substitution mapping. We will not give an implementation of
\Uo, since we are giving an implementation of it using
our algorithm, see \cref{XX}.

\begin{elpicode}
~\PYG{k+kd}{type} \PYG{n+nf}{(\Ue)} \PYG{k+kt}{tm -> tm -> subst -> subst -> o}~.
\end{elpicode}

On the other hand, unification in the ML needs to be defined. In
\cref{code:ue-pred}, we give an implementation of \Ue but
that is actually what our meta language provides as a builtin.

This predicate has four
arguments, the two terms $t_1$ and $t_2$ to unify, the old substitution map
$\rho_1$, and the new substitution map $\rho_2$, with the invariant $\rho_1
\subseteq \rho_2$. The first three rules unify terms with same rigid heads, and
call the unification relation on the sub-terms. If $t_1$ (resp. $t_2$) is an
assigned variables, $t_1$ is dereferenced to $t_1'$ (resp. $t_2'$) and the
unification is called between $t_1'$ and $t_2$ (resp. $t_1$ and $t_2'$). If both
terms are unification variables, we test that their arguments are in the pattern
fragment, we allocate a new variable $w$ in $\rho_1$ such that $w$ is the
pruning of the arguments of $t_1$ and $t_2$, we assign both $t_1$ and $t_2$ to
$w$ and return the new mapping $\rho_2$ containing all the new variable
assignment. Finally, if only one of the two terms is an unification variable
$v$, after having verified that $v$ does not occur in the other term $t$, we
bind $v$ to $t$ and return the new substitution mapping.

\old

A key property needed in unification is being able to verify if two terms are
equal wrt a given equational theory. This relation allow to compare terms under
a certain substitution mapping, so that any time a variable $v$ is assigned in a
subterm, a dereferencing of $v$ is performed. After variable dereferencing, the
test for equality is continued on the new-created subterm.

The base equality function over terms can be defined as follows:

The solution we are proposing aim to overcome these unification issues by 1)
compiling the terms $t$ and $u$ of the OL into an internal version $t'$ and $u'$
in the ML; 2) unifying $t'$ and $u'$ at the meta level instantiating meta
variables; 3) decompiling the meta variable into terms of the OL; 4) assigning
the variables of the OL with the decompiled version of their corresponding meta
variables. We claim that $t$ and $u$ unify if and only if $t'$ and $u'$ unify
and that the substitution in the object language is the same as the one returned
by the ML. \todo{same or $\supseteq$ or $\subseteq$} 

In the following section we explain how we deal with term (de)compilation and
links between unification variables.

\section[Compilation: fo\_tm to tm]{Basic compilation \Fo{} to \Ho{}}
\label{sec:compilation}

In this section we describe a basic compilation scheme that we refine
later, in the following sections.

The objective of the compilation is to recognize the higher-order variables
available in \Ho{} when expressed in a first order way in \Fo{}. The compiler
also generates a list of links that are used to bring back the substitution from
\Ho{} to \Fo{} and allocates in the memory a cell for each variable.

types
\input{code/comp_base_types}

core

\input{code/comp_base}

aux

\input{code/comp_base2}

\noindent
Note that \elpiIn{link} carries the arity (number of expected arguments) of
the variable. \marginpar{say when this is needed}

\begin{elpicode}
type solve-links links -> links -> subst -> subst -> o.
solve-links L L S S.
\end{elpicode}

Then decomp

\begin{elpicode}
type decompile links -> subst -> fsubst -> o.
decompile L S O :-
  map (_\r\r = none) S O1, % allocate empty fsubst
  (pi N X\ knil N X :- mem L (link X N _) ; N = X) =>
    decompl S L O1 O.
type knil nat -> nat -> o.

type decompl links -> subst -> fsubst -> o.
decompl S [] [].
decompl S [link _ N _|L] O P :- unset? N S X,
  decompl S L O P.
decompl S [link M N _|L] O P :- set? N S X,
  decomp-assignment S X T, assign M O (some T) O1,
  decompl S L O1 P.

type decomp-assignment subst -> assignment -> fm -> o.
decomp-assignment S (abs F) (flam G) :-
  pi x y\ decomp-tm S x y => decomp-assignment S (F x) (G y).
decomp-assignment S (val T) T1 :- decomp S T T1.

type decomp subst -> tm -> fm.
decomp _ (con C) (fcon C).
decomp S (app A) (app B) :- map (decomp S) A B.
decomp S (lam F) (flam G) :-
  pi x y\ decomp S x y => decomp S (F x) (G y).
decomp S (uva N A) R :- set? N S F,
  move F A T, decomp S T R.
decomp S (uva N A) R :- unset? N S,
  map (decomp S) A B, knil N M, napp (fapp[fuva M|B]) R.
\end{elpicode}
  
\marginpar{TODO link}
\marginpar{TODO nuove subst}

Now unif\marginpar{TODO: code unif}

\begin{elpicode}
~\PYG{k+kd}{type} \PYG{n+nf}{(\Uo)} \PYG{k+kt}{fm -> fm -> subst -> subst -> o}~.
(X ~\Uo~Y) S S1 :-
  fderef S X X0, fderef S Y Y0,                    ~($\customlabel{step:norm}{norm}$)~
  comp X0 X1 [] S0 [] L0,                        ~($\customlabel{step:compile}{compile}$)~
  comp Y0 Y1 S0 S1 L0 L1,
  (X1 ~\Ue~Y1) [] HS0,                              ~($\customlabel{step:unify}{unify}$)~
  solve-links L1 L2 HS0 HS1,                        ~($\customlabel{step:link}{link}$)~
  decompile L2 HS1  S1.                        ~($\customlabel{step:decompile}{decompile}$)~
\end{elpicode}

\subsection{Prolog simulation}
Allows us to express the properties.
we take all terms involved in a search (if a rule is used twice we simply
take a copy of it), we compile all of them, and then we pick the unification
prblems among these terms and step trough them.

\begin{elpicode}
type pick list A -> (pair nat nat) -> (pair A A) -> o.
pick L (pr X Y) (pr TX TY) :- nth X L TX, nth Y L TY.

type prolog-fo list fm -> list (pair nat nat) -> subst -> o.
prolog-fo Terms Problems S :-
  map (pick Terms) Problems FoProblems,
  fold4 ~(\Uo)~ FoProblems [] S.

type step-ho (pair tm tm) -> links -> links -> subst -> subst -> o.
step-ho (pr X Y) L0 L1 S0 S2 :-
  (X1 ~\Ue~Y1) S0 S1,
  solve-links L0 L1 S1 S2.

type prolog-ho list fm -> list (pair nat nat) -> subst -> o.
prolog-ho Terms Problems S :-
  fold4 comp Terms HoTerms [] L0 [] HS0,
  map (pick HoTerms) Problems HoProblems,
  fold4 step-ho HoProblems L0 L HS0 HS,
  decompile L HS S.
\end{elpicode}

\noindent
the proprty is that if a step for Fo succeds then the Ho one does, and
if Fo fails then the Ho fails ()

\subsection{Example}

OK 

\begin{elpicode}
Terms [ flam x\ fapp[fcon"g",fapp[fuva z, x]] 
      , flam x\ fapp[fcon"g", fcon"a"] ]
Problems = [ pr z (s z) ] % $\lambda x.g (F x) = \lambda x.g a$ 
lam x\ app[con"g",uva z [x]] ~\Uo~lam x\ app[con"g", con"a"]
link z z (s z)
HS = [some (abs x\con"a")]
S = [some (flam x\fcon a)]
\end{elpicode}

KO

\begin{elpicode}
  Terms [ flam x\ fapp[fcon"g",fapp[fuva z, x]] 
  , flam x\ fapp[fcon"g", fcon"a"] ]
Problems = [ pr 0 1   % $A = \lambda x.x$
           , pr 2 3 ] % $A a = a$ 
lam x\ app[con"g",uva z [x]] ~\Uo~lam x\ app[con"g", con"a"]
link z z (s z)
HS = [some (abs x\con"a")]
S = [some (flam x\fcon a)]
lam x\ app[f, app[X, x]] = Y,
  lam x\ x) = X.
\end{elpicode}

\otext{Goal: $s_1 \Uo s_2$ is compiled into $t_1 \Ue t_2$}
\otext{What is done: uvars \elpiIn{fo_uv} of OL are replaced into uvars \elpiIn{ho_uv} of the ML}
\otext{Each \elpiIn{fo_uv} is linked to an \elpiIn{ho_uv} of the OL}
\otext{Example needing the compiler v0 (tra l'altro lo scope è ignorato):\\ \elpiIn{lam x\ app[con"g",app[uv 0, x]] ~\Uo~lam x\ app[con"g", c"a"]}}
\otext{Links used to instantiate vars of elpi}
\otext{After all links, the solution in links are compacted and given to coq}
\otext{It is not so simple, see next sections (multi-vars, eta, beta)}


The compilation step is meant to recover the higher-order variables of the OL,
expressed in a first order way, by replacing them with higher-order variables in
the ML. In particular, every time a variable of the OL is encountered in the
original term, it is replaced with a meta variable, and if the OL variable is
applied to a list of distinct names $L$, then this list becomes the scope of the variable. 
For all the other constructors of
\elpiIn{tm}, the same term constructor is returned and its arguments are
recursively compiled. The predicate in charge for term compilation is:

\elpiIn{type comp tm -> tm -> links -> links -> subst -> subst -> o}. 

\noindent
where, we take the term of the OL, produce the term of the ML, take a list
of link and produce a list of new links, take a substitution and return a 
new substitution.

In particular, due to programming constraints, we need to drag the old subst and
return a new one extended, if needed, with the new declared meta-variables.

The following code
%
\begin{elpicode}
  kind link type.
  type link nat -> nat -> nat -> subst.
\end{elpicode}
%
\noindent
defines a link, which is a relation between to variables indexes, the first
being the index of a OL variable and the second being the index of a ML
variable. The third integer\todo{integer or nat?} is the number of term in the
scope of the two variables, or equivalently, in a typed language, their arity. 

As an example, let's study the following unification problem (a slightly 
modified version from \cref{sec:intro}):

\begin{elpicode}
  lam x\ app[c"decision", app[c"nfact", x, c"3"]] ~\Uo~
    lam x\ app [c"decision", app[uv 0, x]]
\end{elpicode}

\noindent
we have the main unification problem where the nested \elpiIn{app} nodes have
lists of different lengths making the unification to fail. The compilation of 
these terms produces a new unification problem with the following shape:

\begin{elpicode}
  lam x\ app[c"decision", app[c"nfact", x, c"3"]] ~\Ue~
    lam x\ app [c"decision", uv 1 [x]]
\end{elpicode}

\noindent
The main difference is the replacement of the subterm \elpiIn{app[uv 0, x]} of
the OL with the subterm \elpiIn{uv 0 [x]}. Variable indexes are chosen by the
ML, that is, the index \elpiIn{0} for that unification variable of the OL term
has not the sam meaning of the index \elpiIn{0} in the ML. There exists two
different substitution mapping, one for the OL and one for the ML and the indexes
of variable point to the respective substitution.

decomp che mappa abs verso lam
\noindent
\otext{An other example: \\
  \elpiIn{lam x\ app[f, app[X, x]] = Y, (lam x\ x) = X.}}

\section{Use of multivars}

Se il termine initziale è della forma

\begin{elpicode}
  app[con"xxx", (lam x\ lam y\ Y y x), (lam x\ f)]
  =
  app[con"xxx",X,X]
\end{elpicode}

allora se non uso due X diverse non ho modo di recuperare il quoziente che mi manca.

a sto punto consideriamo liste di problemi e così da eliminare sta xxx senza
perdità di generalità (e facciamo problemi più corti, e modellizziamo anche la
sequenza)

\subsection{Problems with $\eta$}

\input{code/comp_eta}

\otext{The following goal necessita v1 (lo scope è usato):\\ \elpiIn{X = lam x\ lam y\ Y y x, X = lam x\ f}}
\otext{The snd unif pb, we have to unif \elpiIn{lam x\ lam y\ Y x y} with \elpiIn{lam x\ f}}
\otext{It is not doable, with the same elpi var}

Invarianti:
A destra della eta abbiamo sempre un termine che comincia per $\lambda x. bla$

\begin{textcode}
  La deduplicate eta:
  - viene chiamata che della forma [variable] -> [eta1] e [variable] -> [eta2] 
    (a destra non c'è mai un termine con testa rigida)
  - i due termini a dx vengono unificati con la unif e uno dei due link viene buttato
    NOTA!! A dx abbiamo sempre un termine della forma lam x.VAR x!!!
    Altrimenti il link sarebbe stato risolto!!
  - dopo l'unificazione rimane un link [variabile] -> [etaX] 
  - nella progress-eta, se a sx abbiamo una constante o un'app, allora eta-espandiamo
    di uno per poter unificare con il termine di dx.
\end{textcode}
  
\subsection{Problems with $\beta$}

\input{code/comp_beta}

$\beta$-reduction problems (\maybebeta) appears any time we deal with a subterm $t
= X t_1 \dots t_n$, where $X$ is flexible and the list $[t_1 \dots t_n]$ in not
in \llambda. This unification problem is not solvable without loss of
generality, since there is not a most general unifier. If we take back the
example given in \cref{sec:nutshell}, the unification $F a = a$ admits two solutions for $F$:
$\rho_1 = \{F \mapsto \lambda x.x\}$ and $\rho_2 = \{F \mapsto \lambda \_.a\}$.
Despite this, it is possible to work with $\maybebeta$ if an oracle provides a
substitution $\rho$ such that $\rho t$ falls again in the \llambda. 

On the other hand, the \Ue is not designed to understand how the $\beta$-redexes
work in the object language. Therefore, even if we know that $F$ is assigned
to $\lambda x.x$, \Ue is not able to unify $F a$ with $a$. On the other hand,
the problem $F a = G$ is solvable by \Ue, but the final result is that $G$ is
assigned to $(\lambda x.x) a$ which breaks the invariant saying that the 
substitution of the meta language does not generate terms outide \wellb{} (Property \ref{prop:nf}).

The solution to this problem is to modify the compiler such that any sub-term $t$
considered as a potential $\beta$-redex is replaced with a hole $h$ and a new dedicated
link, called \linkbeta.

\begin{elpicode}
  type link-beta tm -> tm -> link.
\end{elpicode}
  
This link carries two terms, the former representing the variable $h$ for the
new created hole and the latter containing the subterm $t$. As for the \linketa,
we will call $h$ and $t$ respectively the left hand side (LHS)
and the right hand side (RHS) of the \linkbeta.

A subterm is in \maybebeta{} if it has the shape \elpiIn{fapp[fuva
N | L]} and \elpiIn{distinct L} does not hold. In that case, \elpiIn{L} is split
in two sublist \elpiIn{PF} and \elpiIn{NPF} such that former is the longest
prefix of \elpiIn{L} such that \elpiIn{distinct PF} holds. \elpiIn{NPF} is the
list such that \elpiIn{append PF NPF L}. The LHS is set to a new variable
named $M$ with \elpiIn{PF} in scope whereas the RHS is given by the term
\elpiIn{app[uva N' PF | NPF]} where the \Ho variable identified by \elpiIn{N'}
is mapped to the \Fo{} variable named \elpiIn{N}.

\marginpar{signposting: a link is reconsidered in two cases. then make 2 paragraphs}
After its creation, a \linkbeta remain suspended until the head of the RHS is
instantiated by the oracle (see \cref{prop:simulation}). In this case the RHS is
$\beta$-reduced to a new term $t$. $t$ is either a term in \llambda, in
which case $t$ is unified with the LHS, otherwise, the link remain suspended
and no progress is performed. Another way to wake a \linkbeta up is when the
LHS is a term \elpiIn{T} and RHS has the shape \elpiIn{app[uva N PF | NPF]}
and some of the arguments in the \elpiIn{NPF} list become names. This is
possible after the resolution of other links. In this case, the list \elpiIn{L}
obtained by the concatenation between \elpiIn{PF} and \elpiIn{NPF} is split
again in to lists \elpiIn{PF'} and \elpiIn{NPF'}. If \elpiIn{PF} is not that
same as \elpiIn{PF'}, then we can 1) remove the current \linkbeta, 2) create a
new \linkbeta between \elpiIn{T} and \elpiIn{app[uva N' PF' | NPF']} and 3)
create a new \linketa between the variables \elpiIn{N} and \elpiIn{N'}.

\marginpar{A bit too fast, we first compile, then unify, then the oracle, then the manip...}
An example justifying this last link manipulation is given by the following
unification problem:

\begin{elpicode}
  f = flam x\ fapp[F, (X x), a] % $f = \lambda x.F (X x) a$
\end{elpicode}

\noindent
under the subsitution $\rho = \{X \mapsto \lambda x.x\}$.

\noindent
The links generated from this unification problem are:

\begin{textcode}
X ~$\mapsto$~ X1; F ~$\mapsto$~ X2 % The map
  ~$\vdash$~ X0   =~$\eta$~= x\ `X3 x'
x ~$\vdash$~ X3 x =~$\beta$~= X2 `X1 x' a
\end{textcode}

\noindent
where the first link is a \linketa between the variable \texttt{X0}, representing
the right side of the unification problem (it is a \maybeeta) and
\texttt{X3}; and a \linkbeta between the variable \texttt{X3} and the subterm
\texttt{c0\textbackslash\ X2 `X1 c0' a} (it is a \maybebeta).
The substitution tells that \textIn{x ~$\vdash$~ X1 x = x}.

We can now represent the \hrun execution from this configuration which will, at
first, dereference all the links, and then try to solve them. The only link
being modified is the second one, which is set to \textIn{X3 x =~$\beta$~= X2
x a}. The RHS of the link has now a variable which is partially in the PF,
we can therefore remove the original \linkbeta and replace it with the following 
couple on links:

\begin{textcode}
  ~$\vdash$~ X1   =~$\eta$~= x\ `X4 x'
x ~$\vdash$~ X3 x =~$\beta$~= x\ `X4 x' a
\end{textcode}

By these links we say that \texttt{X1} is now $\eta$-linked to a fresh variable
\texttt{X4} with arity one. This new variable is used in the new \linkbeta where
the name \texttt{x} is in its scope. This allows 

\subsection{Tricky examples}

\begin{elpicode}
  triple ok (@lam x\ @app[@f, @app[@X, x]]) @Y,
  triple ok @X (@lam x\ x),
  triple ok @Y @f
\end{elpicode}

\begin{elpicode}
% @okl 22 [
%   triple ok (@lam x\ @lam y\ @app[@Y, y, x]) @X,
%   triple ok (@lam x\ @f) @X,
% ].
\end{elpicode}

\section{First order approximation}

\otext{Coq can solve this: \coqIn{f 1 2 = X 2}, by setting X to f 1}
\otext{We can re-use part of the algo for $\beta$ given before}


\section{Unif encoding in real life}
\otext{Il ML presentato qui è esattamente elpi}
\otext{Il OL presentato qui è esattamente coq}
\otext{Come implementatiamo tutto ciò nel solver}

\section{Results: stdpp and tlc}
\otext{How may rule are we solving?}
\otext{Can we do some perf test}

\section{Conclusion}

\printbibliography

\clearpage

\input{appendix.tex}

\end{document}