\documentclass[sigconf,natbib=false]{acmart}
\usepackage[]{biblatex}

\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}
\addbibresource{bib.bib}

\usepackage{myTools}
\usepackage{macros}

% TODO: set this fields
%\setcopyright{cc}
%\setcctype{by}
\copyrightyear{2024}
\acmYear{XXXX 2024}
\acmBooktitle{YYY}
\acmDOI{ZZZZZZZZZZZZ}    


% \xspaceaddexceptions{]\}}

\def\elpi{\proglang{elpi}}
\def\coqelpi{\proglang{coq-elpi}}
\def\lambdaprolog{\proglang{$\lambda$-prolog}}
\def\coq{\proglang{coq}}

\newcommand{\library}[1]{\textit{#1}\xspace}
\def\stdpp{\library{stdpp}}
\def\iris{\library{iris}}

\newcommand*{\acronym}[1]{\texttt{#1}\xspace}

\def\ol{\acronym{ol}} % object language
\def\ml{\acronym{ml}} % meta language
\def\lf{\acronym{lf}} % logical framework
\def\ho{\acronym{ho}} % higher order
\def\Forall{$\forall$}

\newcommand{\EqualRel}{\ensuremath{=}}
\newcommand{\nEqualRel}{\ensuremath{\new}}
\newcommand{\UnifRel}{\ensuremath{\simeq}}
\newcommand{\nUnifRel}{\ensuremath{\not\simeq}}

\newcommand{\Uo}{\ensuremath{\UnifRel_o}\xspace}
\newcommand{\nUo}{\ensuremath{\nUnifRel_o}\xspace}
\newcommand{\Eo}{\ensuremath{\EqualRel_o}\xspace}
\newcommand{\nEo}{\ensuremath{\nEqualRel_o}\xspace}

\newcommand{\Ue}{\ensuremath{\UnifRel_\lambda}\xspace}
\newcommand{\nUe}{\ensuremath{\nUnifRel_\lambda}\xspace}
\newcommand{\Ee}{\ensuremath{\EqualRel_\lambda}\xspace}
\newcommand{\nEe}{\ensuremath{\nEqualRel_\lambda}\xspace}
\newcommand{\llambda}{\ensuremath{\mathcal{L}_\lambda}\xspace}

\newcommand{\Fo}{\ensuremath{\mathcal{F}_{\!o}\xspace}} % space non va
\newcommand{\Ho}{\ensuremath{\mathcal{H}_o}\xspace}

\newcommand*{\eqtau}{\ensuremath{\mathrel{\overset{\mathrm{\tau}}{=}}}}

\begin{document}

\title{HO unification from object language to meta language} 

\author{Enrico Tassi}
\email{enrico.tassi@inria.fr}
\affiliation{%
  \institution{Université Côte d'Azur, Inria}
  % \city{Nice}
  \country{France}}

\author{Davide Fissore}
\email{davide.fissore@inria.fr}
\affiliation{%
  \institution{Université Côte d'Azur, Inria}
  % \city{Nice}
  \country{France}}

\begin{abstract}
  Specifying and implementing a logic from scratch requires significant effort.
  Logical Frameworks and Higher Order Logic Programming Languages provide
  dedicated, high-level Meta Languages (ML) to facilitate this task in two
  key ways: 1) variable binding and substitution are simplified when ML binders
  represent object logic ones; 2) proof construction, and even proof search, is
  greatly simplified by leveraging the unification procedure provided by the ML.
  Notable examples of ML are Elf~\cite{elf}, Twelf~\cite{twelf},
  $\lambda$Prolog~\cite{miller_nadathur_2012} and
  Isabelle~\cite{10.1007/978-3-540-71067-7_7}
  which have been utilized to implement various formal systems such as
  First Order Logic~\cite{felty88cade},
  Set Theory~\cite{10.1007/BF00881873},
  Higher Order Logic~\cite{books/sp/NipkowPW02}, and even the Calculus of
  Constuctions~\cite{felty93lics}.
  
  The object logic we are interested in is Coq's~\cite{Coq-refman}
  Dependent Type Theory (DTT),
  for which we aim to implement a unification procedure \Uo using the ML
  Elpi~\cite{dunchev15lpar}, a dialect of $\lambda$Prolog.
  Elpi's equational theory comprises
  $\eta\beta$ equivalence and comes equipped with a
  higher order unification procedure \Ue restricted to the pattern
  fragment~\cite{miller92jsc}.
  We want \Uo to be as powerful as \Ue but on the object logic DTT.
  Elpi also comes with an encoding for DTT that works well
  for meta-programming~\cite{tassi:hal-01637063,tassi:hal-01897468,gregoire:hal-03800154,newtc}.
  Unfortunately this encoding, which we refer to as \Fo,
  ``underuses'' \Ue by restricting it to first-order unification problems only. 
  To address this issue, we propose a better-behaved encoding, \Ho,
  demonstrate how to map unification problems in \Fo{}
  to related problems in \Ho, and illustrate
  how to map back the unifiers found by \Ue, effectively implementing
   \Uo on top of \Ue for the encoding \Fo.
   
  We apply this technique to the implementation of a type-class~\cite{wadler89}
  solver for Coq~\cite{Coq-refman}.
  Type-class solvers are proof search procedures based on
  unification that back-chain designated lemmas, providing essential
  automation to widely used 
  Coq libraries such as Stdpp/Iris~\cite{JUNG_KREBBERS_JOURDAN_BIZJAK_BIRKEDAL_DREYER_2018}
  and TLC~\cite{10.1007/978-3-642-14052-5_15}. These two libraries
  constitute our test bed.
\end{abstract} 

\keywords{Logic Programming, Meta-Programming, Higher-Order Unification, Proof Automation}

\maketitle

\section{Introduction}
\label{sec:intro}

Specifying and implementing a logic from scratch requires significant effort.
Logical Frameworks and Higher Order Logic Programming Languages provide
dedicated, high-level Meta Languages (ML) to facilitate this task in two
key ways: 1) variable binding and substitution are simplified when ML binders
represent object logic ones; 2) proof construction, and even proof search, is
greatly simplified by leveraging the unification procedure provided by the ML.
Notable examples of ML are Elf~\cite{elf}, Twelf~\cite{twelf},
$\lambda$Prolog~\cite{miller_nadathur_2012} and
Isabelle~\cite{10.1007/978-3-540-71067-7_7}
which have been utilized to implement various formal systems such as
First Order Logic~\cite{felty88cade},
Set Theory~\cite{10.1007/BF00881873},
Higher Order Logic~\cite{books/sp/NipkowPW02}, and even the Calculus of
Constuctions~\cite{felty93lics}.

The object logic we are interested in is Coq's~\cite{Coq-refman}
Dependent Type Theory (DTT), and we want to code a type-class~\cite{wadler89}
solver for Coq~\cite{Coq-refman} using the Coq-Elpi~\cite{tassi:hal-01637063}
meta programming framework.
Type-class solvers are unification based proof search procedures
that combine a set of designated lemmas in order to providing essential
automation to widely used Coq libraries.

As the running example we take the \coqIn{Decide} type class,
from the Stdpp~\cite{JUNG_KREBBERS_JOURDAN_BIZJAK_BIRKEDAL_DREYER_2018}
library. The class identifies predicates equipped with a decision procedure.
The following three designated lemmas (called \coqIn{Instances} in the
type-class jargon) state that: 1) the type \coqIn{fin n}, of natural numbers
smaller than \coqIn{n} is finite; 2) the predicate \coqIn{nfact n nf},
linking a natural number \coqIn{n} to its prime factors \coqIn{nf}, is decidable;
3) the universal closure of a predicate has a decision procedure if the
predicate has and if its domain is finite.

\begin{coqcode}
Instance fin_fin n : Finite (fin n).              (* r1 *)
Instance nfact_dec n nf : Decision (nfact n nf).  (* r2 *)
Instance forall_dec A P : Finite A ~$\to$~             (* r3 *)
  ~$\forall$~x:A, Decision (P x) ~$\to$~ Decision (~$\forall$~x:A, P x).
\end{coqcode}

\noindent Under this context of instances a type-class solver is able to prove
the following statement automatically by back-chaining.

\begin{coqcode}
  Check _ : Decision (forall y: fin 7, nfact y 3).       ~\customlabel{goal:g}{(g)}~
\end{coqcode}

\noindent
The encoding of DTT provided by Elpi, that we will discuss at length later in
section~\ref{sec:encodings,sec:lang-spec} and ~\ref{}, is an Higher Order Abstract
Syntax (HOAS) datatype \elpiIn{tm} featuring (among others) the following
constructors:

\begin{elpicode}
type lam  tm -> (tm -> tm) -> tm.     % lambda abstraction
type app  list tm -> tm.              % n-ary application
type all  tm -> (tm -> tm) -> tm.     % forall quantifier
type con  string -> tm.               % constants
\end{elpicode}

\noindent
Following standard $\lambda$Prolog~\cite{miller_nadathur_2012}
the concrete syntax to abstract, at the meta level, an expression
\elpiIn{e} over a variable \elpiIn{x}
is <<\elpiIn{x\ e}>>, and square brackets denote a list of
terms separated by comma. As an example we show the encoding of the Coq term
<<\coqIn{~$\forall$~y:t, nfact y 3}>>:

\begin{elpicode}
all (con"t") y\ app[con"nfact", y, con"3"]
\end{elpicode}

\noindent
We now illustrate the encoding of the three instances above as higher-order
logic-programming rules: capital letters denote rule
parameters; \elpiIn{:-} separates the rule's head from the premises;
\elpiIn{pi w\ p} introduces a fresh nominal constant \elpiIn{w}
for the premise \elpiIn{p}.

\begin{elpicode}
finite (app[con"fin", N]).                            ~\customlabel{clause:r1}{(r1)}~
decision (app [con"nfact", N, NF]).                   ~\customlabel{clause:r2}{(r2)}~
decision (all A x\ app[P, x]) :- finite A,            ~\customlabel{clause:r3}{(r3)}~
  pi w\ decision (app[P, w]).
\end{elpicode}

\noindent
Unfortunately this translation of rule \ref{clause:r3} uses the
predicate \coqIn{P} as a first order term: for the meta
language its type is \elpiIn{tm}.
If we try to backchain the rule \ref{clause:r3} on the encoding of the goal
\ref{goal:g} given below
  
\begin{elpicode}
decision (all (app[con"fin", con"7"]) y\                 
  app[con"nfact", y, con"3"]).
\end{elpicode}

\noindent
we obtain an unsolvable unification problem \ref{problem:p}:
the two lists of terms have different lengths!
%The root cause is that
%\ref{problem:p} is an higher order in DTT, but becomes
%first order in the meta language due to the ``naive'' encoding.

\begin{elpicode}
app[con"nfact", y, con"3"] = app[P, y]                 ~\customlabel{problem:p}{(p)}~
\end{elpicode}

\noindent
In this paper we study a more sophisticated encoding of Coq terms allowing
us to rephrase the problematic rule \ref{clause:r3} as follows:

\begin{elpicode}
decision (all A x\ Pm x) :- link Pm P A, finite A,   ~\customlabel{clause:r3a}{(r3a)}~
  pi x\ decision (app[P, x]).
\end{elpicode}

\noindent
Since \elpiIn{Pm} is an higher-order unification variable,
of type \elpiIn{tm -> tm},
with \elpiIn{x}
in its scope, the unification problem \ref{problem:pa}
admits one solution:

\begin{elpicode}
app[con"nfact", y, con"3"] = Pm y                     ~\customlabel{problem:pa}{(p')}~
Pm = x\ app[con"nfact", x, con"3"]     % assignment for Pm
A = app[con"fin", con"7"]              % assignment for A
\end{elpicode}
  
\noindent
After unifying the head of rule \ref{clause:r3a} with the goal, Elpi runs
the premise <<\elpiIn{link Pm A P}>> that is in charge of bringing the
assignment for \elpiIn{Pm} back to the domain \elpiIn{tm} of Coq terms:

\begin{elpicode}
P = lam A a\ app[con"nfact", a, con"3"]
\end{elpicode}

\noindent
This simple example is sufficient to show that the encoding we seek
is not trivial and does not only concern the head of rules, but the entire sequence
of unification problems that constitute the execution of a logic program.
In fact
the solution for \elpiIn{P} above generates a
(Coq) $\beta$-redex in the second premise (the predicate
under the \elpiIn{pi w\ }\hspace{-0.4em}):

\begin{elpicode}
decision (app[lam A (a\ app[con"nfact", a, con"3"]), w])
\end{elpicode}

\noindent
In turn this redex prevents the rule \ref{clause:r2} to backchain properly since
the following unification problem has no solution:

\begin{elpicode}
app[lam A (a\ app[con"nfact", a, con"3"]), x] =
app[con"nfact", N, NF]
\end{elpicode}
\noindent
~\\
The root cause of the problems we sketched in the running example
is that the unification procedure \Ue of the meta language is not aware
of the equational theory of the object logic, even if both theories
include $\eta\beta$-conversion and admit most general
unifiers for unification problems in the pattern fragment \llambda~\cite{miller92jsc}.

\paragraph{Contributions}
In this paper we discuss alternative encodings of Coq in
Elpi (Section~\ref{sec:encodings}), then we identify a minimal language \Fo{}
in which the problems sketched here can be fully described.
We then detail an encoding \elpiIn{comp} from \Fo{} to \Ho (the language of
the meta language) and a decoding \elpiIn{decomp} to relate the unifiers
bla bla.. TODO citare Teyjus.

\section{Problem statement} %%%%%%%%%%%%%%%%%%%%%%
\label{sec:encodings}

The equational theory of Coq's Dependent Type Theory is very rich. In
addition to the usual $\eta\beta$-equivalence for functions, terms (hence types)
are compared up to definition unfolding and fixpoint unrolling. Still,
for efficiency and predictability reasons, most form of automatic proof search
employ a unification procedure that captures a simpler one,
just $\eta\beta$, and that solves higher-order problems
restricted to the pattern fragment $\mathcal{L}_\lambda$~\cite{miller92jsc}.
We call this unification procedure \Uo{}.

The equational theory of the meta language Elpi that we want to use to
implement a form of proof automation is strikingly similar, since it
it comprises $\eta\beta$ (for the meta language functions), and the
unification procedure \Ue{} solves higher-order problems in
$\mathcal{L}_\lambda$.

In spite of the similarity the link between \Ue{} and \Uo{} is not trivial,
since the abstraction and application term constructors
the two unification procedures deal with are different. For example

\begin{tabular}{lcl}
\elpiIn{x\ f x} & \Ue{} & \elpiIn{f}\\
\elpiIn{lam A x\ app[con"f", x]} & \Uo{} & \elpiIn{con"f"}\\
\elpiIn{lam A x\ app[con"f", x]} & \nUe{} & \elpiIn{con"f"} \\
\elpiIn{P x} & \Ue{} & \elpiIn{x}\\
\elpiIn{app[P, x]} & \Uo{} & \elpiIn{x}\\
\elpiIn{app[P, x]} & \nUe{} & \elpiIn{x}\\
\end{tabular}

\noindent
One could ignore this similarity, and ``just'' describe the object language
unification procedure in the meta language, that is crafting a \elpiIn{unif}
predicate to be used as follows in rule \ref{clause:r3}:

\begin{elpicode}
decision X :- unif X (all A x\ app[P, x]), finite A,
  pi x\ decision (app[P, x]).
\end{elpicode}

\noindent
This choice would underuse the logic programming engine provided by
the metalanguage since by removing any datum from the head of rules
indexing degenerates. Moreover the unification procedure built in the
meta language is likely to be faster than one implemented in it,
especially if the meta language is interpreted as Elpi is. 
  
To state precisely the problem we solve we need a \Fo{} representation
of DTT terms and a \Ho one.
We call \Eo the equality over ground terms in \Fo,
\Ee the equality over ground terms in \Ho,
\Uo the unification procedure we want to implement and
\Ue the one provided by the meta language.
TODO extend \Eo and \Ee with reflexivity on uvars.

\newcommand{\specunif}[3]{
  #3_i \in \mathcal{L}_\lambda \Rightarrow %
    \exists \rho, %
      \rho #3_1 #1 \rho #3_2  %
        \Leftrightarrow #3_1 #2 #3_2 \mapsto \rho' \subseteq \rho 
}


\newcommand{\unifcorrect}[3]{
  % \forall \rho #3_1 #3_2, %
    % \{#3_1, #3_2\} \subseteq \llambda \Rightarrow %
    #3_i \in \llambda \Rightarrow
      #3_1 #2 #3_2 \mapsto \rho
        \Rightarrow 
          \rho #3_1 #1 \rho #3_2  %
}

\newcommand{\unifcomplete}[3]{
  % \forall #3_1 #3_2, %
    % \{#3_1, #3_2\} \subseteq \llambda \Rightarrow %
    #3_i \in \llambda \Rightarrow
      % \forall \rho, %
        \rho #3_1 #1 \rho #3_2  %
          \Rightarrow \exists \rho', #3_1 #2 #3_2 \mapsto \rho' \land \rho' \subseteq \rho 
}

We write $t_1 \Ue t_2 \mapsto \sigma$ when $t_1$ and $t_2$ unify with substitution
$\sigma$, we write $\sigma t$ for the application of the substitution to
$t$, $\sigma \subseteq \sigma'$ when $\sigma$ is more general than $\sigma'$,
and we assume that the unification of our meta language is correct:

%
\begin{gather}
  \unifcorrect{\Ee}{\Ue}{t} \label{prop:correct-ml}\\
  \unifcomplete{\Ee}{\Ue}{t}
\end{gather}

\newcommand{\C}[3]{\ensuremath{\langle #1 \rangle}\mapsto(#2,#3)}
\newcommand{\D}[3]{\ensuremath{\langle #1,#2 \rangle^{-1}\mapsto #3}}

We illustrate a compilation $\C{s}{t}{l}$ that
maps a term $s$ in \Fo{} to a term $t$ in \Ho and a list of links $l$.
The links connect unification variables in \Ho with variables
in \Fo{} and are used to decompile the assignment,
$\D{\sigma}{l}{\rho}$.

Given 
$$
\C{s_1}{t_1}{l_1} \land \C{s_2}{t_2}{l_2}
$$
we define
$$
s_1 \Uo s_2 \mapsto \rho \stackrel{def}{=}
    t_1 \Ue t_2 \mapsto \sigma \land
    \D{\sigma}{l_1 + l_2}{\rho}
$$
Where $l_1 + l_2$ is the list concatenation of links.

We write $s \in \mathcal{L}_\lambda$ if all unif variables in
$s$ are applied to distinct bound variables.
%
\begin{gather}
\unifcorrect{\Eo}{\Uo}{s}\label{prop:correct}\\
\unifcomplete{\Eo}{\Uo}{s}\label{prop:complete}\\
% \forall \rho'\rho, 
  \rho s_1 \Eo \rho s_2 \Rightarrow
  \rho' \subseteq \rho \Rightarrow
  \rho's_i \in \mathcal{L}_\lambda \Rightarrow
  \rho' s_1 \Uo \rho' s_2 \label{prop:simulation}
\end{gather}

Properties \ref{prop:correct} and \ref{prop:complete} state, respectively, that
in \llambda the implementation of \Uo is correct, complete and returns the most
general unifier.

Property \ref{prop:simulation} states that \Uo is resilient to problems outside
\llambda if a third party provides a (partial) solution for its problem. Since
we are interested in using \Uo in a proof search procedure, made of a sequence
of unification problems, not necessarily in \llambda. In practice it is often
the case the order in which these problems are stated matters. A Typical example
is the following problem

\begin{elpicode}
app [F, con"a"] = app[con"f", con"a", con"a"]
\end{elpicode}

\noindent
preceded by 

\begin{elpicode}
F = lam x\ app[con"f",x,x]
\end{elpicode}

\noindent
becomes solvable in DTT trivially, since the term is ground (hence in \llambda),
but if one substitutes \elpiIn{F} in the LHS does not find,
structurally, the RHS
hence \Ue would fail (since \Ue does not know about the $\beta$ rule of DTT).
Our compiler takes care of making property \ref{prop:simulation} hold, see
section XXX.

Property \ref{prop:complete} is also relevant to use \Uo for logic programming.
In particular we want failures to occur as early as possible, so want
the decomp phase to take place immediately after \Ue, and fail if need be.
This becomes particularly important since compile may introduce two
ho variables for the same fo one, leaving the task of unifying the solutions
to decomp.

\section{Alternative encodings and related work}

Paper \cite{10.1145/2966268.2966272} introduces semi-shallow.

Our encoding of DTT may look ``semi shallow'' since we use the meta-language
lambda abstraction but not its application (for the terms of type \elpiIn{tm}).
A fully shallow encoding unfortunately does not fit our use case, although
it would make the running example work:

\begin{elpicode}
finite (fin N).
decision (nfact N NF).
decision (all A x\ P x) :- finite A, pi x\ decision (P x).
\end{elpicode}

\noindent
There are two reasons for dismissing this encoding. The first one is that
in DTT it is not always possible to adopt it since the type system
of the meta language is too weak to accommodate terms with a variable arity,
like the following example:

\begin{coqcode}
Fixpoint arr T n := if n is S m then T -> arr T m else T.
Definition sum n : arr nat n := ...
Check sum 2   7 8   : nat.
Check sum 3   7 8 9 : nat.
\end{coqcode}

\noindent
The second reason is the encoding for Coq is used for meta programming the
system, hence it must accommodate the manipulation of terms that are now
know in advance (not even defined in Coq) without using introspection
primitives such as Prologs's \texttt{functor} and \texttt{arg}.

In the literature we could find a few related encoding of DTT.
TODO In~\cite{felty93lics} is related and make the
discrepancy between the types of ML and DTT visible. In this case
one needs 4 application nodes. Moreover the objective is an encoding
of terms, proofs, not proof search. Also note the conv predicate,
akin to the unif we rule out.

TODO This other paper~\cite{10.1007/978-3-031-38499-8_25} should also be cited.

None of the encodings above provide a solution to our problem.

\section{Preliminaries: \Fo{} and \Ho}
\label{sec:lang-spec}

In order to reason about unification we provide a description of the
\Fo{} and \Ho languages where unification variables
are first class terms, i.e. they have a concrete syntax. We keep these languages
minimal, for example we omit the \elpiIn{all} quantifier of DTT we used
in the example in Section~\ref{sec:intro}. 
%
\setlength{\abovecaptionskip}{0pt}
\setlength{\belowcaptionskip}{-13pt}

\begin{figure}[H]
  \begin{tabular}{ll}
  \begin{minipage}{0.21\textwidth}
  \begin{elpicodetab}
kind fm type.
type fapp list fm -> fm.
type flam (fm -> fm) -> fm.
type fcon string -> fm.
type fuva nat -> fm.
\end{elpicodetab}
  \end{minipage}
  &
  \begin{minipage}{0.24\textwidth}
  \begin{elpicodetab}
kind tm type.
type app list tm -> tm.
type lam (tm -> tm) -> tm.
type con string -> tm.
type uva nat -> list tm -> tm.
  \end{elpicodetab}
  \end{minipage}
  \end{tabular}
  \caption{\Fo{} and \Ho language}\vspace{0.3em}
  \label{code:common-terms}
  \Description[code:common-terms]{code:common-terms}
\end{figure}

\noindent
In the case of \Fo{} unification variables \elpiIn{fuva} have no explicit scope:
Unification variables standing for functions are applied their arguments
via the \elpiIn{fapp} constructor.
For example in the statement of the instance \coqIn{forall_dec} the
term \coqIn{P x} is represented as \elpiIn{fapp[fuva N, x]}, where \elpiIn{N}
is of type \elpiIn{nat} and \elpiIn{x} is a bound variable.

In \Ho the representation of \coqIn{P x} is instead \elpiIn{uva N [x]}.
We say that the unification variable \elpiIn{uva N L} is in \llambda iff
\elpiIn{distinct-names L} holds.

\begin{elpicode}
type distinct-names list tm -> o.
distinct-names [].
distinct-names [X|XS] :- name X, not(mem X XS),
  distinct-names XS.
\end{elpicode}

\noindent
The \elpiIn{name} builtin predicate tests if a term is a bound variable.
\footnote{one could always load name x for every x under a pi and get rid of the name builtin}
The
compiler~\ref{sec:xxx} needs to support terms outside \llambda for practical
reasons, so we don't assume all out terms are in \llambda but rather test.

In both languages unification variables are identified by a natural number,
which can be seen as a memory address. The memory and its associated
operations are described below:

\begin{elpicode}
typeabbrev memory A (list (option A)).
type set?   nat -> memory A -> A -> o.
type unset? nat -> memory A -> o.
type assign nat -> memory A -> A -> memory A -> o.
\end{elpicode}

\noindent 
If a memory cell is \elpiIn{none}, then the corresponding unification variable
is not set. \elpiIn{assign} sets an unset cell to the given value.

Since in \Ho unification variables have a scope, their solution needs to be
abstracted over it in order to enable the instantiation of a single
solution to different scopes. On the contrary solutions to \Fo variables
are plain terms.

\begin{elpicode}
  typeabbrev fsubst (memory ftm).
  kind assmt type.
  type abs (tm -> assmt) -> assmt.
  type val tm -> assmt.
  typeabbrev subst (memory assmt).
\end{elpicode}

\noindent
We call \elpiIn{fsubst} the memory of \Fo{}, while we call \elpiIn{subst}
the one of \Ho.
Both have the invariant that they are not cyclic, TODO explain.

\subsection{Equational theory and Unification}

here we give the functions/signatures to express the properties 3-5 in the problem
statement

Together with the description of the terms of the language, we need some
auxiliary functions to perform operations like term equality, unification,
dereferencing. There predicates are supposed to be implemented in the OL and the
ML following respectively their specification. In the following few paragraphs
we give a brief definition of them.

\paragraph{Term dereferencing: $\rho s$ and $\sigma t$}

Since in our encoding we explicitly carry a substitution we need to
define the operation that applies it to a term. Its definition
takes care to normalize (flatten) applications, for example
it turns
\elpiIn{(app [app [con"f",con"a"],con"b"])}
into
\elpiIn{(app [con"f",con"a",con"b"])}.


dereference variables of the two languages. This is particularly useful to check
if two terms in the OL (resp. in the ML) are equal. The constructors
representing rigid terms, namely \elpiIn{app}, \elpiIn{lam} and \elpiIn{con},
make the dereferencing procedure to recurse over the their subterms. The code
below display this behavior for the dereferencing performed by the OL:

\begin{elpicode}
type fderef fsubst -> fm -> fm -> o.                 ~($\customlabel{pred:fderef}{\rho s}$)~
% flattening
fderef S (fapp [fuva N|A]) R :- set? N S (fapp B), !,
  append A B C, fderef S (fapp C) R.
% traversal
fderef S (fapp A) (fapp B) :- map (fderef S) A B.
fderef S (flam F) (flam G) :- 
  pi x\ fderef S x x => fderef S (F x) (G x).
fderef _ (fcon C) (fcon C).
% dereferencing
fderef S (fuva N) R :- set? N S T, fderef S T R.
fderef S (fuva N) (fuva N) :- unset? N S.
\end{elpicode}

\noindent
We use the cut operator to keep the code compact. It is possible to rewrite
the rule for application traversal so that it is mutually exclusive with the
first one, but that requires a rather verbose analysis of the head of \elpiIn{A}.

The corresponding code for \Ho is similar, we only show the last two rules that
differ in a substantial way:

\begin{elpicode}
type deref subst -> tm -> tm -> o.                   ~($\customlabel{pred:deref}{\sigma t}$)~
% ... similar to above ...
deref S (uva N A) R :- set? N S F, move F A T, deref S T R.
deref S (uva N A) (uva N B) :- unset? N S, map (deref S) A B.
type move assignment -> list tm -> tm -> o.
move (abs F) [X | L] R :- move (F X) L R.
move (val A)         [] A :- !.
move (val (app A))   L (app X) :- append A L X.
move (val (uva N A)) L (uva N X) :- append A L X.
move (val (con H))   L (app [con H | L]).
\end{elpicode}

\noindent
Note that when the substitution \elpiIn{S} maps a unification variable
\elpiIn{N} to an assignment \elpiIn{F} we ....

Important!!!
A different reasoning is to be addressed to the variables of the ML. Firstly, a
meta variable cannot appear in the \elpiIn{app} node as the first element of the
list, we will explain why in \cref{sec:compilation}

\begin{elpicode}
  ~\PYG{k+kd}{type} \PYG{n+nf}{(\Eo)} \PYG{k+kt}{ftm -> ftm -> o}~.                           ~($\customlabel{pred:fequal}{\Eo}$)~
  fapp A ~\Eo~fapp B :- map ~(\Eo)~ A B.
  flam F ~\Eo~flam G :- pi x\ x ~\Eo~x => F x ~\Eo~G x.
  fcon C ~\Eo~fcon C.
  fuva N ~\Eo~fuva N.
  flam F ~\Eo~T :-                                       ~($\customlabel{clause:eta1}{\eta_l}$)~
    pi x\ beta T [x] (R x), x ~\Eo~x => F x ~\Eo~R x.
  T ~\Eo~flam F :-                                       ~($\customlabel{clause:eta2}{\eta_r}$)~
    pi x\ beta T [x] (R x), x ~\Eo~x => R x ~\Eo~F x.
  fapp [flam X | L] ~\Eo~T :- beta (flam X) L R, R ~\Eo~T. ~($\customlabel{clause:beta1}{\beta_l}$)~
  T ~\Eo~fapp [flam X | L] :- beta (flam X) L R, T ~\Eo~R. ~($\customlabel{clause:beta2}{\beta_r}$)~
\end{elpicode}

\begin{figure}
  \begin{elpicode}
    ~\PYG{k+kd}{type} \PYG{n+nf}{(\Ee)} \PYG{k+kt}{tm -> tm -> o}~.
    app A ~\Ee~fapp B :- map ~(\Ee)~ A B.
    lam F ~\Ee~flam G :- pi x\ x ~\Ee~x => F x ~\Ee~G x.
    con C ~\Ee~fcon C.
    uva N A ~\Ee~fuva N B :- map ~(\Ee)~ A B.
  \end{elpicode}
  \caption{Equal predicate ML}
  \label{code:eq-pred-meta}
  \Description[code:equal-pred-meta]{code:equal-pred-meta}
\end{figure}

\paragraph{Term equality: \Eo vs. \Ee} We can test if two terms are equal
following the equational theory of the language being considered. In
\cref{code:eq-pred} we provide an implementation of the \Eo predicate. The first
four rules check if the two terms are equal regarding the structure of the
current node, that is, two terms are equal if they have same head and if
recursively each subterm is two by two equal. Moreover, since the theory of the
OL accepts $\eta$- and $\beta$-equivalence, then we implement the corresponding
rules.

\noindent
The equality relation for the ML, accepts $\eta\beta$-equivalence between terms
of the ML. Recall that \elpiIn{abs x\ f x}, is a valid $\eta$ expansion of the
function \elpiIn{f} and that \elpiIn{lam x\ app[f, x]} is not that equivalent to
\elpiIn{f} at meta level. However, since we are interested in using the
unification procure of the ML, by \cref{prop:correct-ml}, we can use the
\Ue relation to test, when needed if two terms are equal in the ML.

\paragraph{Term unification: \Uo vs. \Ue} 
The last but not least important relation we should take care of before
presenting our full algorithm aiming to unify terms of the OL in the ML and
provide the substitution produced in the ML to the OL, is term unification. This
procedure is a more powerful version of the equal predicate, since unification
checks if two terms can be equal be assigning unification variables. In our
representation, variable assignment (or refinement) is performed by modifying
the corresponding substitution mapping. We will not give an implementation of
\Uo, since we are giving an implementation of it using
our algorithm, see \cref{XX}.

\begin{elpicode}
~\PYG{k+kd}{type} \PYG{n+nf}{(\Ue)} \PYG{k+kt}{tm -> tm -> subst -> subst -> o}~.
\end{elpicode}

On the other hand, unification in the ML needs to be defined. In
\cref{code:ue-pred}, we give an implementation of \Ue but
that is actually what our meta language provides as a builtin.

This predicate has four
arguments, the two terms $t_1$ and $t_2$ to unify, the old substitution map
$\rho_1$, and the new substitution map $\rho_2$, with the invariant $\rho_1
\subseteq \rho_2$. The first three rules unify terms with same rigid heads, and
call the unification relation on the sub-terms. If $t_1$ (resp. $t_2$) is an
assigned variables, $t_1$ is dereferenced to $t_1'$ (resp. $t_2'$) and the
unification is called between $t_1'$ and $t_2$ (resp. $t_1$ and $t_2'$). If both
terms are unification variables, we test that their arguments are in the pattern
fragment, we allocate a new variable $w$ in $\rho_1$ such that $w$ is the
pruning of the arguments of $t_1$ and $t_2$, we assign both $t_1$ and $t_2$ to
$w$ and return the new mapping $\rho_2$ containing all the new variable
assignment. Finally, if only one of the two terms is an unification variable
$v$, after having verified that $v$ does not occur in the other term $t$, we
bind $v$ to $t$ and return the new substitution mapping.

\old

A key property needed in unification is being able to verify if two terms are
equal wrt a given equational theory. This relation allow to compare terms under
a certain substitution mapping, so that any time a variable $v$ is assigned in a
subterm, a dereferencing of $v$ is performed. After variable dereferencing, the
test for equality is continued on the new-created subterm.

The base equality function over terms can be defined as follows:

The solution we are proposing aim to overcome these unification issues by 1)
compiling the terms $t$ and $u$ of the OL into an internal version $t'$ and $u'$
in the ML; 2) unifying $t'$ and $u'$ at the meta level instantiating meta
variables; 3) decompiling the meta variable into terms of the OL; 4) assigning
the variables of the OL with the decompiled version of their corresponding meta
variables. We claim that $t$ and $u$ unify if and only if $t'$ and $u'$ unify
and that the substitution in the object language is the same as the one returned
by the ML. \todo{same or $\supseteq$ or $\subseteq$} 

In the following section we explain how we deal with term (de)compilation and
links between unification variables.

\section[Compilation: fo\_tm to tm]{Compilation}
\label{sec:compilation}

\otext{Goal: $s_1 \Uo s_2$ is compiled into $t_1 \Ue t_2$}
\otext{What is done: uvars \elpiIn{fo_uv} of OL are replaced into uvars \elpiIn{ho_uv} of the ML}
\otext{Each \elpiIn{fo_uv} is linked to an \elpiIn{ho_uv} of the OL}
\otext{Example needing the compiler v0 (tra l'altro lo scope è ignorato):\\ \elpiIn{lam x\ app[con"g",app[uv 0, x]] ~\Uo~lam x\ app[con"g", c"a"]}}
\otext{Links used to instantiate vars of elpi}
\otext{After all links, the solution in links are compacted and given to coq}
\otext{It is not so simple, see next sections (multi-vars, eta, beta)}


The compilation step is meant to recover the higher-order variables of the OL,
expressed in a first order way, by replacing them with higher-order variables in
the ML. In particular, every time a variable of the OL is encountered in the
original term, it is replaced with a meta variable, and if the OL variable is
applied to a list of distinct names $L$, then this list becomes the scope of the variable. 
For all the other constructors of
\elpiIn{tm}, the same term constructor is returned and its arguments are
recursively compiled. The predicate in charge for term compilation is:

\elpiIn{type comp tm -> tm -> links -> links -> subst -> subst -> o}. 

\noindent
where, we take the term of the OL, produce the term of the ML, take a list
of link and produce a list of new links, take a substitution and return a 
new substitution.

In particular, due to programming constraints, we need to drag the old subst and
return a new one extended, if needed, with the new declared meta-variables.

The following code
%
\begin{elpicode}
  kind link type.
  type link nat -> nat -> nat -> subst.
\end{elpicode}
%
\noindent
defines a link, which is a relation between to variables indexes, the first
being the index of a OL variable and the second being the index of a ML
variable. The third integer\todo{integer or nat?} is the number of term in the
scope of the two variables, or equivalently, in a typed language, their arity. 

As an example, let's study the following unification problem (a slightly 
modified version from \cref{sec:intro}):

\begin{elpicode}
  lam x\ app[c"decision", app[c"nfact", x, c"3"]] ~\Uo~
    lam x\ app [c"decision", app[uv 0, x]]
\end{elpicode}

\noindent
we have the main unification problem where the nested \elpiIn{app} nodes have
lists of different lengths making the unification to fail. The compilation of 
these terms produces a new unification problem with the following shape:

\begin{elpicode}
  lam x\ app[c"decision", app[c"nfact", x, c"3"]] ~\Ue~
    lam x\ app [c"decision", uv 1 [x]]
\end{elpicode}

\noindent
The main difference is the replacement of the subterm \elpiIn{app[uv 0, x]} of
the OL with the subterm \elpiIn{uv 0 [x]}. Variable indexes are chosen by the
ML, that is, the index \elpiIn{0} for that unification variable of the OL term
has not the sam meaning of the index \elpiIn{0} in the ML. There exists two
different substitution mapping, one for the OL and one for the ML and the indexes
of variable point to the respective substitution.

decomp che mappa abs verso lam
\noindent
\otext{An other example: \\
  \elpiIn{lam x\ app[f, app[X, x]] = Y, (lam x\ x) = X.}}

\section{Use of multivars}

Se il termine initziale è della forma

\begin{elpicode}
  app[con"xxx", (lam x\ lam y\ Y y x), (lam x\ f)]
  =
  app[con"xxx",X,X]
\end{elpicode}

allora se non uso due X diverse non ho modo di recuperare il quoziente che mi manca.

a sto punto consideriamo liste di problemi e così da eliminare sta xxx senza
perdità di generalità (e facciamo problemi più corti, e modellizziamo anche la
sequenza)

\subsection{Problems with $\eta$}
\otext{The following goal necessita v1 (lo scope è usato):\\ \elpiIn{X = lam x\ lam y\ Y y x, X = lam x\ f}}
\otext{The snd unif pb, we have to unif \elpiIn{lam x\ lam y\ Y x y} with \elpiIn{lam x\ f}}
\otext{It is not doable, with the same elpi var}

\subsection{Problems with $\beta$}

\otext{The following goal: \elpiIn{X = lam x\ x, app[X, 3] = 3}}
\otext{We use links-beta}

\subsection{Tricky examples}

\begin{elpicode}
  triple ok (@lam x\ @app[@f, @app[@X, x]]) @Y,
  triple ok @X (@lam x\ x),
  triple ok @Y @f
\end{elpicode}

\begin{elpicode}
% @okl 22 [
%   triple ok (@lam x\ @lam y\ @app[@Y, y, x]) @X,
%   triple ok (@lam x\ @f) @X,
% ].
\end{elpicode}

\section{First order approximation}

\otext{Coq can solve this: \coqIn{f 1 2 = X 2}, by setting X to f 1}
\otext{We can re-use part of the algo for $\beta$ given before}


\section{Unif encoding in real life}
\otext{Il ML presentato qui è esattamente elpi}
\otext{Il OL presentato qui è esattamente coq}
\otext{Come implementatiamo tutto ciò nel solver}

\section{Results: stdpp and tlc}
\otext{How may rule are we solving?}
\otext{Can we do some perf test}

\section{Conclusion}

\printbibliography

\clearpage
\section*{Appendix}

Note that \elpiIn{(a infix b) c d} de-sugars to \elpiIn{(infix) a b c d}.

\begin{figure*}
\begin{elpicode}
~\PYG{k+kd}{type} \PYG{n+nf}{(\Ue)} \PYG{k+kt}{tm -> tm -> subst -> subst -> o}~.
% Congruence
(app A ~\Ue~app B) S S1 :- fold2 ~(\Ue)~A B S S1.
(lam F ~\Ue~lam G) S S1 :- pi x\ (pi S\ (x ~\Ue~x) S S) => (F x ~\Ue~G x) S S1.
~\Ue~(con C) (con C) S S.
% deref
(uva N A ~\Ue~T) S S1 :- set? N S F, move F A T1, (T1 ~\Ue~T) S S1.
(T ~\Ue~uva N A) S S1 :- set? N S F, move F A T1, (T ~\Ue~T1) S S1.
% flex-flex
(uva N A ~\Ue~uva M B) S S3 :-  unset? M, unset? N,
  distinct-names A, distinct-names B, 
  new S W S1, prune W Args1 B Ass, 
  assign N S1 Ass S2, assign M S2 Ass S3.
% assignment
(uva N A ~\Ue~T) S S1 :- distinct-names A, not (T = uva _ _), not_occ N S T,  
  bind A T T1, assign N S T1 S1.
(T ~\Ue~uva N A) S S1 :- distinct-names A, not (T = uva _ _), not_occ N S T, 
  bind A T T1, assign N S T1 S1. 
      
type distinct-names list tm -> o.
distinct-names [].
distinct-names [X|XS] :- name X, not(mem X XS),
distinct-names XS.

typeabbrev memory A (list (option A)).
type set? nat -> memory A -> A -> o.
set? N S T :- nth N S (some T).
type unset? nat -> memory A -> o.
unset? N S :- nth N S none.
type assign nat -> memory A -> A -> memory A -> o.
assign z [none|M] T [some T|M].
assign (s N) [X|M] T [X|M1] :- assign N M T M1. 
kind nat type.
type z nat.
type s nat -> nat.
type nth nat -> list A -> A -> o.
nth z [X|_] X.
nth (s N) [_|L] X :- nth N L X.

type new memory A -> nat -> memory A -> o.
type prune .
type move .
type beta.
type not_occ.
TODO

\end{elpicode}
\caption{Implementation of the \Ue predicate for \Ho}
\label{code:ue-pred}
\Description[code:unif-pred]{code:unif-pred}
\end{figure*}
  
\end{document}