\documentclass[sigconf,natbib=false]{acmart}
\usepackage[]{biblatex}

\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}
\addbibresource{bib.bib}

\usepackage{myTools}
\usepackage{macros}

% TODO: set this fields
%\setcopyright{cc}
%\setcctype{by}
\copyrightyear{2024}
\acmYear{XXXX 2024}
\acmBooktitle{YYY}
\acmDOI{ZZZZZZZZZZZZ}    


% \xspaceaddexceptions{]\}}

\def\elpi{\proglang{elpi}}
\def\coqelpi{\proglang{coq-elpi}}
\def\lambdaprolog{\proglang{$\lambda$-prolog}}
\def\coq{\proglang{coq}}

\newcommand{\library}[1]{\textit{#1}\xspace}
\def\stdpp{\library{stdpp}}
\def\iris{\library{iris}}

\newcommand*{\acronym}[1]{\texttt{#1}\xspace}

\def\ol{\acronym{ol}} % object language
\def\ml{\acronym{ml}} % meta language
\def\lf{\acronym{lf}} % logical framework
\def\ho{\acronym{ho}} % higher order
\def\Forall{$\forall$}

\newcommand{\U}{\ensuremath{=_o}\xspace}
\newcommand{\Ue}{\ensuremath{=_\lambda}\xspace}
\newcommand{\Fo}{\ensuremath{\mathcal{F}_{\!o}\xspace}}
\newcommand{\Ho}{\ensuremath{\mathcal{H}_o}\xspace}

\newcommand*{\eqtau}{\ensuremath{\mathrel{\overset{\mathrm{\tau}}{=}}}}

\begin{document}

\title{HO unification from object language to meta language} 

\author{Enrico Tassi}
\email{enrico.tassi@inria.fr}
\affiliation{%
  \institution{Université Côte d'Azur, Inria}
  % \city{Nice}
  \country{France}}

\author{Davide Fissore}
\email{davide.fissore@inria.fr}
\affiliation{%
  \institution{Université Côte d'Azur, Inria}
  % \city{Nice}
  \country{France}}

\begin{abstract}
  Specifying and implementing a logic from scratch requires significant effort.
  Logical Frameworks and Higher Order Logic Programming Languages provide
  dedicated, high-level Meta Languages (ML) to facilitate this task in two
  key ways: 1) variable binding and substitution are simplified when ML binders
  represent object logic ones; 2) proof construction, and even proof search, is
  greatly simplified by leveraging the unification procedure provided by the ML.
  Notable examples of ML are Elf~\cite{elf}, Twelf~\cite{twelf},
  $\lambda$Prolog~\cite{miller_nadathur_2012} and
  Isabelle~\cite{10.1007/978-3-540-71067-7_7}
  which have been utilized to implement various formal systems such as
  First Order Logic~\cite{felty88cade},
  Set Theory~\cite{10.1007/BF00881873},
  Higher Order Logic~\cite{books/sp/NipkowPW02}, and even the Calculus of
  Constuctions~\cite{felty93lics}.
  
  The object logic we are interested in is Coq's~\cite{Coq-refman}
  Dependent Type Theory (DTT),
  for which we aim to implement a unification procedure \U using the ML
  Elpi~\cite{dunchev15lpar}, a dialect of $\lambda$Prolog.
  Elpi comes equipped with the equational theory \Ue, comprising
  $\eta\beta$ equivalence
  and higher order unification restricted to the pattern
  fragment~\cite{miller92jsc}.
  We want \U to feature the same equational theory as \Ue but on the
  object logic DTT. Elpi also comes with an encoding for DTT that works well
  for meta-programming~\cite{tassi:hal-01637063,tassi:hal-01897468,gregoire:hal-03800154,newtc}.
  Unfortunately this encoding, which we refer to as \Fo,
  ``underuses'' \Ue by restricting it to first-order unification problems only. 
  To address this issue, we propose a better-behaved encoding, \Ho,
  demonstrate how to map unification problems in \Fo
  to related problems in \Ho, and illustrate
  how to map back the unifiers found by \Ue, effectively implementing
   \U on top of \Ue for the encoding \Fo.
   
  We apply this technique to the implementation of a type-class~\cite{wadler89}
  solver for Coq~\cite{Coq-refman}.
  Type-class solvers are proof search procedures based on
  unification that back-chain designated lemmas, providing essential
  automation to widely used 
  Coq libraries such as Stdpp/Iris~\cite{JUNG_KREBBERS_JOURDAN_BIZJAK_BIRKEDAL_DREYER_2018}
  and TLC~\cite{10.1007/978-3-642-14052-5_15}. These two libraries
  constitute our test bed.
\end{abstract} 

\keywords{Logic Programming, Meta-Programming, Higher-Order Unification, Proof Automation}

\maketitle

\section{Introduction}
\label{sec:intro}

Specifying and implementing a logic from scratch requires significant effort.
Logical Frameworks and Higher Order Logic Programming Languages provide
dedicated, high-level Meta Languages (ML) to facilitate this task in two
key ways: 1) variable binding and substitution are simplified when ML binders
represent object logic ones; 2) proof construction, and even proof search, is
greatly simplified by leveraging the unification procedure provided by the ML.
Notable examples of ML are Elf~\cite{elf}, Twelf~\cite{twelf},
$\lambda$Prolog~\cite{miller_nadathur_2012} and
Isabelle~\cite{10.1007/978-3-540-71067-7_7}
which have been utilized to implement various formal systems such as
First Order Logic~\cite{felty88cade},
Set Theory~\cite{10.1007/BF00881873},
Higher Order Logic~\cite{books/sp/NipkowPW02}, and even the Calculus of
Constuctions~\cite{felty93lics}.

The object logic we are interested in is Coq's~\cite{Coq-refman}
Dependent Type Theory (DTT), and we want to code a type-class~\cite{wadler89}
solver for Coq~\cite{Coq-refman} using the Coq-Elpi~\cite{tassi:hal-01637063}
meta programming framework.
Type-class solvers are unification based proof search procedures
that combine a set of designated lemmas in order to providing essential
automation to widely used Coq libraries.

As the running example we take the \coqIn{Decide} type class,
from the Stdpp~\cite{JUNG_KREBBERS_JOURDAN_BIZJAK_BIRKEDAL_DREYER_2018}
library. The class identifies predicates equipped with a decision procedure.
The following three designated lemmas (called \coqIn{Instances} in the
type-class jargon) state that: 1) the type \coqIn{fin n}, of natural numbers
smaller than \coqIn{n} is finite; 2) the predicate \coqIn{nfact n nf},
linking a natural number \coqIn{n} to its prime factors \coqIn{nf}, is decidable;
3) the universal closure of a predicate has a decision procedure if the
predicate has and if its domain is finite.

\begin{coqcode}
Instance fin_fin n : Finite (fin n).
Instance nfact_dec n nf : Decision (nfact n nf).
Instance forall_dec A P : Finite A ~$\to$~ 
  ~$\forall$~x:A, Decision (P x) ~$\to$~ Decision (~$\forall$~x, P x).
\end{coqcode}

\noindent Under this context the type-class solver is able to prove
the the following statement automatically by back-chaining
the three instances.

\begin{coqcode}
  Check _ : Decision (forall y: fin 7, nfact y 3).
\end{coqcode}

\noindent
The encoding of DTT provided by Elpi, that we will discuss at length later in
\cref{sec:encodings,sec:lang-spec}, features the following term constructors:

\begin{elpicode}
kind tm type.
type lam tm -> (tm -> tm) -> tm. % lambda abstraction
type app list tm -> tm.          % n-ary application
type all tm -> (tm -> tm) -> tm. % forall quantifier
type c string -> tm.             % constants
\end{elpicode}

\noindent
\marginpar{TODO: explain HOAS}
Following this term encoding the three instances are represented by the
following rules:

\begin{elpicode}
finite (app[c"fin", N]).
decision (app [c"nfact", N, NF]).
decision (all A x\ app[P, x]) :- finite A,
  pi x\ decision (app[P, x]).
\end{elpicode}

\noindent
\marginpar{TODO: explain pi, cons}
Unfortunately this direct translation of the instances considers the
predicate \coqIn{P} as a first order term. If we try to backchain the
third rule on the encoding of the goal above:
  
\begin{elpicode}
decision (all (app[c"fin", c"7"]) y\
  app[c"nfact", y, c"3"]).
\end{elpicode}

\noindent
we fail because of this ``higher order'' unification problem (in DTT)
is phrased as a first order unification problem in the meta language.

\begin{elpicode}
app[c"nfact", y, c"3"] = app[P, y]
\end{elpicode}

\noindent
In this paper we study a more sophisticated encoding of Coq terms allowing
us to rephrase the problematic rule as follows:

\begin{elpicode}
decision (all A x\ Pm x) :- link Pm A P, finite A,
  pi x\ decision (app[P, x]).
\end{elpicode}

\noindent
This time \elpiIn{Pm} is an higher order unification variable (of type
\elpiIn{tm -> tm}). The resulting unification problem is now:

\begin{elpicode}
app[c"nfact", y, c"3"] = Pm y
\end{elpicode}

\noindent
That admits one solution:

\begin{elpicode}
Pm = y\ app[c"nfact", y, c"3"]
A = app[c"fin",c"7"]
\end{elpicode}
  
\noindent
Elpi succeeds in the application of the new rule and then runs
the premise \elpiIn{link Pm A P} that is in charge of bringing the
assignment back to the domain of Coq terms (the type \elpiIn{tm}):

\begin{elpicode}
P = lam A a\ app[c"nfact", a, c"3"]
\end{elpicode}

\noindent
This simple example is sufficient to show that the encoding we seek
is not trivial. Indeed the solution for \elpiIn{P} generates a
(Coq) $\beta$-redex in the second premise (under the \elpiIn{pi x}):

\begin{elpicode}
decision (app[lam A (a\ app[c"nfact", a, c"3"]), x])
\end{elpicode}

\noindent
In turn the redex prevents the second rule to backchain properly since
the following unification problem has no solution:

\begin{elpicode}
app[lam A (a\ app[c"nfact", a, c"3"]), x] =
app[c"nfact", N, NF]
\end{elpicode}

\noindent
This time the root cause is that the unification procedure of \Ue of the
meta language is not aware of the equational theory of the object logic \U,
even if both theories include $\eta\beta$-conversion and admit most general
unifiers for problems in the pattern fragment~\cite{miller92jsc}.

In this paper we discuss alternative encodings of Coq in
Elpi~\ref{sec:encodings}, then we identify a minimal language \Fo
in which the problems sketched here can be fully described.
We then detail an encoding \elpiIn{comp} from \Fo to \Ho (the language of
the meta language) and a decoding \elpiIn{decomp} to relate the unifiers
bla bla..

\section{Alternative encodings} %%%%%%%%%%%%%%%%%%%%%%
\label{sec:encodings}

Our choice of encoding of DTT may look weird to the reader familiar with
LF, since used a shallow encoding of classes and binders, but not of the
``lambda calculus'' part of DTT. Here a more lightweight encoding
that unfortunately does not fit our use case

\begin{elpicode}
finite (fin N).
decision (nfact N NF).
decision (all A x\ P x) :- 
  (pi x\ decision (P x)), finite A.
\end{elpicode}

but in DTT this is not always possible and not handy in our use case,
since the arity of constants is not fixed.

\begin{coqcode}
Fixpoint narr T n := 
  if n is S m then T -> narr T m else T.
Definition nsum n : narr nat (n+1).
Check nsum 2   8 9 : nat.
Check nsum 3 7 8 9 : nat.
\end{coqcode}
  
moreover we use the same encoding for meta programming, or even just to provide
hand written rules. We want to access the syntax of OL, so our embedding cannot
be that shallow. We want to keep it shallow for the binders, but we need
the c, app and lam nodes. % all ?

Another alternative

\begin{elpicode}
decision X :- unif X (all A x\ app[P, x]), 
  (pi x\ decision (app[P, x])), finite A.
\end{elpicode}

gives up all half of what the ML gives us. Moreover even if unif here embodies
the eq theory of DTT which is much stronger than the one of the ML, we don't need 
it. According to our experience eta beta suffice, but HO is needed.



Note that this~\cite{felty93lics} is related and make the
discrepancy between the types of ML and DTT visible. In this case
one needs 4 application nodes. Moreover the objective is an encoding
of terms, proofs, not proof search. Also note the conv predicate,
akin to the unif we rule out.

This other paper~\cite{10.1007/978-3-031-38499-8_25} should also be cited.

\section{Languages description}
\label{sec:lang-spec}

\input{lang_descr.tex}

% Description of languages (OL and ML)

\def\eqfo{eq\_fo\xspace}

In order to reason about unification of the terms of the objet language within the
meta language, we start by formally describing the two languages. Employing
meta-programming for this purpose, \cref{code:lang-descr} presents the type
\elpiIn{tm} containing the constructors for term application, lambda abstraction
and constants. Moreover, in order to represent unification variables, we need 
to give two different constructors. 

In the case of the OL, variables have no scope. For example, the subterm
\coqIn{P x} from the instance forall\_dec. Here, \coqIn{P} is an higher order
variables with type \coqIn{A ~$\to$~ Prop} and \coqIn{x} is a name bound to
\coqIn{P}. However, at the meta level, the translation of \coqIn{P x} becomes
\elpiIn{app[P, x]}, that is, \elpiIn{P} cannot reference \elpiIn{x}. In our
encoding, unification variables are encoded as integer corresponding to memory
addresses, and the constructor for unification variables in the OL is
\elpiIn{fo_uv}. This constructor is prefixed with \elpiIn{fo} since the
variable, having no scope, is a first-order variable.

On the other hand, in the case of the ML, we want to use its unification
algorithm to make variable assignment. Since the ML is an Higher Order
Programming Language, we represent unification variables with the \elpiIn{uv}
constructor, which, this time, can see a list of terms. Of course some attention
should be payed when dealing with this constructor, since we have to certify
each time that an \elpiIn{uv i} remain in the pattern fragment, that is, the
list of term in the scope of \elpiIn{i} is a list of distinct names. Finally,
the following code

\begin{elpicode}
  kind assmt type.
  type abs (tm -> assmt) -> assmt.
  type val tm -> assmt.
\end{elpicode}

\noindent
illustrates the \elpiIn{assmt} representing variable assignment in the ML. \marginpar{todo: explain better}

The memory of the two languages are represented with lists of substitutions. In
particular, the substitution of the OL, called \elpiIn{fo_subst}, is made by
optional terms such that, if the substitution is \elpiIn{none}, then the
variable is not instantiated. Note that the variables in the \elpiIn{fo_subst}
have always the \elpiIn{fo_uv} constructor. On the other hand, the ML
substitution is an optional assignment and in that assignment, variables are
considered to have the \elpiIn{uv} constructor.

A key property needed in unification is being able to verify if two terms are
equal. This is kind of a structural equality verification between two terms,
where variable dereferencing is performed when the variable is assigned. A
sketch of the equality function is given for the OL language in
\cref{code:term-equal}. Though, this equality relation over terms of a language
can be powered by other reduction rules depending equational theory being
considered. In our case, the OL terms are equal under $\eta\beta$ redex. This mean
that new rules for those two redexes are added in the implementation of
\elpiIn{fo_equal}.

If \elpiIn{fo_equal} is conceived to manage equality between terms of the OL,
the same equality predicate in the ML behave slightly different. By the given
definition of the ML, the ML allows $\eta\beta$ congruence of terms, but, since
the node \elpiIn{app} and \elpiIn{abs} are constructor representing the
applications and the abstractions of the OL, these two reduction rules cannot
applied on them. We build therefore a predicate \elpiIn{equal} working for terms
in the ML which is implemented merely with the rules for the \elpiIn{fo_equal}
predicate.\todo{not true for uv} For example, if \elpiIn{fo_equal []
(abs x\ [c"f", c]) (c"f")} is true in the object language, \elpiIn{equal [] (abs
x\ [c"f", c]) (c"f")} produces a failure.

The solution we are proposing aim to overcome these unification issues by 1)
compiling the terms $t$ and $u$ of the OL into an internal version $t'$ and $u'$
in the ML; 2) unifying $t'$ and $u'$ at the meta level instantiating meta
variables; 3) decompiling the meta variable into terms of the OL; 4) assigning
the variables of the OL with the decompiled version of their corresponding meta
variables. We claim that $t$ and $u$ unify if and only if $t'$ and $u'$ unify
and that the substitution in the object language is the same as the one returned
by the ML. \todo{same or $\supseteq$ or $\subseteq$} 

Mathematically, we what to prove the following property:

\begin{coqcode}
  forall (t  u : term_ol) (s : subst_ol) 
         (t' u': term_ml) (s': subst_ml), 
    equal_ol t u s <->
      comp t t' /\ comp u u' /\ 
      unif_ml t' u' s' /\ decomp s' s.
\end{coqcode}

$$Math\ formula$$

In the following section we explain how we deal with term (de)compilation and
unification variable linking.

\section[Compilation: fo\_tm to tm]{Compilation: \texttt{tm} $\to$ \texttt{tm}}

% - how we transform an fo\_tm in tm \\
% - the role of links \\
% - decomp
% - esempio che va in questa semplice rappresentazione (from intro)
% - esempio che non va, multi-var, eta, beta
% % \section{Term de-compilation}

% \section{Unification in ML}

% - we accept HO unif with PF \\
% - need of multiple vars for a single OL var

% % Compile FO to HO

% % Assignement in HO should be decompiled




% -------------------------------------------------------------------

% \noindent


% \subsection{implementation}

% l'HO encoding e' esattamente lambda Prolog/elpi, il compilatore
% in pratica potrebbe essere scritto in un meta language, qui lo si presenta in
% elpi stesso. HO e FO in questo paper sono deep embedded in elpi per parlarne,
% ma in pratica il nostro solever, prendere XX, scrivere la clausola compilata.


% \section{recovering eta}

% \begin{elpicode}
% q (all x\ F x) = q (all x\ app[f,x]) /\ p f = p F
% F = fun a => app [f,a] ----> F = f
% \end{elpicode}

% l'utene da p su f, mentre l'istanza pe q forza F a fun .. 

% \section{recovering beta}

% \begin{elpicode}
%   q (all x\ F x) = q (all x\ app[f,x,x]) /\ p1 (app[f,a,a]) = p1 (app[F,a])
%   F = fun y => app [f,y,y] ----> (app[F,a]) ~> app[f, a, a].
% \end{elpicode}
  
% qui la sintesi di F puo generare un beta redex, quindi ci mettiamo
% p1 F1, e decomp beta F [a] F1.

% \section{recovering eta-beta within unification (non linear variables)}

% se i problemi di cui sopra avvengono nello stesso termine

% \begin{elpicode}
%   q2 (all x\ F x) (app[F,a]) = q2 (all x\ app[f,x,x]) (app[f,a,a])
% \end{elpicode}

% bisogna slegare le due F e poi unificare le soluzioni tra di loro

% \section{heuristic / binary app}

% fo approx / sub pattern fragment

% \begin{elpicode}
%   p (all x\app[F,x,a]) (app[F,b]) = p (all x\app[f,x,x,a]) (app[f,b,b])
%   p (all x\G x) F' = 
%   G = x\ f x x a
%   F = lam x\f x x
%   F' = (app[f,b,b])
%   link (F a) F'
%   link G F
% \end{elpicode}


% % questo esempio recupera l'app binaria perche

% \begin{elpicode}
%   (app (app F x) a) = (app (f x x) a)
% \end{elpicode}

% \section{Stats}

% Concretamente:

% - quante volte l'ordine superiore è necessario in stdpp/tlc

% \section{Conclusion}

% \printbibliography

\end{document}