\documentclass[sigconf,natbib=false]{acmart}
\usepackage[]{biblatex}

\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}
\addbibresource{bib.bib}

\usepackage{myTools}
\usepackage{macros}

% TODO: set this fields
%\setcopyright{cc}
%\setcctype{by}
\copyrightyear{2024}
\acmYear{XXXX 2024}
\acmBooktitle{YYY}
\acmDOI{ZZZZZZZZZZZZ}    


% \xspaceaddexceptions{]\}}

\def\elpi{\proglang{elpi}}
\def\coqelpi{\proglang{coq-elpi}}
\def\lambdaprolog{\proglang{$\lambda$-prolog}}
\def\coq{\proglang{coq}}

\newcommand{\library}[1]{\textit{#1}\xspace}
\def\stdpp{\library{stdpp}}
\def\iris{\library{iris}}

\newcommand*{\acronym}[1]{\texttt{#1}\xspace}

\def\ol{\acronym{ol}} % object language
\def\ml{\acronym{ml}} % meta language
\def\lf{\acronym{lf}} % logical framework
\def\ho{\acronym{ho}} % higher order
\def\Forall{$\forall$}

\newcommand{\EqualRel}{\ensuremath{=}}
\newcommand{\nEqualRel}{\ensuremath{\new}}
\newcommand{\UnifRel}{\ensuremath{\simeq}}
\newcommand{\nUnifRel}{\ensuremath{\not\simeq}}

\newcommand{\Uo}{\ensuremath{\UnifRel_o}\xspace}
\newcommand{\nUo}{\ensuremath{\nUnifRel_o}\xspace}
\newcommand{\Eo}{\ensuremath{\EqualRel_o}\xspace}
\newcommand{\nEo}{\ensuremath{\nEqualRel_o}\xspace}

\newcommand{\Ue}{\ensuremath{\UnifRel_\lambda}\xspace}
\newcommand{\nUe}{\ensuremath{\nUnifRel_\lambda}\xspace}
\newcommand{\Ee}{\ensuremath{\EqualRel_\lambda}\xspace}
\newcommand{\nEe}{\ensuremath{\nEqualRel_\lambda}\xspace}

\newcommand{\Fo}{\ensuremath{\mathcal{F}_{\!o}\xspace}} % space non va
\newcommand{\Ho}{\ensuremath{\mathcal{H}_o}\xspace}

\newcommand*{\eqtau}{\ensuremath{\mathrel{\overset{\mathrm{\tau}}{=}}}}

\begin{document}

\title{HO unification from object language to meta language} 

\author{Enrico Tassi}
\email{enrico.tassi@inria.fr}
\affiliation{%
  \institution{Université Côte d'Azur, Inria}
  % \city{Nice}
  \country{France}}

\author{Davide Fissore}
\email{davide.fissore@inria.fr}
\affiliation{%
  \institution{Université Côte d'Azur, Inria}
  % \city{Nice}
  \country{France}}

\begin{abstract}
  Specifying and implementing a logic from scratch requires significant effort.
  Logical Frameworks and Higher Order Logic Programming Languages provide
  dedicated, high-level Meta Languages (ML) to facilitate this task in two
  key ways: 1) variable binding and substitution are simplified when ML binders
  represent object logic ones; 2) proof construction, and even proof search, is
  greatly simplified by leveraging the unification procedure provided by the ML.
  Notable examples of ML are Elf~\cite{elf}, Twelf~\cite{twelf},
  $\lambda$Prolog~\cite{miller_nadathur_2012} and
  Isabelle~\cite{10.1007/978-3-540-71067-7_7}
  which have been utilized to implement various formal systems such as
  First Order Logic~\cite{felty88cade},
  Set Theory~\cite{10.1007/BF00881873},
  Higher Order Logic~\cite{books/sp/NipkowPW02}, and even the Calculus of
  Constuctions~\cite{felty93lics}.
  
  The object logic we are interested in is Coq's~\cite{Coq-refman}
  Dependent Type Theory (DTT),
  for which we aim to implement a unification procedure \Uo using the ML
  Elpi~\cite{dunchev15lpar}, a dialect of $\lambda$Prolog.
  Elpi's equational theory comprises
  $\eta\beta$ equivalence and comes equipped with a
  higher order unification procedure \Ue restricted to the pattern
  fragment~\cite{miller92jsc}.
  We want \Uo to be as powerful as \Ue but on the object logic DTT.
  Elpi also comes with an encoding for DTT that works well
  for meta-programming~\cite{tassi:hal-01637063,tassi:hal-01897468,gregoire:hal-03800154,newtc}.
  Unfortunately this encoding, which we refer to as \Fo,
  ``underuses'' \Ue by restricting it to first-order unification problems only. 
  To address this issue, we propose a better-behaved encoding, \Ho,
  demonstrate how to map unification problems in \Fo{}
  to related problems in \Ho, and illustrate
  how to map back the unifiers found by \Ue, effectively implementing
   \Uo on top of \Ue for the encoding \Fo.
   
  We apply this technique to the implementation of a type-class~\cite{wadler89}
  solver for Coq~\cite{Coq-refman}.
  Type-class solvers are proof search procedures based on
  unification that back-chain designated lemmas, providing essential
  automation to widely used 
  Coq libraries such as Stdpp/Iris~\cite{JUNG_KREBBERS_JOURDAN_BIZJAK_BIRKEDAL_DREYER_2018}
  and TLC~\cite{10.1007/978-3-642-14052-5_15}. These two libraries
  constitute our test bed.
\end{abstract} 

\keywords{Logic Programming, Meta-Programming, Higher-Order Unification, Proof Automation}

\maketitle

\section{Introduction}
\label{sec:intro}

Specifying and implementing a logic from scratch requires significant effort.
Logical Frameworks and Higher Order Logic Programming Languages provide
dedicated, high-level Meta Languages (ML) to facilitate this task in two
key ways: 1) variable binding and substitution are simplified when ML binders
represent object logic ones; 2) proof construction, and even proof search, is
greatly simplified by leveraging the unification procedure provided by the ML.
Notable examples of ML are Elf~\cite{elf}, Twelf~\cite{twelf},
$\lambda$Prolog~\cite{miller_nadathur_2012} and
Isabelle~\cite{10.1007/978-3-540-71067-7_7}
which have been utilized to implement various formal systems such as
First Order Logic~\cite{felty88cade},
Set Theory~\cite{10.1007/BF00881873},
Higher Order Logic~\cite{books/sp/NipkowPW02}, and even the Calculus of
Constuctions~\cite{felty93lics}.

The object logic we are interested in is Coq's~\cite{Coq-refman}
Dependent Type Theory (DTT), and we want to code a type-class~\cite{wadler89}
solver for Coq~\cite{Coq-refman} using the Coq-Elpi~\cite{tassi:hal-01637063}
meta programming framework.
Type-class solvers are unification based proof search procedures
that combine a set of designated lemmas in order to providing essential
automation to widely used Coq libraries.

As the running example we take the \coqIn{Decide} type class,
from the Stdpp~\cite{JUNG_KREBBERS_JOURDAN_BIZJAK_BIRKEDAL_DREYER_2018}
library. The class identifies predicates equipped with a decision procedure.
The following three designated lemmas (called \coqIn{Instances} in the
type-class jargon) state that: 1) the type \coqIn{fin n}, of natural numbers
smaller than \coqIn{n} is finite; 2) the predicate \coqIn{nfact n nf},
linking a natural number \coqIn{n} to its prime factors \coqIn{nf}, is decidable;
3) the universal closure of a predicate has a decision procedure if the
predicate has and if its domain is finite.

\begin{coqcode}
Instance fin_fin n : Finite (fin n).             (* r1 *)
Instance nfact_dec n nf : Decision (nfact n nf). (* r2 *)
Instance forall_dec A P : Finite A ~$\to$~            (* r3 *)
  ~$\forall$~x:A, Decision (P x) ~$\to$~ Decision (~$\forall$~x:A, P x).
\end{coqcode}

\noindent Under this context of instances a type-class solver is able to prove
the the following statement automatically by back-chaining.

\begin{coqcode}
  Check _ : Decision (forall y: fin 7, nfact y 3).  (* g *)
\end{coqcode}

\noindent
The encoding of DTT provided by Elpi, that we will discuss at length later in
section~\ref{sec:encodings,sec:lang-spec} and ~\ref{}, is an Higher Order Abstract
Syntax (HOAS) datatype \elpiIn{tm} featuring (among others) the following
constructors:

\begin{elpicode}
type lam  tm -> (tm -> tm) -> tm.     % lambda abstraction
type app  list tm -> tm.              % n-ary application
type all  tm -> (tm -> tm) -> tm.     % forall quantifier
type c    string -> tm.               % constants
\end{elpicode}

\noindent
Following standard $\lambda$Prolog~\cite{miller_nadathur_2012}
the concrete syntax to abstract, at the meta level, an expression
\elpiIn{e} over a variable \elpiIn{x}
is \elpiIn{x\ e}, and square brackets denote a list of
terms separated by comma. As an example we show the encoding of the Coq term
``$\forall y:\mathrm{t}.\mathrm{nfact}~ y~ 3$'':

\begin{elpicode}
all (c"t") y\ app[c"nfact", y, c"3"]
\end{elpicode}

\noindent
We now illustrate the encoding of the three instances above as higher order
logic programming rules: capital letters denote rule
parameters; \elpiIn{:-} separates the rule's head from the premises;
\elpiIn{pi w\ p} introduces a fresh nominal constant \elpiIn{w}
for the premise \elpiIn{p}.

\begin{elpicode}
finite (app[c"fin", N]).                             % r1
decision (app [c"nfact", N, NF]).                    % r2
decision (all A x\ app[P, x]) :- finite A,           % r3
  pi w\ decision (app[P, w]).
\end{elpicode}

\noindent
Unfortunately this direct translation of rule (r3) uses the
predicate \coqIn{P} essentially as a first order term for the meta
language (its type is \elpiIn{tm}).
If we try to backchain the rule (r3) on the encoding of the goal (g) below:
  
\begin{elpicode}
decision (all (app[c"fin", c"7"]) y\                 % g
  app[c"nfact", y, c"3"]).
\end{elpicode}

\noindent
we fail because of this ``higher order'' unification problem (for DTT)
is phrased as a first order unification problem in the meta language:
the two lists of terms have different lengths!

\begin{elpicode}
app[c"nfact", y, c"3"] = app[P, y]                   % p
\end{elpicode}

\noindent
In this paper we study a more sophisticated encoding of Coq terms allowing
us to rephrase the problematic rule (r3) as follows:

\begin{elpicode}
decision (all A x\ Pm x) :- link Pm A P, finite A,   % r3a
  pi x\ decision (app[P, x]).
\end{elpicode}

\noindent
Since \elpiIn{Pm} is an higher order unification variable with \elpiIn{x}
in its scope, the unification problem (pa) admits one solution:

\begin{elpicode}
app[c"nfact", y, c"3"] = Pm y                       % pa
Pm = x\ app[c"nfact", x, c"3"]       % assignment for Pm
A = app[c"fin", c"7"]                % assignment for A
\end{elpicode}
  
\noindent
After unifying the head of rule (r3a) with the goal Elpi runs
the premise \elpiIn{link Pm A P} that is in charge of bringing the
assignment for \elpiIn{Pm} (that has type \elpiIn{tm -> tm})
back to the domain of Coq terms (the type \elpiIn{tm}):

\begin{elpicode}
P = lam A a\ app[c"nfact", a, c"3"]
\end{elpicode}

\noindent
This simple example is sufficient to show that the encoding we seek
is not trivial, since the solution for \elpiIn{P} above generates a
(Coq) $\beta$-redex in the second premise (the predicate
under the \elpiIn{pi w\ }\hspace{-0.8em}):

\begin{elpicode}
decision (app[lam A (a\ app[c"nfact", a, c"3"]), w])
\end{elpicode}

\noindent
In turn this redex prevents the rule (r2) to backchain properly since
the following unification problem has no solution:

\begin{elpicode}
app[lam A (a\ app[c"nfact", a, c"3"]), x] =
app[c"nfact", N, NF]
\end{elpicode}

\noindent
The root cause of the problems we face is that the unification procedure
\Ue of the meta language is not aware of the equational theory of the object
logic \Uo, even if both theories include $\eta\beta$-conversion and admit most general
unifiers for problems in the pattern fragment~\cite{miller92jsc}.

\paragraph{Contributions}
In this paper we discuss alternative encodings of Coq in
Elpi~\ref{sec:encodings}, then we identify a minimal language \Fo
in which the problems sketched here can be fully described.
We then detail an encoding \elpiIn{comp} from \Fo{} to \Ho (the language of
the meta language) and a decoding \elpiIn{decomp} to relate the unifiers
bla bla.. TODO citare Teyjus.

\section{Problem statement and alternative encodings} %%%%%%%%%%%%%%%%%%%%%%
\label{sec:encodings}

The equational theory of Coq's Dependent Type Theory is very rich. In
addition to the usual $\eta\beta$-equivalence for functions, terms (hence types)
are compared up to definition unfolding and fixpoint unrolling. Still,
for efficiency and predictability reasons, most form of automatic proof search
employ a unification procedure that captures a simpler one,
just $\eta\beta$, and that solves higher order problems
restricted to the pattern fragment $\mathcal{L}_\lambda$~\cite{miller92jsc}.
We call this unification procedure \Uo{}.

The equational theory of the meta language Elpi that we want to use to
implement a form of proof automation is strikingly similar, since it
it comprises $\eta\beta$ (for the meta language functions), and the
unification procedure \Ue{} solves higher order problems in
$\mathcal{L}_\lambda$.

In spite of the similarity the link between \Ue{} and \Uo{} is not trivial,
since the abstraction and application term constructors
the two unification procedure deal with are different. For example

\begin{tabular}{lcl}
\elpiIn{x\ f x} & \Ue{} & \elpiIn{f}\\
\elpiIn{lam A x\ app[c"f", x]} & \Uo{} & \elpiIn{c"f"}\\
\elpiIn{lam A x\ app[c"f", x]} & \nUe{} & \elpiIn{c"f"} \\
\elpiIn{P x} & \Ue{} & \elpiIn{x}\\
\elpiIn{app[P, x]} & \Uo{} & \elpiIn{x}\\
\elpiIn{app[P, x]} & \nUe{} & \elpiIn{x}\\
\end{tabular}

\noindent
One could ignore this similarity, and ``just'' describe the object language
unification procedure in the meta language, that is crafting a \elpiIn{unif}
predicate to be used as follows in rule (r3):

\begin{elpicode}
decision X :- unif X (all A x\ app[P, x]), finite A,
  pi x\ decision (app[P, x]).
\end{elpicode}

\noindent
This choice would underuse the logic programming engine provided by
the metalanguage since by removing any datum from the head of rules
indexing degenerates. Moreover the unification procedure built in the
meta language is likely to be faster than one implemented in it,
especially if the meta language is interpreted as Elpi is. 
  
To state precisely the problem we solve we need a \Fo{} representation
of DTT terms and a \Ho one.
We call \Eo the equality over ground terms in \Fo,
\Ee the equality over ground terms in \Ho,
\Uo the unification procedure we want to implement and
\Ue the one provided by the meta language.
TODO extend \Eo and \Ee with reflexivity on uvars.

We write $t_1 \Ue t_2 \mapsto \sigma$ when $t_1$ and $t_2$ unify with substitution
$\sigma$, we write $\sigma t$ for the application of the substitution to
$t$ and we assume that the unification of our meta language is correct:

$$
t_1 \Ue t_2 \mapsto \sigma \Rightarrow \sigma t_1 \Ee \sigma t_2
$$

\newcommand{\C}[3]{\ensuremath{\langle #1 \rangle}\mapsto(#2,#3)}
\newcommand{\D}[3]{\ensuremath{\langle #1,#2 \rangle^{-1}\mapsto #3}}

We illustrate a compilation $\C{s}{t}{l}$ that
maps a term $s$ in \Fo{} to a term $t$ in \Ho and a list of links $l$.
The links connect unification variables in \Ho with variables
in \Fo{} and are used to decompile the assignment,
$\D{\sigma}{l}{\rho}$.

Given 
$$
\C{s_1}{t_1}{l_1} \land \C{s_2}{t_2}{l_2}
$$
we define
$$
s_1 \Uo s_2 \mapsto \rho \stackrel{def}{=}
    t_1 \Ue t_2 \mapsto \sigma \land
    \D{\sigma}{l_1 + l_2}{\rho}
$$

We write $s \in \mathcal{L}_\lambda$ if all unif variables in
$s$ are applied to distinct bound variables.

\begin{align}
t_1 \Uo t_2 \mapsto \rho &\Rightarrow \rho t_1 \Eo \rho t_2\\
s_i \in \mathcal{L}_\lambda \land \exists \rho, \rho s_1 \Eo \rho s_2 &\Leftrightarrow s_1 \Uo s_2 \mapsto \rho' \subseteq \rho \\
\forall \rho, \rho s_1 \Eo \rho s_2 &\Rightarrow \rho t_1 \Uo \rho t_2
\end{align}

the first one is that we are correct

the second one is that we are complete and mgu iff the problems are nice

the third one is still broken since we did not define how
to apply a fo subst to a ho term but it morally means
that any valid substitution for s1 s2 cannot break
the unification of terms t1 t2 obtained by compiling
s1 and s2 before knowing the subst.

These properties allow us to simulate a unification based
backward search on DTT by using \Ue, in a faithful way:
the trace of the logic program
performing the search not only gives the same result, but
also takes the same paths, that is it fails as early as possible.


\subsection{Alternative encodings and related work}


Our choice of encoding of DTT may look weird to the reader familiar with
LF, since used a shallow encoding of classes and binders, but not of the
``lambda calculus'' part of DTT. Here a more lightweight encoding
that unfortunately does not fit our use case

\begin{elpicode}
finite (fin N).
decision (nfact N NF).
decision (all A x\ P x) :- 
  (pi x\ decision (P x)), finite A.
\end{elpicode}

but in DTT this is not always possible and not handy in our use case,
since the arity of constants is not fixed.

\begin{coqcode}
Fixpoint narr T n := 
  if n is S m then T -> narr T m else T.
Definition nsum n : narr nat (n+1).
Check nsum 2   8 9 : nat.
Check nsum 3 7 8 9 : nat.
\end{coqcode}
  
moreover we use the same encoding for meta programming, or even just to provide
hand written rules. We want to access the syntax of OL, so our embedding cannot
be that shallow. We want to keep it shallow for the binders, but we need
the c, app and lam nodes. % all ?


Note that this~\cite{felty93lics} is related and make the
discrepancy between the types of ML and DTT visible. In this case
one needs 4 application nodes. Moreover the objective is an encoding
of terms, proofs, not proof search. Also note the conv predicate,
akin to the unif we rule out.

This other paper~\cite{10.1007/978-3-031-38499-8_25} should also be cited.

\section{Languages description}
\label{sec:lang-spec}

\input{lang_descr.tex}

% Description of languages (OL and ML)

\def\eqfo{eq\_fo\xspace}

In order to reason about unification of the terms of the objet language within the
meta language, we start by formally describing the two languages. Employing
meta-programming for this purpose, \cref{code:lang-descr} presents the type
\elpiIn{tm} containing the constructors for term application, lambda abstraction
and constants. Moreover, in order to represent unification variables, we need 
to give two different constructors. 

\

In the case of the OL, variables have no scope. For example, the subterm
\coqIn{P x} from the instance forall\_dec. Here, \coqIn{P} is an higher order
variables with type \coqIn{A ~$\to$~ Prop} and \coqIn{x} is a name bound to
\coqIn{P}. However, at the meta level, the translation of \coqIn{P x} becomes
\elpiIn{app[P, x]}, that is, \elpiIn{P} cannot reference \elpiIn{x}. In our
encoding, unification variables are encoded as integer corresponding to memory
addresses, and the constructor for unification variables in the OL is
\elpiIn{fo_uv}. This constructor is prefixed with \elpiIn{fo} since the
variable, having no scope, is a first-order variable.

On the other hand, in the case of the ML, we want to use its unification
algorithm to make variable assignment. Since the ML is an Higher Order
Programming Language, we represent unification variables with the \elpiIn{uv}
constructor, which, this time, can see a list of terms. Of course some attention
should be payed when dealing with this constructor, since we have to certify
each time that an \elpiIn{uv i} remain in the pattern fragment, that is, the
list of term in the scope of \elpiIn{i} is a list of distinct names. Finally,
the following code

\begin{elpicode}
  kind assmt type.
  type abs (tm -> assmt) -> assmt.
  type val tm -> assmt.
\end{elpicode}

\noindent
illustrates the \elpiIn{assmt} representing variable assignment in the ML. \marginpar{todo: explain better}

The memory of the two languages are represented with lists of substitutions. In
particular, the substitution of the OL, called \elpiIn{fo_subst}, is made by
optional terms such that, if the substitution is \elpiIn{none}, then the
variable is not instantiated. Note that the variables in the \elpiIn{fo_subst}
have always the \elpiIn{fo_uv} constructor. On the other hand, the ML
substitution is an optional assignment and in that assignment, variables are
considered to have the \elpiIn{uv} constructor.

A key property needed in unification is being able to verify if two terms are
equal. This is kind of a structural equality verification between two terms,
where variable dereferencing is performed when the variable is assigned. A
sketch of the equality function is given for the OL language in
\cref{code:term-equal}. Though, this equality relation over terms of a language
can be powered by other reduction rules depending equational theory being
considered. In our case, the OL terms are equal under $\eta\beta$ redex. This mean
that new rules for those two redexes are added in the implementation of
\elpiIn{fo_equal}.

If \elpiIn{fo_equal} is conceived to manage equality between terms of the OL,
the same equality predicate in the ML behave slightly different. By the given
definition of the ML, the ML allows $\eta\beta$ congruence of terms, but, since
the node \elpiIn{app} and \elpiIn{abs} are constructor representing the
applications and the abstractions of the OL, these two reduction rules cannot
applied on them. We build therefore a predicate \elpiIn{equal} working for terms
in the ML which is implemented merely with the rules for the \elpiIn{fo_equal}
predicate.\todo{not true for uv} For example, if \elpiIn{fo_equal []
(abs x\ [c"f", c]) (c"f")} is true in the object language, \elpiIn{equal [] (abs
x\ [c"f", c]) (c"f")} produces a failure.

The solution we are proposing aim to overcome these unification issues by 1)
compiling the terms $t$ and $u$ of the OL into an internal version $t'$ and $u'$
in the ML; 2) unifying $t'$ and $u'$ at the meta level instantiating meta
variables; 3) decompiling the meta variable into terms of the OL; 4) assigning
the variables of the OL with the decompiled version of their corresponding meta
variables. We claim that $t$ and $u$ unify if and only if $t'$ and $u'$ unify
and that the substitution in the object language is the same as the one returned
by the ML. \todo{same or $\supseteq$ or $\subseteq$} 

Mathematically, we what to prove the following property:

\begin{coqcode}
  forall (t  u : term_ol) (s : subst_ol) 
         (t' u': term_ml) (s': subst_ml), 
    equal_ol t u s <->
      comp t t' /\ comp u u' /\ 
      unif_ml t' u' s' /\ links ... /\ decomp s' s.
\end{coqcode}

$$Math\ formula$$

In the following section we explain how we deal with term (de)compilation and
unification variable linking.

\section[Compilation: fo\_tm to tm]{Compilation}

The compilation step is meant to recover the higher-order variables of the OL,
expressed in a first order way, by replacing them with higher-order variables in
the ML. In particular, every time a variable of the OL is encountered in the
original term, it is replaced with a meta variable, and if the OL variable is
applied to a list of distinct names $L$, then this list becomes the scope of the variable. 
For all the other constructors of
\elpiIn{tm}, the same term constructor is returned and its arguments are
recursively compiled. The predicate in charge for term compilation is:\\
\elpiIn{type comp tm -> tm -> links -> links -> subst -> subst -> o}.
Where, we take the term of the OL, produce the term of the ML, take a list
of link and produce a list of new links, take a substitution and return a 
new substitution.

In particular, due to programming constraints, we need to drag the old subst and
return a new one extended, if needed, with the new declared meta-variables.

The following code
%
\begin{elpicode}
  kind link type.
  type link nat -> nat -> nat -> subst.
\end{elpicode}
%
\noindent
defines a link, which is a relation between to variables indexes, the first
being the index of a OL variable and the second being the index of a ML
variable. The third integer\todo{integer or nat?} is the number of term in the
scope of the two variables, or equivalently, in a typed language, their arity. 

As an example, let's study the following unification problem (a slightly 
modified version from \cref{sec:intro}):

\begin{elpicode}
  lam x\ app[c"decision", app[c"nfact", x, c"3"]] ~\Uo~
    lam x\ app [c"decision", app[uv 0, x]]
\end{elpicode}

\noindent
we have the main unification problem where the nested \elpiIn{app} nodes have
lists of different lengths making the unification to fail. The compilation of 
these terms produces a new unification problem with the following shape:

\begin{elpicode}
  lam x\ app[c"decision", app[c"nfact", x, c"3"]] ~\Ue~ 
    lam x\ app [c"decision", uv 1 [x]]
\end{elpicode}

\noindent
The main difference is the replacement of the subterm \elpiIn{app[uv 0, x]} of
the OL with the subterm \elpiIn{uv 0 [x]}. Variable indexes are chosen by the
ML, that is, the index \elpiIn{0} for that unification variable of the OL term
has not the sam meaning of the index \elpiIn{0} in the ML. There exists two
different substitution mapping, one for the OL and one for the ML and the indexes
of variable point to the respective substitution.

\noindent
- how we transform an fo\_tm in tm \\
- the role of links \\
- decomp
- esempio che va in questa semplice rappresentazione (from intro)
- esempio che non va, multi-var, eta, beta
% \section{Term de-compilation}

\section{Unification in ML}

- we accept HO unif with PF \\
- need of multiple vars for a single OL var

% Compile FO to HO

% Assignement in HO should be decompiled




% -------------------------------------------------------------------

% \noindent


% \subsection{implementation}

% l'HO encoding e' esattamente lambda Prolog/elpi, il compilatore
% in pratica potrebbe essere scritto in un meta language, qui lo si presenta in
% elpi stesso. HO e FO in questo paper sono deep embedded in elpi per parlarne,
% ma in pratica il nostro solever, prendere XX, scrivere la clausola compilata.


% \section{recovering eta}

% \begin{elpicode}
% q (all x\ F x) = q (all x\ app[f,x]) /\ p f = p F
% F = fun a => app [f,a] ----> F = f
% \end{elpicode}

% l'utene da p su f, mentre l'istanza pe q forza F a fun .. 

% \section{recovering beta}

% \begin{elpicode}
%   q (all x\ F x) = q (all x\ app[f,x,x]) /\ p1 (app[f,a,a]) = p1 (app[F,a])
%   F = fun y => app [f,y,y] ----> (app[F,a]) ~> app[f, a, a].
% \end{elpicode}
  
% qui la sintesi di F puo generare un beta redex, quindi ci mettiamo
% p1 F1, e decomp beta F [a] F1.

% \section{recovering eta-beta within unification (non linear variables)}

% se i problemi di cui sopra avvengono nello stesso termine

% \begin{elpicode}
%   q2 (all x\ F x) (app[F,a]) = q2 (all x\ app[f,x,x]) (app[f,a,a])
% \end{elpicode}

% bisogna slegare le due F e poi unificare le soluzioni tra di loro

% \section{heuristic / binary app}

% fo approx / sub pattern fragment

% \begin{elpicode}
%   p (all x\app[F,x,a]) (app[F,b]) = p (all x\app[f,x,x,a]) (app[f,b,b])
%   p (all x\G x) F' = 
%   G = x\ f x x a
%   F = lam x\f x x
%   F' = (app[f,b,b])
%   link (F a) F'
%   link G F
% \end{elpicode}


% % questo esempio recupera l'app binaria perche

% \begin{elpicode}
%   (app (app F x) a) = (app (f x x) a)
% \end{elpicode}

% \section{Stats}

% Concretamente:

% - quante volte l'ordine superiore è necessario in stdpp/tlc

% \section{Conclusion}

% \printbibliography

\end{document}