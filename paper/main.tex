\documentclass[sigconf,natbib=false]{acmart}
\usepackage[]{biblatex}

\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}
\addbibresource{bib.bib}

\usepackage{myTools}
\usepackage{macros}

% TODO: set this fields
%\setcopyright{cc}
%\setcctype{by}
\copyrightyear{2024}
\acmYear{XXXX 2024}
\acmBooktitle{YYY}
\acmDOI{ZZZZZZZZZZZZ}    


% \xspaceaddexceptions{]\}}

\def\elpi{\proglang{elpi}}
\def\coqelpi{\proglang{coq-elpi}}
\def\lambdaprolog{\proglang{$\lambda$-prolog}}
\def\coq{\proglang{coq}}

\newcommand{\library}[1]{\textit{#1}\xspace}
\def\stdpp{\library{stdpp}}
\def\iris{\library{iris}}

\newcommand*{\acronym}[1]{\texttt{#1}\xspace}

\def\ol{\acronym{ol}} % object language
\def\ml{\acronym{ml}} % meta language
\def\lf{\acronym{lf}} % logical framework
\def\ho{\acronym{ho}} % higher order
\def\Forall{$\forall$}

\newcommand{\EqualRel}{\ensuremath{=}}
\newcommand{\nEqualRel}{\ensuremath{\new}}
\newcommand{\UnifRel}{\ensuremath{\simeq}}
\newcommand{\nUnifRel}{\ensuremath{\not\simeq}}

\newcommand{\Uo}{\ensuremath{\UnifRel_o}\xspace}
\newcommand{\nUo}{\ensuremath{\nUnifRel_o}\xspace}
\newcommand{\Eo}{\ensuremath{\EqualRel_o}\xspace}
\newcommand{\nEo}{\ensuremath{\nEqualRel_o}\xspace}

\newcommand{\Ue}{\ensuremath{\UnifRel_\lambda}\xspace}
\newcommand{\nUe}{\ensuremath{\nUnifRel_\lambda}\xspace}
\newcommand{\Ee}{\ensuremath{\EqualRel_\lambda}\xspace}
\newcommand{\nEe}{\ensuremath{\nEqualRel_\lambda}\xspace}
\newcommand{\llambda}{\ensuremath{\mathcal{L}_\lambda}\xspace}

\newcommand{\Fo}{\ensuremath{\mathcal{F}_{\!o}\xspace}} % space non va
\newcommand{\Ho}{\ensuremath{\mathcal{H}_o}\xspace}

\newcommand*{\eqtau}{\ensuremath{\mathrel{\overset{\mathrm{\tau}}{=}}}}

\begin{document}

\title{HO unification from object language to meta language} 

\author{Enrico Tassi}
\email{enrico.tassi@inria.fr}
\affiliation{%
  \institution{Université Côte d'Azur, Inria}
  % \city{Nice}
  \country{France}}

\author{Davide Fissore}
\email{davide.fissore@inria.fr}
\affiliation{%
  \institution{Université Côte d'Azur, Inria}
  % \city{Nice}
  \country{France}}

\begin{abstract}
  Specifying and implementing a logic from scratch requires significant effort.
  Logical Frameworks and Higher Order Logic Programming Languages provide
  dedicated, high-level Meta Languages (ML) to facilitate this task in two
  key ways: 1) variable binding and substitution are simplified when ML binders
  represent object logic ones; 2) proof construction, and even proof search, is
  greatly simplified by leveraging the unification procedure provided by the ML.
  Notable examples of ML are Elf~\cite{elf}, Twelf~\cite{twelf},
  $\lambda$Prolog~\cite{miller_nadathur_2012} and
  Isabelle~\cite{10.1007/978-3-540-71067-7_7}
  which have been utilized to implement various formal systems such as
  First Order Logic~\cite{felty88cade},
  Set Theory~\cite{10.1007/BF00881873},
  Higher Order Logic~\cite{books/sp/NipkowPW02}, and even the Calculus of
  Constuctions~\cite{felty93lics}.
  
  The object logic we are interested in is Coq's~\cite{Coq-refman}
  Dependent Type Theory (DTT),
  for which we aim to implement a unification procedure \Uo using the ML
  Elpi~\cite{dunchev15lpar}, a dialect of $\lambda$Prolog.
  Elpi's equational theory comprises
  $\eta\beta$ equivalence and comes equipped with a
  higher order unification procedure \Ue restricted to the pattern
  fragment~\cite{miller92jsc}.
  We want \Uo to be as powerful as \Ue but on the object logic DTT.
  Elpi also comes with an encoding for DTT that works well
  for meta-programming~\cite{tassi:hal-01637063,tassi:hal-01897468,gregoire:hal-03800154,newtc}.
  Unfortunately this encoding, which we refer to as \Fo,
  ``underuses'' \Ue by restricting it to first-order unification problems only. 
  To address this issue, we propose a better-behaved encoding, \Ho,
  demonstrate how to map unification problems in \Fo{}
  to related problems in \Ho, and illustrate
  how to map back the unifiers found by \Ue, effectively implementing
   \Uo on top of \Ue for the encoding \Fo.
   
  We apply this technique to the implementation of a type-class~\cite{wadler89}
  solver for Coq~\cite{Coq-refman}.
  Type-class solvers are proof search procedures based on
  unification that back-chain designated lemmas, providing essential
  automation to widely used 
  Coq libraries such as Stdpp/Iris~\cite{JUNG_KREBBERS_JOURDAN_BIZJAK_BIRKEDAL_DREYER_2018}
  and TLC~\cite{10.1007/978-3-642-14052-5_15}. These two libraries
  constitute our test bed.
\end{abstract} 

\keywords{Logic Programming, Meta-Programming, Higher-Order Unification, Proof Automation}

\maketitle

\section{Introduction}
\label{sec:intro}

Specifying and implementing a logic from scratch requires significant effort.
Logical Frameworks and Higher Order Logic Programming Languages provide
dedicated, high-level Meta Languages (ML) to facilitate this task in two
key ways: 1) variable binding and substitution are simplified when ML binders
represent object logic ones; 2) proof construction, and even proof search, is
greatly simplified by leveraging the unification procedure provided by the ML.
Notable examples of ML are Elf~\cite{elf}, Twelf~\cite{twelf},
$\lambda$Prolog~\cite{miller_nadathur_2012} and
Isabelle~\cite{10.1007/978-3-540-71067-7_7}
which have been utilized to implement various formal systems such as
First Order Logic~\cite{felty88cade},
Set Theory~\cite{10.1007/BF00881873},
Higher Order Logic~\cite{books/sp/NipkowPW02}, and even the Calculus of
Constuctions~\cite{felty93lics}.

The object logic we are interested in is Coq's~\cite{Coq-refman}
Dependent Type Theory (DTT), and we want to code a type-class~\cite{wadler89}
solver for Coq~\cite{Coq-refman} using the Coq-Elpi~\cite{tassi:hal-01637063}
meta programming framework.
Type-class solvers are unification based proof search procedures
that combine a set of designated lemmas in order to providing essential
automation to widely used Coq libraries.

As the running example we take the \coqIn{Decide} type class,
from the Stdpp~\cite{JUNG_KREBBERS_JOURDAN_BIZJAK_BIRKEDAL_DREYER_2018}
library. The class identifies predicates equipped with a decision procedure.
The following three designated lemmas (called \coqIn{Instances} in the
type-class jargon) state that: 1) the type \coqIn{fin n}, of natural numbers
smaller than \coqIn{n} is finite; 2) the predicate \coqIn{nfact n nf},
linking a natural number \coqIn{n} to its prime factors \coqIn{nf}, is decidable;
3) the universal closure of a predicate has a decision procedure if the
predicate has and if its domain is finite.

\begin{coqcode}
Instance fin_fin n : Finite (fin n).              (* r1 *)
Instance nfact_dec n nf : Decision (nfact n nf).  (* r2 *)
Instance forall_dec A P : Finite A ~$\to$~             (* r3 *)
  ~$\forall$~x:A, Decision (P x) ~$\to$~ Decision (~$\forall$~x:A, P x).
\end{coqcode}

\noindent Under this context of instances a type-class solver is able to prove
the following statement automatically by back-chaining.

\begin{coqcode}
  Check _ : Decision (forall y: fin 7, nfact y 3).       ~\customlabel{goal:g}{(g)}~
\end{coqcode}

\noindent
The encoding of DTT provided by Elpi, that we will discuss at length later in
section~\ref{sec:encodings,sec:lang-spec} and ~\ref{}, is an Higher Order Abstract
Syntax (HOAS) datatype \elpiIn{tm} featuring (among others) the following
constructors:

\begin{elpicode}
type lam  tm -> (tm -> tm) -> tm.     % lambda abstraction
type app  list tm -> tm.              % n-ary application
type all  tm -> (tm -> tm) -> tm.     % forall quantifier
type con  string -> tm.               % constants
\end{elpicode}

\noindent
Following standard $\lambda$Prolog~\cite{miller_nadathur_2012}
the concrete syntax to abstract, at the meta level, an expression
\elpiIn{e} over a variable \elpiIn{x}
is <<\elpiIn{x\ e}>>, and square brackets denote a list of
terms separated by comma. As an example we show the encoding of the Coq term
<<\coqIn{~$\forall$~y:t, nfact y 3}>>:

\begin{elpicode}
all (con"t") y\ app[con"nfact", y, con"3"]
\end{elpicode}

\noindent
We now illustrate the encoding of the three instances above as higher-order
logic-programming rules: capital letters denote rule
parameters; \elpiIn{:-} separates the rule's head from the premises;
\elpiIn{pi w\ p} introduces a fresh nominal constant \elpiIn{w}
for the premise \elpiIn{p}.

\begin{elpicode}
finite (app[con"fin", N]).                            ~\customlabel{clause:r1}{(r1)}~
decision (app [con"nfact", N, NF]).                   ~\customlabel{clause:r2}{(r2)}~
decision (all A x\ app[P, x]) :- finite A,            ~\customlabel{clause:r3}{(r3)}~
  pi w\ decision (app[P, w]).
\end{elpicode}

\noindent
Unfortunately this translation of rule \ref{clause:r3} uses the
predicate \coqIn{P} as a first order term for the meta
language (its type is \elpiIn{tm}).
If we try to backchain the rule \ref{clause:r3} on the encoding of the goal
\ref{goal:g}:
  
\begin{elpicode}
decision (all (app[con"fin", con"7"]) y\                 
  app[con"nfact", y, con"3"]).
\end{elpicode}

\noindent
we obtain an unsolvable unification problem \ref{problem:p}:
the two lists of terms have different lengths!
%The root cause is that
%\ref{problem:p} is an higher order in DTT, but becomes
%first order in the meta language due to the ``naive'' encoding.

\begin{elpicode}
app[con"nfact", y, con"3"] = app[P, y]                 ~\customlabel{problem:p}{(p)}~
\end{elpicode}

\noindent
In this paper we study a more sophisticated encoding of Coq terms allowing
us to rephrase the problematic rule \ref{clause:r3} as follows:

\begin{elpicode}
decision (all A x\ Pm x) :- link Pm P A, finite A,   ~\customlabel{clause:r3a}{(r3a)}~
  pi x\ decision (app[P, x]).
\end{elpicode}

\noindent
Since \elpiIn{Pm} is an higher-order unification variable with \elpiIn{x}
in its scope, the unification problem \ref{problem:pa} admits one solution:

\begin{elpicode}
app[con"nfact", y, con"3"] = Pm y                     ~\customlabel{problem:pa}{(p')}~
Pm = x\ app[con"nfact", x, con"3"]     % assignment for Pm
A = app[con"fin", con"7"]              % assignment for A
\end{elpicode}
  
\noindent
After unifying the head of rule \ref{clause:r3a} with the goal, Elpi runs
the premise <<\elpiIn{link Pm A P}>> that is in charge of bringing the
assignment for \elpiIn{Pm} (that has type \elpiIn{tm -> tm})
back to the domain of Coq terms:

\begin{elpicode}
P = lam A a\ app[con"nfact", a, con"3"]
\end{elpicode}

\noindent
This simple example is sufficient to show that the encoding we seek
is not trivial and does not only concern the head of rules, but the entire sequence
of unification problems that constitute the execution of a logic program.
In fact
the solution for \elpiIn{P} above generates a
(Coq) $\beta$-redex in the second premise (the predicate
under the \elpiIn{pi w\ }\hspace{-0.4em}):

\begin{elpicode}
decision (app[lam A (a\ app[con"nfact", a, con"3"]), w])
\end{elpicode}

\noindent
In turn this redex prevents the rule \ref{clause:r2} to backchain properly since
the following unification problem has no solution:

\begin{elpicode}
app[lam A (a\ app[con"nfact", a, con"3"]), x] =
app[con"nfact", N, NF]
\end{elpicode}
\noindent
~\\
The root cause of the problems we sketched in the running example
is that the unification procedure \Ue of the meta language is not aware
of the equational theory of the object logic, even if both theories
include $\eta\beta$-conversion and admit most general
unifiers for unification problems in the pattern fragment \llambda~\cite{miller92jsc}.

\paragraph{Contributions}
In this paper we discuss alternative encodings of Coq in
Elpi~\ref{sec:encodings}, then we identify a minimal language \Fo
in which the problems sketched here can be fully described.
We then detail an encoding \elpiIn{comp} from \Fo{} to \Ho (the language of
the meta language) and a decoding \elpiIn{decomp} to relate the unifiers
bla bla.. TODO citare Teyjus.

\section{Problem statement} %%%%%%%%%%%%%%%%%%%%%%
\label{sec:encodings}

The equational theory of Coq's Dependent Type Theory is very rich. In
addition to the usual $\eta\beta$-equivalence for functions, terms (hence types)
are compared up to definition unfolding and fixpoint unrolling. Still,
for efficiency and predictability reasons, most form of automatic proof search
employ a unification procedure that captures a simpler one,
just $\eta\beta$, and that solves higher-order problems
restricted to the pattern fragment $\mathcal{L}_\lambda$~\cite{miller92jsc}.
We call this unification procedure \Uo{}.

The equational theory of the meta language Elpi that we want to use to
implement a form of proof automation is strikingly similar, since it
it comprises $\eta\beta$ (for the meta language functions), and the
unification procedure \Ue{} solves higher-order problems in
$\mathcal{L}_\lambda$.

In spite of the similarity the link between \Ue{} and \Uo{} is not trivial,
since the abstraction and application term constructors
the two unification procedures deal with are different. For example

\begin{tabular}{lcl}
\elpiIn{x\ f x} & \Ue{} & \elpiIn{f}\\
\elpiIn{lam A x\ app[con"f", x]} & \Uo{} & \elpiIn{con"f"}\\
\elpiIn{lam A x\ app[con"f", x]} & \nUe{} & \elpiIn{con"f"} \\
\elpiIn{P x} & \Ue{} & \elpiIn{x}\\
\elpiIn{app[P, x]} & \Uo{} & \elpiIn{x}\\
\elpiIn{app[P, x]} & \nUe{} & \elpiIn{x}\\
\end{tabular}

\noindent
One could ignore this similarity, and ``just'' describe the object language
unification procedure in the meta language, that is crafting a \elpiIn{unif}
predicate to be used as follows in rule \ref{clause:r3}:

\begin{elpicode}
decision X :- unif X (all A x\ app[P, x]), finite A,
  pi x\ decision (app[P, x]).
\end{elpicode}

\noindent
This choice would underuse the logic programming engine provided by
the metalanguage since by removing any datum from the head of rules
indexing degenerates. Moreover the unification procedure built in the
meta language is likely to be faster than one implemented in it,
especially if the meta language is interpreted as Elpi is. 
  
To state precisely the problem we solve we need a \Fo{} representation
of DTT terms and a \Ho one.
We call \Eo the equality over ground terms in \Fo,
\Ee the equality over ground terms in \Ho,
\Uo the unification procedure we want to implement and
\Ue the one provided by the meta language.
TODO extend \Eo and \Ee with reflexivity on uvars.

\newcommand{\specunif}[3]{
  #3_i \in \mathcal{L}_\lambda \Rightarrow %
    \exists \rho, %
      \rho #3_1 #1 \rho #3_2  %
        \Leftrightarrow #3_1 #2 #3_2 \mapsto \rho' \subseteq \rho 
}


\newcommand{\unifcorrect}[3]{
  % \forall \rho #3_1 #3_2, %
    % \{#3_1, #3_2\} \subseteq \llambda \Rightarrow %
    #3_i \in \llambda \Rightarrow
      #3_1 #2 #3_2 \mapsto \rho
        \Rightarrow 
          \rho #3_1 #1 \rho #3_2  %
}

\newcommand{\unifcomplete}[3]{
  % \forall #3_1 #3_2, %
    % \{#3_1, #3_2\} \subseteq \llambda \Rightarrow %
    #3_i \in \llambda \Rightarrow
      % \forall \rho, %
        \rho #3_1 #1 \rho #3_2  %
          \Rightarrow \exists \rho', #3_1 #2 #3_2 \mapsto \rho' \land \rho' \subseteq \rho 
}

We write $t_1 \Ue t_2 \mapsto \sigma$ when $t_1$ and $t_2$ unify with substitution
$\sigma$, we write $\sigma t$ for the application of the substitution to
$t$, $\sigma \subseteq \sigma'$ when $\sigma$ is more general than $\sigma'$,
and we assume that the unification of our meta language is correct:

%
\begin{gather}
  \unifcorrect{\Ee}{\Ue}{t} \label{prop:correct-ml}\\
  \unifcomplete{\Ee}{\Ue}{t}
\end{gather}

\newcommand{\C}[3]{\ensuremath{\langle #1 \rangle}\mapsto(#2,#3)}
\newcommand{\D}[3]{\ensuremath{\langle #1,#2 \rangle^{-1}\mapsto #3}}

We illustrate a compilation $\C{s}{t}{l}$ that
maps a term $s$ in \Fo{} to a term $t$ in \Ho and a list of links $l$.
The links connect unification variables in \Ho with variables
in \Fo{} and are used to decompile the assignment,
$\D{\sigma}{l}{\rho}$.

Given 
$$
\C{s_1}{t_1}{l_1} \land \C{s_2}{t_2}{l_2}
$$
we define
$$
s_1 \Uo s_2 \mapsto \rho \stackrel{def}{=}
    t_1 \Ue t_2 \mapsto \sigma \land
    \D{\sigma}{l_1 + l_2}{\rho}
$$
Where $l_1 + l_2$ is the list concatenation of links.

We write $s \in \mathcal{L}_\lambda$ if all unif variables in
$s$ are applied to distinct bound variables.
%
\begin{gather}
\unifcorrect{\Eo}{\Uo}{s}\label{prop:correct}\\
\unifcomplete{\Eo}{\Uo}{s}\label{prop:complete}\\
% \forall \rho'\rho, 
  \rho s_1 \Eo \rho s_2 \Rightarrow
  \rho' \subseteq \rho \Rightarrow
  \rho's_i \in \mathcal{L}_\lambda \Rightarrow
  \rho' s_1 \Uo \rho' s_2 \label{prop:simulation}
\end{gather}

Properties \ref{prop:correct} and \ref{prop:complete} state, respectively, that
in \llambda the implementation of \Uo is correct, complete and returns the most
general unifier.

Property \ref{prop:simulation} states that \Uo is resilient to problems outside
\llambda if a third party provides a (partial) solution for its problem. Since
we are interested in using \Uo in a proof search procedure, made of a sequence
of unification problems, not necessarily in \llambda. In practice it is often
the case the order in which these problems are stated matters. A Typical example
is the following problem

\begin{elpicode}
app [F, con"a"] = app[F, con"a", con"a"]
\end{elpicode}

\noindent
preceded by 

\begin{elpicode}
F = lam x\app[const f,x,x]
\end{elpicode}

\noindent
becomes solvable in DTT trivially, since the term is ground (hence in \llambda),
but is one substitutes F in the LHS does not find, structurally, the RHS
hence \Ue would fail (since \Ue does not know about the $\beta$ rule of DTT).
Our compiler takes care of making property \ref{prop:simulation} hold, see
section XXX.

Property \ref{prop:complete} is also relevant to use \Uo for logic programming.
In particular we want failures to occur as early as possible, so want
the decomp phase to take place immediately after \Ue, and fail if need be.
This becomes particularly important since compile may introduce two
ho variables for the same fo one, leaving the task of unifying the solutions
to decomp.

\section{Alternative encodings and related work}


Our encoding of DTT may look ``semi shallow'' since we we use the meta language
lambda abstraction but not its application (for the terms of type \elpiIn{tm}).
A fully shallow encoding unfortunately does not fit our use case, although
it would make the running example work:

\begin{elpicode}
finite (fin N).
decision (nfact N NF).
decision (all A x\ P x) :- finite A, pi x\ decision (P x).
\end{elpicode}

\noindent
There are two reasons for dismissing this encoding. The first one is that
in DTT it is not always possible to adopt it since the type system
of the meta language is too weak to accommodate terms with a variable arity,
like the following example:

\begin{coqcode}
Fixpoint arr T n := if n is S m then T -> arr T m else T.
Definition sum n : arr nat n := ...
Check sum 2   7 8   : nat.
Check sum 3   7 8 9 : nat.
\end{coqcode}

\noindent
The second reason is the encoding for Coq is used for meta programming the
system, hence it must accommodate the manipulation of terms that are now
know in advance (not even defined in Coq) without using introspection
primitives such as Prologs's \texttt{functor} and \texttt{arg}.

In the literature we could find a few related encoding of DTT.
TODO In~\cite{felty93lics} is related and make the
discrepancy between the types of ML and DTT visible. In this case
one needs 4 application nodes. Moreover the objective is an encoding
of terms, proofs, not proof search. Also note the conv predicate,
akin to the unif we rule out.

TODO This other paper~\cite{10.1007/978-3-031-38499-8_25} should also be cited.

None of the encodings above provide a solution to our problem.

\section{Languages description}
\label{sec:lang-spec}

% \input{lang_descr.tex}

% Description of languages (OL and ML)

\def\eqfo{eq\_fo\xspace}

In order to reason about unification of the terms of the objet language within the
meta language, we start by formally describing the two languages. Employing
meta-programming for this purpose, we present in \cref{code:common-terms} a new type for the terms of
the OL.
%
\setlength{\abovecaptionskip}{0pt}
\setlength{\belowcaptionskip}{-13pt}

\begin{figure}[H]
  \begin{elpicode}
    kind tm type.
    type app list tm -> tm.
    type lam (tm -> tm) -> tm.
    type con string -> tm.
  \end{elpicode}
  \caption{Common terms}
  \label{code:common-terms}
  \Description[code:common-terms]{code:common-terms}
\end{figure}
%
\noindent
This encoding is very similar to the one introduced in \cref{sec:intro},\todo{say we do not care about types} except
for the \elpiIn{all} constructor. We explicitly neglect it since blabla.
Moreover, since we are working with unification variables we need to introduce a
new constructor. 

In the case of the OL, variables have no scope. For example, the subterm
\coqIn{P x} from the instance forall\_dec has \coqIn{P} an higher order
variables with type \coqIn{A ~$\to$~ Prop} and \coqIn{x} as bound variable. 
However, at the meta level, the translation of \coqIn{P x} becomes
\elpiIn{app[P, x]}, that is, \elpiIn{P} cannot reference \elpiIn{x}. In our
encoding, we represent the variables of the OL in the following way:

\begin{elpicode}
  type fo_uv nat -> tm.
\end{elpicode}

\noindent 
In particular, a variable of the OL is identified by a integer
refereeing a memory address. This constructor is prefixed with \elpiIn{fo} since
the variable, having no scope, is a first-order variable. Finally, the memory of
the OL is depicted by the following type abbreviation:

\begin{elpicode}
  typeabbrev fo_subst list (option tm).
\end{elpicode}

\noindent 
which is a list of optional terms. If a cell is \elpiIn{none}, then the variable
corresponding to this cell is not instantiated.

On the other hand, the terms of the ML have exactly the same shape
has the terms of \cref{code:common-terms}. However, since the ML is an Higher
Order Programming Language, unification unification variables must have a scope.
We represent them in the following way:

\begin{elpicode}
  type ho_uv nat -> list tm -> tm.
\end{elpicode}

Of course some attention
should be payed when dealing with \elpiIn{ho_uv}, since we have to certify
that an \elpiIn{uv i} remain in the pattern fragment, that is, the
list of term in the scope of \elpiIn{i} is always a list of distinct names.

Another important implementation should be provided in order to represent the
lambda abstractions and the applications of the ML. As outlined in
\cref{sec:encodings}, <<\elpiIn{x\ f x}>> has not the same semantic as 
<<\elpiIn{lam x\ app[f, x]}>>, since, even though, the two terms represent the same
concept, the former is the lambda abstraction of \elpiIn{f} applied to the 
binder in ML, whereas the latter is the same term representation but wrt the OL.
We already have defined the nodes \elpiIn{app} and \elpiIn{lam} for the OL,
therefore, in the following code snippet, we give their representation in the
ML.

\begin{elpicode}
  kind assmt type.
  type abs (tm -> assmt) -> assmt.
  type val tm -> assmt.
\end{elpicode}

\noindent
In particular, the node \elpiIn{abs} stands for the lambda abstraction. The
node \elpiIn{val} contains terms of the object language. The node for variable
application is not really necessary, since, using the syntax of the ML, it is
defined by putting two terms of the ML side by side. For example, the terms 
<<\elpiIn{x\ f x}>> becomes <<\elpiIn{abs x\ f x}>>.

The memory of the ML, is defined with the following type abbreviation:

\begin{elpicode}
  typeabbrev ho_subst list (option tm).
\end{elpicode}

\noindent
with the invariant that the \elpiIn{tm} inside the cell never contains the node
\elpiIn{fo_uv}. Note that, reciprocally, the \elpiIn{fo_subst} does not contain
any node of the form \elpiIn{ho_uv}.

\subsection{Auxiliary relations}

Together with the description of the terms of the language, we need some
auxiliary functions to perform operations like term equality, unification,
dereferencing. There predicates are supposed to be implemented in the OL and the
ML following respectively their specification. In the following few paragraphs
we give a brief definition of them.

\paragraph{Term dereferencing: $\rho s$ vs. $\sigma t$}

Since in our encoding we explicitly drag substitution mappings, we need to
dereference variables of the two languages. This is particularly useful to check
if two terms in the OL (resp. in the ML) are equal. The constructors
representing rigid terms, namely \elpiIn{app}, \elpiIn{lam} and \elpiIn{con},
make the dereferencing procedure to recurse over the their subterms. The code
below display this behavior for the dereferencing performed by the OL:

\begin{elpicode}
  type fo_deref fo_subst -> tm -> tm -> o.
  fo_deref S (app L1) (app L2) :- forall2 (fo_deref S) L1 L2.
  fo_deref S (lam F1) (lam F2) :- 
    pi x\ fo_deref S x x => fo_deref S (F1 x) (F2 x).
  fo_deref _ (con X) (con X).
\end{elpicode}

A very similar implementation for the dereferencing performed by the ML, given 
in the appendix, can be encoded respecting the signature:

\begin{elpicode}
  type ho_deref ho_subst -> tm -> tm -> o.
\end{elpicode}

More attention should be payed when the dereferencing encounters a subterm that
is unification variable. The following new rules should be added to the previous
code snipper to complete the dereferencing of variables of the OL:

\begin{elpicode}
  fo_deref S (fov N) R :- assigned? N S T, fo_deref S T R.
  fo_deref S (app [fov N|L]) R :- 
    assigned? N S T, beta T L R', fo_deref S R' R.
  fo_deref _ (fov N) (fov N).
\end{elpicode}

In particular, 1) if the variable \elpiIn{fov N} is assigned to a term
\elpiIn{T} in a substitution mapping \elpiIn{S}, we return the result of
dereferencing \elpiIn{T}; 2) if the current term is the application of a
variable \elpiIn{fov N} assigned to a list of terms \elpiIn{L} and \elpiIn{uv N}
is assigned to a term \elpiIn{T}, we return the result of dereferencing the beta
reduction of \elpiIn{T} to \elpiIn{L}. This is due to the semantics of the
unification variables within the OL; 3) finally, if \elpiIn{uv N} is not
assigned, then the same variable is returned.

A different reasoning is to be addressed to the variables of the ML. Firstly, a
meta variable cannot appear in the \elpiIn{app} node as the first element of the
list, we will explain why in \cref{sec:compilation}; secondly, variables in the
ML have a scope which should be taken into account. The following few lines of
code outline the rules of dereferencing for the ML:

\begin{elpicode}
  ho_deref H (hov N L) R :- assigned? N H T, 
    ho_beta T L R', ho_deref H R' R.
  ho_deref H (hov X L) (hov X L1) :- 
    forall2 (ho_deref H) L L1.
\end{elpicode}

\noindent
where, 1) if the variable \elpiIn{hov N L} has an assignment \elpiIn{T}, we
return the dereferencing of the beta reduction \elpiIn{T} to the scope
\elpiIn{L}.

\begin{figure}
  \begin{elpicode}
    type ~(\Eo)~ tm -> tm -> o.
    % congruence
    app L1 ~\Eo~app L2 :- forall2 ~(\Eo)~ L1 L2.
    lam F1 ~\Eo~lam F2 :- pi x\ x ~\Eo~x => F1 x ~\Eo~F2 x.
    con X ~\Eo~con X.
    fov N ~\Eo~fov N.
    % eta
    lam F ~\Eo~T :- pi x\ beta T [x] (T' x),                 ~($\customlabel{clause:eta1}{\eta_1}$)~
      x ~\Eo~x => F x ~\Eo~T' x.
    T ~\Eo~lam F :- pi x\ beta T [x] (T' x),                 ~($\customlabel{clause:eta2}{\eta_2}$)~
      x ~\Eo~x => T' x ~\Eo~F x.
    % beta
    app [lam X | TL] ~\Eo~T :- beta (lam X) TL T', T' ~\Eo~T. ~($\customlabel{clause:beta1}{\beta_1}$)~
    T ~\Eo~app [lam X | TL] :- beta (lam X) TL T', T ~\Eo~T'. ~($\customlabel{clause:beta2}{\beta_2}$)~
  \end{elpicode}
  \caption{Equal predicate}
  \label{code:eq-pred}
  \Description[code:equal-pred]{code:equal-pred}
\end{figure}

\paragraph{Term equality: \Eo vs. \Ee} We can test if two terms are equal
following the equational theory of the language being considered. In
\cref{code:eq-pred} we provide an implementation of the \Eo predicate. The first
four rules check if the two terms are equal regarding the structure of the
current node, that is, two terms are equal if they have same head and if
recursively each subterm is two by two equal. Moreover, since the theory of the
OL accepts $\eta$- and $\beta$-equivalence, then we implement the corresponding
rules.

\noindent
The equality relation for the ML, accepts $\eta\beta$-equivalence between terms
of the ML. Recall that \elpiIn{abs x\ f x}, is a valid $\eta$ expansion of the
function \elpiIn{f} and that \elpiIn{lam x\ app[f, x]} is not that equivalent to
\elpiIn{f} at meta level. However, since we are interested in using the
unification procure of the ML, by \cref{prop:correct-ml}, we can use the
\Ue relation to test, when needed if two terms are equal in the ML.

\paragraph{Term unification: \Uo vs. \Ue} 
The last but not least important relation we should take care of before
presenting our full algorithm aiming to unify terms of the OL in the ML and
provide the substitution produced in the ML to the OL, is term unification. This
procedure is a more powerful version of the equal predicate, since unification
checks if two terms can be equal be assigning unification variables. In our
representation, variable assignment (or refinement) is performed by modifying
the corresponding substitution mapping. We will not give an implementation of
\Uo, since we are giving an implementation of it using
our algorithm, see \cref{XX}.

\begin{figure}
  \begin{elpicode}
    type unif tm -> tm -> ho_subst -> ho_subst ->  o.
    % Base cases
    unif (app L1) (app L2) S S1 :- fold2 unif L1 L2 S S1.
    unif (lam F1) (lam F2) S S1 :- 
      pi x\ (pi S\ unif x x S S) => unif (F1 x) (F2 x) S S1.
    unif (con X) (con X) S S.
    % Assigned variables
    unif (hov N Args) T S S1 :- 
      assigned-deref N S F, beta-abs F Args T1, unif T1 T S S1.
    unif T (hov N Args) S S1 :- 
      assigned-deref N S F, beta-abs F Args T1, unif T T1 S S1.
    % Non-assigned variabless
    unif (hov N Args1) (hov M Args2) S S3 :-  
      pattern-fragment Args1, pattern-fragment Args2, 
      new S W S1, prune W Args1 Args2 Ass, 
      assign N S1 Ass S2, assign M S2 Ass S3.
    unif (hov N Args) T S S1 :- pattern-fragment Args,
      not (T = hov _ _), not_occ N S T,  
      bind Args T T1, assign N S T1 S1.
    unif T (hov N Args) S S1 :- pattern-fragment Args,
      not (T = hov _ _), not_occ N S T, 
       bind Args T T1, assign N S T1 S1.
  \end{elpicode}
  \caption{The \Ue predicate}
  \label{code:ue-pred}
  \Description[code:unif-pred]{code:unif-pred}
\end{figure}

On the other hand, unification in the ML needs to be defined. In
\cref{code:ue-pred}, we give an implementation of \Ue. This predicate has four
arguments, the two terms $t_1$ and $t_2$ to unify, the old substitution map
$\rho_1$, and the new substitution map $\rho_2$, with the invariant $\rho_1
\subseteq \rho_2$. The first three rules unify terms with same rigid heads, and
call the unification relation on the sub-terms. If $t_1$ (resp. $t_2$) is an
assigned variables, $t_1$ is dereferenced to $t_1'$ (resp. $t_2'$) and the
unification is called between $t_1'$ and $t_2$ (resp. $t_1$ and $t_2'$). If both
terms are unification variables, we test that their arguments are in the pattern
fragment, we allocate a new variable $w$ in $\rho_1$ such that $w$ is the
pruning of the arguments of $t_1$ and $t_2$, we assign both $t_1$ and $t_2$ to
$w$ and return the new mapping $\rho_2$ containing all the new variable
assignment. Finally, if only one of the two terms is an unification variable
$v$, after having verified that $v$ does not occur in the other term $t$, we
bind $v$ to $t$ and return the new substitution mapping.

\old

A key property needed in unification is being able to verify if two terms are
equal wrt a given equational theory. This relation allow to compare terms under
a certain substitution mapping, so that any time a variable $v$ is assigned in a
subterm, a dereferencing of $v$ is performed. After variable dereferencing, the
test for equality is continued on the new-created subterm.

The base equality function over terms can be defined as follows:

The solution we are proposing aim to overcome these unification issues by 1)
compiling the terms $t$ and $u$ of the OL into an internal version $t'$ and $u'$
in the ML; 2) unifying $t'$ and $u'$ at the meta level instantiating meta
variables; 3) decompiling the meta variable into terms of the OL; 4) assigning
the variables of the OL with the decompiled version of their corresponding meta
variables. We claim that $t$ and $u$ unify if and only if $t'$ and $u'$ unify
and that the substitution in the object language is the same as the one returned
by the ML. \todo{same or $\supseteq$ or $\subseteq$} 

In the following section we explain how we deal with term (de)compilation and
links between unification variables.

\section[Compilation: fo\_tm to tm]{Compilation}
\label{sec:compilation}

\otext{Goal: $s_1 \Uo s_2$ is compiled into $t_1 \Ue t_2$}
\otext{What is done: uvars \elpiIn{fo_uv} of OL are replaced into uvars \elpiIn{ho_uv} of the ML}
\otext{Each \elpiIn{fo_uv} is linked to an \elpiIn{ho_uv} of the OL}
\otext{Example: \elpiIn{lam x\ app[uv 0, x] ~\Ue~lam x\ c"f"}}
\otext{Links used to instantiate vars of elpi}
\otext{After all links, the solution in links are compacted and given to coq}
\otext{It is not so simple, see next sections (multi-vars, eta, beta)}


The compilation step is meant to recover the higher-order variables of the OL,
expressed in a first order way, by replacing them with higher-order variables in
the ML. In particular, every time a variable of the OL is encountered in the
original term, it is replaced with a meta variable, and if the OL variable is
applied to a list of distinct names $L$, then this list becomes the scope of the variable. 
For all the other constructors of
\elpiIn{tm}, the same term constructor is returned and its arguments are
recursively compiled. The predicate in charge for term compilation is:

\elpiIn{type comp tm -> tm -> links -> links -> subst -> subst -> o}. 

\noindent
where, we take the term of the OL, produce the term of the ML, take a list
of link and produce a list of new links, take a substitution and return a 
new substitution.

In particular, due to programming constraints, we need to drag the old subst and
return a new one extended, if needed, with the new declared meta-variables.

The following code
%
\begin{elpicode}
  kind link type.
  type link nat -> nat -> nat -> subst.
\end{elpicode}
%
\noindent
defines a link, which is a relation between to variables indexes, the first
being the index of a OL variable and the second being the index of a ML
variable. The third integer\todo{integer or nat?} is the number of term in the
scope of the two variables, or equivalently, in a typed language, their arity. 

As an example, let's study the following unification problem (a slightly 
modified version from \cref{sec:intro}):

\begin{elpicode}
  lam x\ app[c"decision", app[c"nfact", x, c"3"]] ~\Uo~
    lam x\ app [c"decision", app[uv 0, x]]
\end{elpicode}

\noindent
we have the main unification problem where the nested \elpiIn{app} nodes have
lists of different lengths making the unification to fail. The compilation of 
these terms produces a new unification problem with the following shape:

\begin{elpicode}
  lam x\ app[c"decision", app[c"nfact", x, c"3"]] ~\Ue~ 
    lam x\ app [c"decision", uv 1 [x]]
\end{elpicode}

\noindent
The main difference is the replacement of the subterm \elpiIn{app[uv 0, x]} of
the OL with the subterm \elpiIn{uv 0 [x]}. Variable indexes are chosen by the
ML, that is, the index \elpiIn{0} for that unification variable of the OL term
has not the sam meaning of the index \elpiIn{0} in the ML. There exists two
different substitution mapping, one for the OL and one for the ML and the indexes
of variable point to the respective substitution.

\section{Use of multivars}

\subsection{Problems with $\eta$}
\otext{The following goal: \elpiIn{X = lam x\ lam y\ Y x y, X = lam x\ f}}
\otext{The snd unif pb, we have to unif \elpiIn{lam x\ lam y\ Y x y} with \elpiIn{lam x\ f}}
\otext{It is not doable, with the same elpi var}


\subsection{Problems with $\beta$}

\otext{The following goal: \elpiIn{X = lam x\ x, app[X, 3] = 3}}
\otext{We use links-beta}

\section{First order approximation}

\otext{Coq can solve this: \coqIn{f 1 2 = X 2}, by setting X to f 1}
\otext{We can re-use part of the algo for $\beta$ given before}


\section{Unif encoding in real life}
\otext{Il ML presentato qui è esattamente elpi}
\otext{Il OL presentato qui è esattamente coq}
\otext{Come implementatiamo tutto ciò nel solver}

\section{Results: stdpp and tlc}
\otext{How may rule are we solving?}
\otext{Can we do some perf test}

\section{Conclusion}

% \subsection{implementation}

% l'HO encoding e' esattamente lambda Prolog/elpi, il compilatore
% in pratica potrebbe essere scritto in un meta language, qui lo si presenta in
% elpi stesso. HO e FO in questo paper sono deep embedded in elpi per parlarne,
% ma in pratica il nostro solever, prendere XX, scrivere la clausola compilata.


% \section{recovering eta}

% \begin{elpicode}
% q (all x\ F x) = q (all x\ app[f,x]) /\ p f = p F
% F = fun a => app [f,a] ----> F = f
% \end{elpicode}

% l'utene da p su f, mentre l'istanza pe q forza F a fun .. 

% \section{recovering beta}

% \begin{elpicode}
%   q (all x\ F x) = q (all x\ app[f,x,x]) /\ p1 (app[f,a,a]) = p1 (app[F,a])
%   F = fun y => app [f,y,y] ----> (app[F,a]) ~> app[f, a, a].
% \end{elpicode}
  
% qui la sintesi di F puo generare un beta redex, quindi ci mettiamo
% p1 F1, e decomp beta F [a] F1.

% \section{recovering eta-beta within unification (non linear variables)}

% se i problemi di cui sopra avvengono nello stesso termine

% \begin{elpicode}
%   q2 (all x\ F x) (app[F,a]) = q2 (all x\ app[f,x,x]) (app[f,a,a])
% \end{elpicode}

% bisogna slegare le due F e poi unificare le soluzioni tra di loro

% \section{heuristic / binary app}

% fo approx / sub pattern fragment

% \begin{elpicode}
%   p (all x\app[F,x,a]) (app[F,b]) = p (all x\app[f,x,x,a]) (app[f,b,b])
%   p (all x\G x) F' = 
%   G = x\ f x x a
%   F = lam x\f x x
%   F' = (app[f,b,b])
%   link (F a) F'
%   link G F
% \end{elpicode}


% % questo esempio recupera l'app binaria perche

% \begin{elpicode}
%   (app (app F x) a) = (app (f x x) a)
% \end{elpicode}

% \section{Stats}

% Concretamente:

% - quante volte l'ordine superiore è necessario in stdpp/tlc

% \section{Conclusion}

\printbibliography

\end{document}