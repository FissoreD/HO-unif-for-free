\documentclass[sigconf,natbib=false]{acmart}
\usepackage[]{biblatex}

\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}
\addbibresource{bib.bib}

\usepackage{myTools}
\usepackage{macros}

% TODO: set this fields
%\setcopyright{cc}
%\setcctype{by}
\copyrightyear{2024}
\acmYear{XXXX 2024}
\acmBooktitle{YYY}
\acmDOI{ZZZZZZZZZZZZ}    


% \xspaceaddexceptions{]\}}

\def\elpi{\proglang{elpi}}
\def\coqelpi{\proglang{coq-elpi}}
\def\lambdaprolog{\proglang{$\lambda$-prolog}}
\def\coq{\proglang{coq}}

\newcommand{\library}[1]{\textit{#1}\xspace}
\def\stdpp{\library{stdpp}}
\def\iris{\library{iris}}

\newcommand*{\acronym}[1]{\texttt{#1}\xspace}

\def\ol{\acronym{ol}} % object language
\def\ml{\acronym{ml}} % meta language
\def\lf{\acronym{lf}} % logical framework
\def\ho{\acronym{ho}} % higher order
\def\Forall{$\forall$}

\newcommand{\U}{\ensuremath{=_o}}
\newcommand{\Ue}{\ensuremath{=_\lambda}}
\newcommand{\Fo}{\ensuremath{\mathcal{F}_{\!o}}}
\newcommand{\Ho}{\ensuremath{\mathcal{H}_o}}

\newcommand*{\eqtau}{\ensuremath{\mathrel{\overset{\mathrm{\tau}}{=}}}}

\begin{document}

\title{HO unification from object language to meta language} 

\author{Enrico Tassi}
\email{enrico.tassi@inria.fr}
\affiliation{%
  \institution{Université Côte d'Azur, Inria}
  % \city{Nice}
  \country{France}}

\author{Davide Fissore}
\email{davide.fissore@inria.fr}
\affiliation{%
  \institution{Université Côte d'Azur, Inria}
  % \city{Nice}
  \country{France}}

\begin{abstract}
  Specifying and implementing a logic from scratch requires significant effort.
  Logical Frameworks and Higher Order Logic Programming Languages provide
  dedicated, high-level Meta Languages (ML) to facilitate this task in two
  key ways: 1) variable binding and substitution are simplified when ML binders
  represent object logic ones; 2) proof construction, and even proof search, is
  greatly simplified by leveraging the unification procedure provided by the ML.
  Notable examples of ML are Elf~\cite{elf}, Twelf~\cite{twelf},
  $\lambda$Prolog~\cite{miller_nadathur_2012} and
  Isabelle~\cite{10.1007/978-3-540-71067-7_7}
  which have been utilized to implement various formal systems such as
  First Order Logic~\cite{felty88cade},
  Set Theory~\cite{10.1007/BF00881873},
  Higher Order Logic~\cite{books/sp/NipkowPW02}, and even the Calculus of
  Constuctions~\cite{felty93lics}.
  
  The object logic we are interested in is Coq's~\cite{Coq-refman}
  Dependent Type Theory (DTT),
  for which we aim to implement a unification procedure \U{} using the ML
  Elpi~\cite{dunchev15lpar}, a dialect of $\lambda$Prolog.
  Elpi comes equipped with the equational theory \Ue{}, comprising
  $\eta\beta$ equivalence
  and higher order unification restricted to the pattern
  fragment~\cite{miller92jsc}.
  We want \U{} to feature the same equational theory as \Ue{} but on the
  object logic DTT. Elpi also comes with an encoding for DTT that works well
  for meta-programming~\cite{tassi:hal-01637063,tassi:hal-01897468,gregoire:hal-03800154,newtc}.
  Unfortunately this encoding, which we refer to as \Fo{},
  ``underuses'' \Ue{} by restricting it to first-order unification problems only. 
  To address this issue, we propose a better-behaved encoding, \Ho{},
  demonstrate how to map unification problems in \Fo{}
  to related problems in \Ho{}, and illustrate
  how to map back the unifiers found by \Ue{}, effectively implementing
   \U{} on top of \Ue{} for the encoding \Fo{}.
   
  We apply this technique to the implementation of a type-class~\cite{wadler89}
  solver for Coq~\cite{Coq-refman}.
  Type-class solvers are proof search procedures based on
  unification that back-chain designated lemmas, providing essential
  automation to widely used 
  Coq libraries such as Stdpp/Iris~\cite{JUNG_KREBBERS_JOURDAN_BIZJAK_BIRKEDAL_DREYER_2018}
  and TLC~\cite{10.1007/978-3-642-14052-5_15}. These two libraries
  constitute our test bed.
\end{abstract} 

\keywords{Logic Programming, Meta-Programming, Higher-Order Unification, Proof Automation}

\maketitle

\section{Introduction}

Specifying and implementing a logic from scratch requires significant effort.
Logical Frameworks and Higher Order Logic Programming Languages provide
dedicated, high-level Meta Languages (ML) to facilitate this task in two
key ways: 1) variable binding and substitution are simplified when ML binders
represent object logic ones; 2) proof construction, and even proof search, is
greatly simplified by leveraging the unification procedure provided by the ML.
Notable examples of ML are Elf~\cite{elf}, Twelf~\cite{twelf},
$\lambda$Prolog~\cite{miller_nadathur_2012} and
Isabelle~\cite{10.1007/978-3-540-71067-7_7}
which have been utilized to implement various formal systems such as
First Order Logic~\cite{felty88cade},
Set Theory~\cite{10.1007/BF00881873},
Higher Order Logic~\cite{books/sp/NipkowPW02}, and even the Calculus of
Constuctions~\cite{felty93lics}.

The object logic we are interested in is Coq's~\cite{Coq-refman}
Dependent Type Theory (DTT), and we want to code a type-class~\cite{wadler89}
solver for Coq~\cite{Coq-refman} using the Coq-Elpi~\cite{tassi:hal-01637063}
meta programming framework.
Type-class solvers are unification based proof search procedures
that combine a set of designated lemmas in order to providing essential
automation to widely used Coq libraries.

As the running example we take the \coqIn{Decide} type class,
from the Stdpp~\cite{JUNG_KREBBERS_JOURDAN_BIZJAK_BIRKEDAL_DREYER_2018}
library. The class identifies predicates equipped with a decision procedure.
The following three designated lemmas (called \coqIn{Instances} in the
type-class jargon) state that: 1) the type \coqIn{fin n}, of natural numbers
smaller than \coqIn{n} is finite; 2) the predicate \coqIn{nfact n nf},
linking a natural number \coqIn{n} to its prime factors \coqIn{nf}, is decidable;
3) the universal closure of a predicate has a decision procedure if the
predicate has and if its domain is finite.

\begin{coqcode}
Instance fin_fin n : Finite (fin n).
Instance nfact_dec n nf : Decision (nfact n nf).
Instance forall_dec A P : Finite A ~$\to$~ 
  ~$\forall$~x:A, Decision (P x) ~$\to$~ Decision (~$\forall$~x, P x).
\end{coqcode}

\noindent Under this context the type-class solver is able to prove
the the following statement automatically by back-chaining
the three instances.

\begin{coqcode}
  Check _ : Decision (forall y: fin 7, nfact y 3).
\end{coqcode}

\noindent
The encoding of DTT provided by Elpi, that we will discuss at length later in
section~\ref{sec:encodings} and ~\ref{} features the following term constructors:

\begin{elpicode}
kind tm type.
type lam tm -> (tm -> tm) -> tm. % lambda abstraction
type app list tm -> tm.          % n-ary application
type all tm -> (tm -> tm) -> tm. % forall quantifier
type c string -> tm.             % constants
\end{elpicode}

\noindent
\marginpar{TODO: explain HOAS}
Following this term encoding the three instances are represented by the
following rules:

\begin{elpicode}
finite (app[c"fin", N]).
decision (app [c"nfact", N, NF]).
decision (all A x\ app[P, x]) :- finite A,
  pi x\ decision (app[P, x]).
\end{elpicode}

\noindent
\marginpar{TODO: explain pi, cons}
Unfortunately this direct translation of the instances considers the
predicate \coqIn{P} as a first order term. If we try to backchain the
third rule on the encoding of the goal above:
  
\begin{elpicode}
decision (all (app[c"fin", c"7"]) y\
  app[c"nfact", y, c"3"]).
\end{elpicode}

\noindent
we fail because of this ``higher order'' unification problem (in DTT)
is phrased as a first order unification problem in the meta language.

\begin{elpicode}
app[c"nfact", y, c"3"] = app[P, y]
\end{elpicode}

\noindent
In this paper we study a more sophisticated encoding of Coq terms allowing
us to rephrase the problematic rule as follows:

\begin{elpicode}
decision (all A x\ Pm x) :- link Pm A P, finite A,
  pi x\ decision (app[P, x]).
\end{elpicode}

\noindent
This time \elpiIn{Pm} is an higher order unification variable (of type
\elpiIn{tm -> tm}). The resulting unification problem is now:

\begin{elpicode}
app[c"nfact", y, c"3"] = Pm y
\end{elpicode}

\noindent
That admits one solution:

\begin{elpicode}
Pm = y\ app[c"nfact", y, c"3"]
A = app[c"fin",c"7"]
\end{elpicode}
  
\noindent
Elpi succeeds in the application of the new rule and then runs
the premise \elpiIn{link Pm A P} that is in charge of bringing the
assignment back to the domain of Coq terms (the type \elpiIn{tm}):

\begin{elpicode}
P = lam A a\ app[c"nfact", a, c"3"]
\end{elpicode}

\noindent
This simple example is sufficient to show that the encoding we seek
is not trivial. Indeed the solution for \elpiIn{P} generates a
(Coq) $\beta$-redex in the second premise (under the \elpiIn{pi x}):

\begin{elpicode}
decision (app[lam A (a\ app[c"nfact", a, c"3"]), x])
\end{elpicode}

\noindent
In turn the redex prevents the second rule to backchain properly since
the following unification problem has no solution:

\begin{elpicode}
app[lam A (a\ app[c"nfact", a, c"3"]), x] =
app[c"nfact", N, NF]
\end{elpicode}

\noindent
This time the root cause is that the unification procedure of \Ue{} of the
meta language is not aware of the equational theory of the object logic \U{},
even if both theories include $\eta\beta$-conversion and admit most general
unifiers for problems in the pattern fragment~\cite{miller92jsc}.

In this paper we discuss alternative encodings of Coq in
Elpi~\ref{sec:encodings}, then we identify a minimal language \Fo{}
in which the problems sketched here can be fully described.
We then detail an encoding \elpiIn{comp} from \Fo{} to \Ho{} (the language of
the meta language) and a decoding \elpiIn{decomp} to relate the unifiers
bla bla..

\section{Alternative encodings} %%%%%%%%%%%%%%%%%%%%%%
\label{sec:encodings}

Our choice of encoding of DTT may look weird to the reader familiar with
LF, since used a shallow encoding of classes and binders, but not of the
``lambda calculus'' part of DTT. Here a more lightweight encoding
that unfortunately does not fit our use case

\begin{elpicode}
finite (fin N).
decision (nfact N NF).
decision (all A x\ P x) :- 
  (pi x\ decision (P x)), finite A.
\end{elpicode}

but in DTT this is not always possible and not handy in our use case,
since the arity of constants is not fixed.

\begin{coqcode}
Fixpoint narr T n := 
  if n is S m then T -> narr T m else T.
Definition nsum n : narr nat (n+1).
Check nsum 2   8 9 : nat.
Check nsum 3 7 8 9 : nat.
\end{coqcode}
  
moreover we use the same encoding for meta programming, or even just to provide
hand written rules. We want to access the syntax of OL, so our embedding cannot
be that shallow. We want to keep it shallow for the binders, but we need
the c, app and lam nodes. % all ?

Another alternative

\begin{elpicode}
decision X :- unif X (all A x\ app[P, x]), 
  (pi x\ decision (app[P, x])), finite A.
\end{elpicode}

gives up all half of what the ML gives us. Moreover even if unif here embodies
the eq theory of DTT which is much stronger than the one of the ML, we don't need 
it. According to our experience eta beta suffice, but HO is needed.



Note that this~\cite{felty93lics} is related and make the
discrepancy between the types of ML and DTT visible. In this case
one needs 4 application nodes. Moreover the objective is an encoding
of terms, proofs, not proof search. Also note the conv predicate,
akin to the unif we rule out.

This other paper~\cite{10.1007/978-3-031-38499-8_25} should also be cited.

\section{Lanuages description}

\input{lang_descr.tex}

% Description of languages (OL and ML)

\def\eqfo{eq\_fo\xspace}

In order to reason about unification of the terms of an objet language within a
meta language, we start by formally describing the two languages. We use
meta-programming to accomplish this result. In \cref{code:lang-descr}, we
provide on the left the typing structure of the terms of the object language
together with the signature of the \eqfo function.

In this encoding, the fo\_tm type stands for the first order representation of
the object language terms. We model unification variables as integers
corresponding to memory addresses. This memory is represented with the subst
type abbreviation which is list of optional terms. If the cell $i$ is none, then
the variable $i$ is not assigned. 

% Why the fo prefix for fo_tm && Uvar in OL have no scope
Because of our translation of the terms of the object language into the meta
language we have sketched in section one, a object language term has no scope.
An example of this claim can be given by analyzing deeply the subterm \coqIn{P x} from
the instance forall\_dec. \coqIn{P} is an higher order variables
with type \coqIn{A ~$\to$~ Prop} and
\coqIn{x} is a name bound to \coqIn{P}.
However, at the meta level, the translation of \coqIn{P x} become \elpiIn{app[uv
1, x]}, that is, \elpiIn{uv 1} cannot see \elpiIn{x}.

Since our goal is to work with higher order variables, we need to compile the
term received in entry into a more expressive version. This is possible by using
a second type structure for the terms of the OL. This term definition is given
in the second column of the \cref{code:lang-descr}. The main different here is
that a unification variable (always identified with by an integer) has now a
list of terms representing the scope of the variable. We symbolize the
abstractions of the ML using the constructor \elpiIn{abs} of the type
\elpiIn{assmt}. The constructor \elpiIn{val} is is used to contain terms of the
object language. In this context we do not need to have an application node for
the ML. 

\def\eqfo{equal\_fo\xspace}
\def\eqho{equal\_ho\xspace}
\def\etabeta{$\eta\beta$\xspace}

% We have two different equal functions
The equality relation over terms under a given substitution mapping is possible 
thanks to the equal predicate. There exist
two version of this predicate: \eqfo and \eqho. Their implementation is given in
\cref{code:term-equal}. 

The first tests if two terms are equal in the object language, that is, given a
substitution $\theta$, is it true that the two terms are equal? Note that no
variable instantiation is done: unification is not performed by the
\elpiIn{equal} predicate. Therefore, a unification variable $i$ equals to
another term $t$ if $t$ is a variable with same index $i$, or if $i$ is assigned
to $t'$ in $\theta$ and \elpiIn{equal ~$t'$~ ~$t$~}. Moreover, since \eqfo 
represents the equality of the OL, and since the OL accept term equality up to
\etabeta, then \eqfo also quotient over these reductions.

The \eqho predicate tests if two terms are equal in the world of the meta
languages. This equality function is not capable to understand the \etabeta
reductions over terms of the object language. The ML sees a term of the type
\elpiIn{tm} as atom on which only structural equality can be performed. It is
only possible to dereference a variable if assigned.

\subsection[Compilation: fo\_tm to tm]{Compilation: \elpiIn{fo_tm} $\to$ \elpiIn{tm}}

- how we transform an fo\_tm in tm
- the role of links

\subsection{Unification in ML}

\subsection{Term de-compilation}
% Compile FO to HO

% Assignement in HO should be decompiled




-------------------------------------------------------------------




le due sintassi, XX tradotto, unif passa, bisogna riportare la soluzione
nel mondo fo

this should hold in both encoding
%abella
\begin{elpicode}
forall t1 t2 s, unif t1 t2 nil s -> equal s t1 t2
\end{elpicode}
we have unif only in the HO one, where equal is
weaker (but unif is stronger)

segnatura di decomp e unif, equalfo (fa beta, eta, deref)

\noindent

equal fo is congruence, deref, beta, eta (for the OL).
equal ho is congruence, deref (for the OL).
unif (fo or ho) should cover pattern fragment, i.e. well behaved unif.

ho, and unif ho, is the LF/ML language/unif. here we describe fo and ho
with a deeply embedded syntax, but the idea is that uv can be mapped to
an actual unif variable.

of course we could write a unif for the ho that had beta and eta,
but if we use the one of the LF it can't have eta beta of the OL baked in.

\subsection{implementation}

l'HO encoding e' esattamente lambda Prolog/elpi, il compilatore
in pratica potrebbe essere scritto in un meta language, qui lo si presenta in
elpi stesso. HO e FO in questo paper sono deep embedded in elpi per parlarne,
ma in pratica il nostro solever, prendere XX, scrivere la clausola compilata.

\begin{elpicode}
prove (app[c "decidable", all x\ P x]) Proof :- ho-link P P', prove (... P' ...).
\end{elpicode}

qui P nel paper diventa uv N [x] per un certo N.

\section{recovering HO}

\begin{elpicode}
  :index (1)
  p (all x\ app[F,x]).
\end{elpicode}

fallisce perche le liste non hanno la stessa lunghezza.


compile

\begin{elpicode}
  p (all x\ F' x) = p (all x\ app[f,x,x]) , link F F'.
  F' = x\ app[f,x,x]
  F = lam a\ app[f,a,a].
\end{elpicode}

\begin{elpicode}
  type comp fo.tm -> ho.tm -> list link -> list link -> ho.subst -> ho.subst -> o.
  comp (fo.c X)   (ho.c X) L L S S.
  comp (fo.app [fo.uv N|Argsss]) TT L L3 S S3 :- %!,
    % TODO: here split-pf to enter dist. names into N
    % split-pf Argsss [] PF NPF,
    split-pf Argsss [] PF [], NPF = [], % TODO: compile to (uv N L) + link-fo-app
    print "In PF" PF NPF, 
    if (NPF = []) (TT = ho.uv M PF1) (TT = ho.app [ho.uv M PF1 | NPF1]),
    % pattern-fragment Args,
    fold4 comp PF PF1 L L1 S S1,
    fold4 comp NPF NPF1 L1 L2 S1 S2,
    ho.new S2 M S3,
    % TODO: maybe len can be given by split-pf
    len PF Len,
    L3 = [link N M Len| L2].
  % TODO: if don't want to modify unif, we compile `fo.app [fo.c f, c0, c0, ho.c a]` into 
  % `ho.app [ho.app[f, c0, c0], ho.c a]
  comp (fo.app A) (ho.app A1) L L1 S S1 :- fold4 comp A A1 L L1 S S1.
  comp (fo.lam F) (ho.lam F1) L L1 S S1 :- 
    (pi x y\ (pi A S\ comp x y A A S S) => comp (F x) (F1 y) L L1 S S1).
  comp (fo.uv N) (ho.uv M []) L [link N M z|L] S S1 :- ho.new S M S1.

  decmop...
\end{elpicode}


\section{recovering eta}

\begin{elpicode}
q (all x\ F x) = q (all x\ app[f,x]) /\ p f = p F
F = fun a => app [f,a] ----> F = f
\end{elpicode}

l'utene da p su f, mentre l'istanza pe q forza F a fun .. 

\section{recovering beta}

\begin{elpicode}
  q (all x\ F x) = q (all x\ app[f,x,x]) /\ p1 (app[f,a,a]) = p1 (app[F,a])
  F = fun y => app [f,y,y] ----> (app[F,a]) ~> app[f, a, a].
\end{elpicode}
  
qui la sintesi di F puo generare un beta redex, quindi ci mettiamo
p1 F1, e decomp beta F [a] F1.

\section{recovering eta-beta within unification (non linear variables)}

se i problemi di cui sopra avvengono nello stesso termine

\begin{elpicode}
  q2 (all x\ F x) (app[F,a]) = q2 (all x\ app[f,x,x]) (app[f,a,a])
\end{elpicode}

bisogna slegare le due F e poi unificare le soluzioni tra di loro

\section{heuristic / binary app}

fo approx / sub pattern fragment

\begin{elpicode}
  p (all x\app[F,x,a]) (app[F,b]) = p (all x\app[f,x,x,a]) (app[f,b,b])
  p (all x\G x) F' = 
  G = x\ f x x a
  F = lam x\f x x
  F' = (app[f,b,b])
  link (F a) F'
  link G F
\end{elpicode}


% questo esempio recupera l'app binaria perche

\begin{elpicode}
  (app (app F x) a) = (app (f x x) a)
\end{elpicode}

\printbibliography

\end{document}