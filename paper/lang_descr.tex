\setlength{\abovecaptionskip}{0pt plus 3pt minus 2pt}
% \begin{figure*}
%   \begin{minipage}{.40\textwidth}

%     \begin{elpicode}
%       # Common code
%       kind tm type.
%       type app list tm -> tm.
%       type lam (tm -> tm) -> tm.
%       type c string -> tm.
%     \end{elpicode}
    
%   \end{minipage}

%   \vspace{3pt}

%   \begin{tabular}{lr}
%     \begin{minipage}{.40\textwidth}

%       \begin{elpicode}
%         # OL code
%         type fo_uv  nat -> tm.
%         typeabbrev fo_subst list (option tm).
%       \end{elpicode}
%     \end{minipage}
%     &
%     \begin{minipage}{.40\textwidth}
      
%       \begin{elpicode}
%         # ML code
%         type uv  nat -> list tm -> tm.
%         typeabbrev subst list (option assmt).
%       \end{elpicode}
%     \end{minipage}
%   \end{tabular}
  
%   \caption{Language description}
%   \label{code:lang-descr}
%   \Description[lang-spec]{Language description}
% \end{figure*}

% The two equals: equal of OL and ML
% In ML we don't have eta beta -> only unification is allowed on variables


\begin{figure*}
  \begin{tabular}{cc}
    \begin{minipage}{.50\textwidth}
      \begin{elpicode}
        type fo_equal subst -> tm -> tm -> o.
        % deref
        fo_equal S (fo_uv N) T1 :- assigned? N S T, fo_equal S T T1.
        fo_equal S T1 (fo_uv N) :- assigned? N S T, fo_equal S T1 T.
        % congruence
        fo_equal S (app L1) (app L2) :- forall2 (fo_equal S) L1 L2.
        fo_equal S (lam F1) (lam F2) :- 
          pi x\ fo_equal S x x => fo_equal S (F1 x) (F2 x).
        fo_equal _ (c X) (c X).
        fo_equal _ (fo_uv N) (fo_uv N).
      \end{elpicode}
    \end{minipage}
    &
    \begin{minipage}{.50\textwidth}
      \begin{elpicode}

        % eta
        fo_equal S (lam F) T :- not (T = lam _), 
          pi x\ beta T [x] (T' x), fo_equal S (lam F) (lam T').
        fo_equal S T (lam F) :- not (T = lam _), 
          pi x\ beta T [x] (T' x), fo_equal S (lam T') (lam F).
        % beta
        fo_equal S (app [uv N|Args]) T1 :- 
          assigned? N S F, beta F Args T, fo_equal S T T1.
        fo_equal S T1 (app [uv N|Args]) :- 
          assigned? N S F, beta F Args T, fo_equal S T1 T.
        fo_equal S (app [lam X | TL]) T :- beta (lam X) TL T', fo_equal S T' T.
        fo_equal S T (app [lam X | TL]) :- beta (lam X) TL T', fo_equal S T T'.
      \end{elpicode}
    \end{minipage}
  \end{tabular}
  \caption{Term equality}
  \label{code:term-equal}
  \Description[term-equal]{Term equality}
\end{figure*}

% \begin{figure*}
%   \begin{tabular}{c}
%     \begin{minipage}{.80\textwidth}
%       \begin{elpicode}
%         % beta
%         equal S (app [uv N|A]) T1 :- assigned? N S F, beta F A T, equal S T T1.
%         equal S T1 (app [uv N|A]) :- assigned? N S F, beta F A T, equal S T1 T.
%         equal S (app [lam X | TL]) T :- beta (lam X) TL T', equal S T' T.
%         equal S T (app [lam X | TL]) :- beta (lam X) TL T', equal S T T'.
%         % eta
%         equal S (lam F) T :- not (T = lam _),
%           pi x\ beta T [x] (T' x), equal S (lam F) (lam T').
%         equal S T (lam F) :- not (T = lam _),
%           pi x\ beta T [x] (T' x), equal S (lam T') (lam F).
%       \end{elpicode}
%     \end{minipage}
%   \end{tabular}
%   \caption{$\eta\beta$ in the OL}
%   \label{code:eta-beta}
%   \Description[Eta-beta-OL]{Eta-beta in OL}
% \end{figure*}