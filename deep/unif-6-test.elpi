macro @X :- fo.fuva (addr z).
macro @Y :- fo.fuva (addr (s z)).
macro @Z :- fo.fuva (addr (s (s z))).
macro @W :- fo.fuva (addr (s (s (s z)))).
macro @f :- fo.fcon "f".
macro @g :- fo.fcon "g".
macro @h :- fo.fcon "h".
macro @a :- fo.fcon "a".
macro @b :- fo.fcon "b".
macro @c :- fo.fcon "c".
macro @app L :- fo.fapp L.
macro @lam L :- fo.flam L.

shorten fo.{(==o)}.

macro @read :- input_line std_in _.

type compile-terms 
  list (triple diagnostic fo.fm fo.fm) -> 
  list (triple diagnostic ho.tm ho.tm) -> 
  comp.mappings ->
  comp.mappings ->
  comp.links ->
  ho.subst -> ho.subst ->
  o.
compile-terms [] [] M M [] H H.
compile-terms [triple D S1 S2|Src] [triple D T1 T2|PS] Map0 MapS LS H0 H3 :-
  std.assert! (comp.comp S1 T1 Map0 Map1 [] L1 H0 H1) "comp s1",
  std.assert! (comp.comp S2 T2 Map1 Map2 L1 L2 H1 H2) "comp s2",
  compile-terms Src PS Map2 MapS Links2 H2 H3,
  std.append L2 Links2 LS.

type prolog 
  list (triple diagnostic ho.tm ho.tm) -> 
  comp.links -> comp.links ->
  ho.subst -> ho.subst ->
  diagnostic ->
  o.
prolog [] L L H H ok :- print "end proggram\n".
prolog [triple ok L R|Us] Links Links2 H H3 D :- std.do! [
  print "## prolog unif step" {ho.pp {ho.deref H L}} "=" {ho.pp {ho.deref H R}},
  ho.unif L R H H1,
  print "## After unif subst is" {ho.ppsubst H1},
  print "## Links are" {comp.pplinks Links},
  printC "solve links?",
  comp.solve-links-fixpoint Links Links1 H1 H2,
  print "## After solve links, links are" {comp.pplinks Links1},
  print "## After solve links, subst is" {ho.ppsubst H2},
  ],
  !,
  printC "next problem?",
  prolog Us Links1 Links2 H2 H3 D.
prolog [_|_] L L H H (error "xx").
prolog [triple (error "unif") L R|_] Links Links H H1 (error "stop") :-
  print "## unif (error)" L "=" R,
  if (ho.unif L R H H1)
     (print "## After unif" L "=" R "subst is" {ho.ppsubst H1},
      print "## Links are" {comp.pplinks Links},
      printC "solve links?",
      not(comp.solve-links-fixpoint Links _ H1 _))
     (H1 = H).

type decompile-subst
  comp.mappings -> 
  comp.links -> 
  ho.subst ->
  fo.subst ->
  fo.subst ->
  o.
decompile-subst Mappings Links H F F1 :-
  comp.decompl Mappings Links H F F1.

% @okl 22300 [
%   triple ok (@app[@g, (@lam x\ @lam y\ @app[@Y, y, x])]) @X,
%   % triple ok (@app[@g, @f]) @X,
% ].

type is-nf fo.fm -> o.
is-nf (fo.fcon _).
is-nf (fo.fuva _).
is-nf (fo.fapp [fo.flam _ | _]) :-
  halt "There is a beta expansion in the input".
is-nf (fo.fapp L) :- std.forall L is-nf.
is-nf (fo.flam B) :- 
  pi x\ sigma L\ fo.fapp L = B x, std.appendR _ [x] L, 
  halt "There is an eta exapansion in the input".
is-nf (fo.flam B) :- pi x\ is-nf x => is-nf (B x).

type is-nf-goal list (triple diagnostic fo.fm fo.fm) -> o.
is-nf-goal [].
is-nf-goal [triple _ A B | TL] :-
  is-nf A, is-nf B, is-nf-goal TL.

type build-fo-subst list (triple diagnostic fo.fm fo.fm) -> fo.subst -> fo.subst -> o.
build-fo-subst [] L L.
build-fo-subst [triple _ L R | TL] A D :-
  fo.extend-subst L A B, fo.extend-subst R B C,
  build-fo-subst TL C D.

type validate-solution 
  list (triple diagnostic fo.fm fo.fm) ->
  fo.subst ->
  o.
validate-solution [] _.
validate-solution [triple ok L R|Goals] FS :- 
  std.do![fo.deref FS L L', fo.deref FS R R',
  %  (L' ==o R'),
  std.assert! (L' ==o R') "Invalid solution",
  validate-solution Goals FS].
validate-solution [triple (error _) _ _|_] _.

% (x\y\Y y x) = Z, g Z = X.
% X = g c0 \ c1 \ Y c1 c0
% Z = c0 \ c1 \ Y c1 c0
% @okl 22001 [
%   triple ok (@lam x\ @lam y\ @app[@X, y, x]) @Y,
%   triple ok (@app[@g, @Y]) @Z,
% ].

type same-sols list (option fo.fm) -> list (option fo.fm) -> o.
same-sols [] [].
same-sols [A|L] [A|M] :- !, same-sols L M.
same-sols [] L :- std.assert! (forall1 ((=) none) L) "Invalid solution".
same-sols L [] :- std.assert! (forall1 ((=) none) L) "Invalid solution".
same-sols A B :- halt "INVALID SOL" {fo.ppsubst A} " =/= " {fo.ppsubst B}.


type check-sol option (list fo.fm) -> fo.subst -> o.
check-sol none _. 
check-sol (some Sol) L :-
  std.map Sol (x\r\ if (var x) (r = none) (r = some x)) L1,
  same-sols L L1. 

type do-read o.
:if "DEBUG"
do-read.

type printC string -> o.
printC A :- X = "@@@@@@@@@@@@@@@@@@@@@@@@@", print X A X, (not do-read; @read).

type ptest test fo.fm -> string -> o.
ptest (test _ (pr Pbs (some Sol))) S :-
  std.map Pbs pppbs S1,
  fo.ppsubst {std.map Sol (x\r\ r = some x)} S2,
  S is {std.string.concat "; " S1} ^ "\n==> " ^ {std.string.concat "; " S2}.
ptest (test _ (pr Pbs none)) S :-
  std.map Pbs pppbs S1,
  S is {std.string.concat "\n" S1} ^ "\n==> _".


type pppbs triple diagnostic fo.fm fo.fm -> string -> o.
pppbs (triple ok A B) S :- S is {fo.pp A} ^ " == " ^ {fo.pp B}.
pppbs (triple (error _) A B) S :- S is {fo.pp A} ^ " =/= " ^ {fo.pp B}.

type pppbsc triple diagnostic ho.tm ho.tm -> string -> o.
pppbsc (triple ok A B) S :- S is {ho.pp A} ^ " == " ^ {ho.pp B}.
pppbsc (triple (error _) A B) S :- S is {ho.pp A} ^ " =/= " ^ {ho.pp B}.

type xtest test fo.fm -> o.
xtest (test N (pr LR Sol) as Test) :- std.do![
  print "## Test" N ":" {ptest Test},
  printC "run test?",
  build-fo-subst LR [] FO_Subst,
  compile-terms LR Uproblems [] Map1 Links [] HO_Subst,
  comp.post-comp Map1 Map2 HO_Subst HO_Subst1 Links Links2,                % TODO: refactor compile-terms so that it also does post processing 
  print "## After compilation the terms are" {std.map Uproblems pppbsc},
  print "## After compilation the links are" {comp.pplinks Links2},
  print "## After compilation the mappings are" {comp.ppmappings Map2},
  printC "continue to prolog?",
  prolog Uproblems Links2 Links1 HO_Subst1 HO_Subst2 D,
  if (D = ok) (
    print "## After prolog HO subst is" {ho.ppsubst HO_Subst2},
    print "## After prolog links are" {comp.pplinks Links1},
    print "## After prolog mappings are" {comp.ppmappings Map2},
    printC "continue to decomp?",
    decompile-subst Map2 Links1 HO_Subst2 FO_Subst Sol1,
    print "## After decomp FO subst is" {fo.ppsubst Sol1},
    printC "continue to validate solution?",
    validate-solution LR Sol1,
    printC "continue to check solution vs expected?",
    check-sol Sol Sol1
  ) (print "Prolog failed at the expected step"),

].

macro @ok N X Y S :- declare-test xtest ptest (test N (pr [triple ok X Y] (some S))).
macro @ko N X Y :- declare-test xtest ptest (test N (pr [triple ok X Y] none)).

macro @okl N X :- declare-test xtest ptest (test N (pr X none)).
macro @okl1 N X S:- declare-test xtest ptest (test N (pr X (some S))).
macro @kol N X :- declare-test xtest ptest (test N (pr X none)).

@ok 1 (@app [@f, @X]) (@app [@f, @a]) [@a].
% @ok 2 (@app [@X, @a]) (@app [@f, @a]) [@f].                                           % here two solutions for X: fun _ => a, fun x => x
% @ok 3 (@lam x\ @app [@X, x, @a]) (@lam x\ @app [@f, x, @a]) [@f].

@ko 4 (@app [@f, @X]) @X.
@ko 5 (@app [@f, @X, @X]) (@app [@f, @a, @b]).
@ok 6 (@app [@f, @X, @Y, @X]) (@app [@f, (@app [@f, @Y]), @b, (@app [@f, @b])]) [@app [@f, @b], @b].
@ok 7 (@lam x\ (@app [@f, @X])) (@lam x\ (@app [@f, @a])) [@a].

@ok 8 (@lam x\ @lam y\ @app [@X, x, y]) (@lam x\ @lam y\ @app [@X, x, y]) [].

@ok 9  (@lam x\ @lam y\ @app [@X, x, y]) (@lam x\ @lam y\ @app [@f, y]) [@lam x\ @f].
@ok 90  (@lam x\ @lam y\ @app [@X, y, x]) (@lam x\ @f) [@lam c0 \ @lam c1 \ @app [@f, c0]].
@ok 10 @X (@lam x\ @lam y\ @app [@X, y, x]) [@lam x\ @lam y\ Y].
@okl 100 [
  triple ok (@lam x\ @lam y\ @app [@f, y, x]) (@lam x\ @lam y\ @app [@X, y, x]),
 ].
@okl1 1000 [
  triple ok (@lam x\ @lam y\ @app [@f, @app[@Y, y], @app[@Z, x, y]]) (@lam x\ @lam y\ @app [@X, y, x]),
  triple ok @Z (@lam x\ @lam y\ y),
  triple ok @Y (@lam x\ @a),
  triple ok (@lam x\ @app [@f, @a]) (@lam x\ @lam y\ @app [@X, y, x]),
 ] [(@lam x\ @lam y\ @app[@f, @a, x]), (@lam _\ @a), @lam x\ @lam y\ y].
@okl 10000 [
  triple ok (@lam x\ @lam y\ @app [@f, @app[@Y, x], @app[@Z, x, y]]) (@lam x\ @lam y\ @app [@X, y, x]),
 ].

% @ok 11 (@lam x\ @app [@X, x]) (@lam x\ @app [@f, x, x, @a]) [@lam x\ @app [@f, x, x, @a]].
% @ok 12 (@lam x\ @app [@X, x, @a]) (@lam x\ @app [@f, x, x, @a]) [@lam x\ @app [@f, x, x]].                 % here two solutions for X: fun x _ => f x x a, fun x y => f x x y

@okl 13 [
  (triple ok (@lam x\ @app [@X, x]) (@lam x\ @app [@f, x])), 
  (triple ok @f @X)].

@okl1 131 [
   (triple ok (@lam x\ @app [@X, x]) @f), % ci costringe a bucare il lambda, ci puo' essere una eta 
   (triple ok @f @X)]
   [@f]
   .

@okl1 132 [
  (triple ok (@lam x\ @app [@X, x]) (@lam x\ @app[@f, x, x])),  % visto che buchiamo a sx, la link deve usare il PF sotto il lambda
  (triple ok @X (@lam y\@app[@f,y,y]))]
  [(@lam y\@app[@f,y,y])]
  .

@okl 15 [
  (triple ok @X (@lam x\ @app [@f, @app[@Y,x]])), 
  (triple (error "unif") @g @X)]. % we fail early for the wrong reason

@okl 16 [
(triple ok (@X) (@lam x\ @app [@f, @app[@Y,x]])), 
(triple ok @f @X)
].
@okl 160 [
  (triple ok (@X) (@lam x\ @app [@f, @app[@Y,x]])), 
  (triple ok (@Y) (@lam x\ x)), 
].
@okl 1600 [
  (triple ok (@f) (@lam x\ @app [@f, @app[@X,x]])), 
  % (triple ok (@app [@f, @a]) (@app [@f, @app[@X,@a]])),
  (triple ok (@app [@f, @lam x\x]) (@app [@f, @X])),
].

@okl 17 [
  (triple ok @X (@lam x\ x)),
  % (triple ok (@app [@X, @a]) (@a)),
  (triple ok (@app [@X, @a]) (@Y))
]. % beta redex

% @okl 18 [
%   (triple ok (@lam x\ @app[@X, x, @a]) (@lam x\ @app[@f, x, @a]))
% ].                                                                               % here two solutions for X: fun x _ => f x a, fun x y => f x y

% @okl 19 [
%   (triple ok (@lam x\ @app[@X, x, @a]) (@lam x\ @app[@f, @a]))
% ].                                                                               % here two solutions for X: fun _ _ => f a, fun _ x => f x

% @okl 20 [
%   (triple (error "comp1") (@lam x\ @app[@X, x, x, @a]) (@lam x\ @app[@f, x, @a]))
% ]. % we are not in PF, X have two solutions: fun x _ => f x | fun _ x => f x

@okl 21 [
  (triple ok (@lam x\ @lam y\ @app[@f, y, @a]) (@lam x\ @lam y\ @app[@X, x, y]))
].

% BUG: first decomp the eta, and then the normal links,
% or force the ta links when used in the normal links
@okl1 288 [
  triple ok (@lam x\ @lam y\ @app[@X, y, x]) @Y
] [_, @lam x\ @lam y\ @app[@X, y, x]].

% @okl 22001 [
%   triple ok (@lam x\ @lam y\ @app[@Y, y, x]) @Z,
%   triple ok (@app[@g, @Z]) @X,
%   % triple ok (@app[@g, @f]) @X,
% ].
@okl 22000 [
  triple ok (@app[@g, (@lam x\ @lam y\ @app[@Y, y, x])]) @X,
  triple ok (@app[@g, @f]) @X,
].
@okl 2200 [
  triple ok (@lam x\ @lam y\ @app[@Y, y, x]) @X,
  triple ok (@f) @X,
].
@okl 220 [
  triple ok (@lam x\ @lam y\ @app[@Y, y, x]) @X,
  triple ok (@lam x\             @f) @X,
].
@okl 22 [
  triple ok (             @f) @X,
  triple ok ( @lam y\ @app[@Y, y]) @X,
].

@okl 23 [
  triple ok (@lam x\ @app[@f, @app[@X, x]]) @Y,
  triple ok @X (@lam x\ x),
].

@okl 24 [
  triple ok (@lam x\ x) @X,
  triple ok @Y (@lam x\ @app[@f, @app[@X, x]]),
].

@okl 25 [
  triple ok (@lam x\ @app[@f, @app[@X, x]]) @Y,
  triple ok @X (@lam x\ x),
  triple ok @Y @f
].

/*
  C = lam xy.y
  B = lam x.x
  A = lam xy. A (B x) (C x y)
*/

@okl1 26 [
  triple ok (@lam x\ @lam y\ @app [@f, @app [@X, x], @app [@Y, x, y]]) @f
] [(@lam x\x), (@lam x\@lam y\y)].

/*
  (x\y\ f (A x) (B x y)) = f.
*/