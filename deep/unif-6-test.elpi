macro @X :- try6.fo.fuva z.
macro @Y :- try6.fo.fuva (s z).
macro @Z :- try6.fo.fuva (s (s z)).
macro @f :- try6.fo.fcon "f".
macro @g :- try6.fo.fcon "g".
macro @h :- try6.fo.fcon "h".
macro @a :- try6.fo.fcon "a".
macro @b :- try6.fo.fcon "b".
macro @c :- try6.fo.fcon "c".
macro @app L :- try6.fo.fapp L.
macro @lam L :- try6.fo.flam L.

shorten try6.fo.{(==o)}.

type eval-unif 
  list (triple diagnostic try6.fo.fm try6.fo.fm) -> 
  try6.ho.subst -> try6.ho.subst ->
  list try6.comp.link ->
  list try6.comp.link ->
  try6.fo.subst -> try6.fo.subst -> o.
eval-unif [] S S L L FO FO.

eval-unif [triple (error "comp1") L _ | _] HO_Subs1 _ L0 _ _ _ :- std.do![
  not (try6.comp.comp L _ L0 _ HO_Subs1 _)
].

eval-unif [triple (error "unif") L R | _] HO_Subs1 HO_Subs3 L0 L3 FOSol FOSol :- std.do![
  std.assert! (try6.comp.comp L LH L0 L1 HO_Subs1 HO_Subs2) "b1",
  std.assert! (try6.comp.comp R RH L1 L2 HO_Subs2 HO_Subs3) "b2",
  print "# comp Left:" LH,
  print "# comp Right:" RH,

  std.spy(try6.comp.solve-link L2 L3 HO_Subs3 HO_Subs4),
  print "## unif" LH "with" RH "in" HO_Subs4,
  not(std.spy(try6.ho.unif LH RH HO_Subs4 HO_Subs4_)),
].

eval-unif [triple ok L R | TL] HO_Subs1 HO_SubsNN L0 L4 FOSol FOSol2 :- std.spy-do![

  std.assert! (try6.comp.comp L LH L0 L1 HO_Subs1 HO_Subs2) "b1",
  std.assert! (try6.comp.comp R RH L1 L2 HO_Subs2 HO_Subs3) "b2",
  print "# comp Left:" LH,
  print "# comp Right:" RH,

  print "## unif" LH "with" RH "in" HO_Subs3,
  std.spy(try6.ho.unif LH RH HO_Subs3 HO_Subs4),
  
  std.spy(try6.comp.solve-link L2 L3 HO_Subs4 HO_Subs5),

  % std.spy(try6.comp.decompl L3 L3 HO_Subs5 FOSol FOSol1),

  % print "FO Subst" L "==" R ":=" FOSol,

  eval-unif TL HO_Subs5 HO_SubsNN L3 L4 FOSol FOSol2,
].

type is-nf try6.fo.fm -> o.
is-nf (try6.fo.fcon _).
is-nf (try6.fo.fuva _).
is-nf (try6.fo.fapp [try6.fo.flam _ | _]) :-
  halt "There is a beta expansion in the input".
is-nf (try6.fo.fapp L) :- std.forall L is-nf.
is-nf (try6.fo.flam B) :- 
  pi x\ sigma L\ try6.fo.fapp L = B x, std.appendR _ [x] L, 
  halt "There is an eta exapansion in the input".
is-nf (try6.fo.flam B) :- pi x\ is-nf x => is-nf (B x).

type is-nf-goal list (triple diagnostic try6.fo.fm try6.fo.fm) -> o.
is-nf-goal [].
is-nf-goal [triple _ A B | TL] :-
  is-nf A, is-nf B, is-nf-goal TL.

type build-fo-subst list (triple diagnostic try6.fo.fm try6.fo.fm) -> try6.fo.subst -> try6.fo.subst -> o.
build-fo-subst [] L L.
build-fo-subst [triple _ L R | TL] A D :-
  try6.fo.extend-subst L A B, try6.fo.extend-subst R B C,
  build-fo-subst TL C D.

type validate-solution 
  list (triple diagnostic try6.fo.fm try6.fo.fm) -> int ->
  list try6.comp.link ->
  try6.ho.subst ->
  try6.fo.subst ->
  try6.fo.subst -> o.
validate-solution Goals N Links HS FS FS' :- 
  forall1 (x\ x = triple ok _ _) Goals, !,
  try6.comp.decompl Links Links HS FS FS',
  print "The solution for" N "is" FS', 
  forall1 (x\ sigma L R L' R'\ triple _ L R = x,
    try6.fo.deref FS' L L', try6.fo.deref FS' R R',
    L' ==o R') Goals.
validate-solution _ _ _ _ _ _.

type same-sols list (option A) -> list (option A) -> o.
same-sols [] [].
same-sols [A|L] [A|M] :- !, same-sols L M.
same-sols [] L :- std.assert! (forall1 ((=) none) L) "Invalid solution".
same-sols L [] :- std.assert! (forall1 ((=) none) L) "Invalid solution".
same-sols A B :- halt "Invalid sol" A B.


type check-sol option (list try6.fo.fm) -> try6.fo.subst -> o.
check-sol none _. 
check-sol (some Sol) L :-
  std.map Sol (x\r\ if (var x) (r = none) (r = some x)) L1,
  same-sols L L1. 

type xtest test try6.fo.fm -> o.
xtest (test N (pr LR Sol) tt) :- std.do![
  build-fo-subst LR [] FO_Subst,
  eval-unif LR [] HO_Subst [] Links FO_Subst FO_Subst',
  validate-solution LR N {std.rev Links} HO_Subst FO_Subst' Sol1,
  check-sol Sol Sol1
].
xtest (test _ (pr LR _) ff) :- std.do! [
  build-fo-subst LR [] FO_Subst,
  not(eval-unif LR [] _S [] _L FO_Subst _FO)
].

macro @ok N X Y S :- declare-test xtest (test N (pr [triple ok X Y] (some S)) tt).
macro @ko N X Y :- declare-test xtest (test N (pr [triple ok X Y] none) ff).

macro @okl N X :- declare-test xtest (test N (pr X none) tt).
macro @kol N X :- declare-test xtest (test N (pr X none) ff).

@ok 1 (@app [@f, @X]) (@app [@f, @a]) [@a].
@ok 2 (@app [@X, @a]) (@app [@f, @a]) [@f].                                           % here two solutions for X: fun _ => a, fun x => x
@ok 3 (@lam x\ @app [@X, x, @a]) (@lam x\ @app [@f, x, @a]) [@f].

@ko 4 (@app [@f, @X]) @X.
@ko 5 (@app [@f, @X, @X]) (@app [@f, @a, @b]).
@ok 6 (@app [@f, @X, @Y, @X]) (@app [@f, (@app [@f, @Y]), @b, (@app [@f, @b])]) [@app [@f, @b], @b].
@ok 7 (@lam x\ (@app [@f, @X])) (@lam x\ (@app [@f, @a])) [@a].

@ok 8 (@lam x\ @lam y\ @app [@X, x, y]) (@lam x\ @lam y\ @app [@X, x, y]) [@Z].

@ok 9  (@lam x\ @lam y\ @app [@X, x, y]) (@lam x\ @lam y\ @app [@f, y]) [@lam x\ @f].
@ok 10 @X (@lam x\ @lam y\ @app [@X, y, x]) [@lam x\ @lam y\ TODO_].

@ok 11 (@lam x\ @app [@X, x]) (@lam x\ @app [@f, x, x, @a]) [@lam x\ @app [@f, x, x, @a]].
@ok 12 (@lam x\ @app [@X, x, @a]) (@lam x\ @app [@f, x, x, @a]) [@lam x\ @app [@f, x, x]].                 % here two solutions for X: fun x _ => f x x a, fun x y => f x x y

@okl 13 [
  (triple ok (@lam x\ @app [@X, x]) (@lam x\ @app [@f, x])), 
  (triple ok @f @X)].

% TODO: 131 & 132 dont work yet...
% @okl 131 [
%   (triple ok (@lam x\ @app [@X, x]) @f), % ci costringe a bucare il lambda, ci puo' essere una eta 
%   (triple ok @f @X)].

% @okl 132 [
%   (triple ok (@lam x\ @app [@X, x]) (@lam x\ @app[@f, x, x])),  % visto che buchiamo a sx, la link deve usare il PF sotto il lambda
%   (triple ok @X (@lam y\ @app [@f, y, y]))].

@okl 14 [
  (triple ok (@lam x\ @app [@X, x]) (@lam x\ @app [@f, x])), 
  (triple (error "unif") @g @X)]. % we fail early

@okl 15 [
  (triple ok (@lam x\ @app [@X, x]) (@lam x\ @app [@f, @app[@Y,x]])), 
  (triple (error "unif") @g @X)]. % we fail early for the wrong reason

@okl 16 [
  (triple ok (@X) (@lam x\ @app [@f, @app[@Y,x]])), 
  (triple ok @f @X)].

@okl 17 [
  (triple ok @X (@lam x\ x)),
  (triple ok (@app [@X, @a]) (@a))
]. % beta redex

@okl 18 [
  (triple ok (@lam x\ @app[@X, x, @a]) (@lam x\ @app[@f, x, @a]))
].                                                                               % here two solutions for X: fun x _ => f x a, fun x y => f x y

@okl 19 [
  (triple ok (@lam x\ @app[@X, x, @a]) (@lam x\ @app[@f, @a]))
].                                                                               % here two solutions for X: fun _ _ => f a, fun _ x => f x

% @okl 20 [
%   (triple (error "comp1") (@lam x\ @app[@X, x, x, @a]) (@lam x\ @app[@f, x, @a]))
% ]. % we are not in PF, X have two solutions: fun x _ => f x | fun _ x => f x

@okl 21 [
  (triple ok (@lam x\ @lam y\ @app[@f, y, @a]) (@lam x\ @lam y\ @app[@X, x, y]))
].

% @okl 22001 [
%   triple ok (@lam x\ @lam y\ @app[@Y, y, x]) @Z,
%   triple ok (@app[@g, @Z]) @X,
%   triple ok (@app[@g, @f]) @X,
% ].
% @okl 22000 [
%   triple ok (@app[@g, (@lam x\ @lam y\ @app[@Y, y, x])]) @X,
%   triple ok (@app[@g, @f]) @X,
% ].
@okl 2200 [
  triple ok (@lam x\ @lam y\ @app[@Y, y, x]) @X,
  triple ok (@f) @X,
].
@okl 220 [
  triple ok (@lam x\ @lam y\ @app[@Y, y, x]) @X,
  triple ok (@lam x\             @f) @X,
].
@okl 22 [
  triple ok (             @f) @X,
  triple ok ( @lam y\ @app[@Y, y]) @X,
].

@okl 23 [
  triple ok (@lam x\ @app[@f, @app[@X, x]]) @Y,
  triple ok @X (@lam x\ x),
].

@okl 24 [
  triple ok (@lam x\ x) @X,
  triple ok @Y (@lam x\ @app[@f, @app[@X, x]]),
].

@okl 25 [
  triple ok (@lam x\ @app[@f, @app[@X, x]]) @Y,
  triple ok @X (@lam x\ x),
  triple ok @Y @f
].