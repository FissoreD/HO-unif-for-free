internal-test try4.comp.test-hope-eta-1.
internal-test try4.comp.test-hope-eta-2.

namespace try4 {

%%%%%%%%%%%%%%%%%%% the OL %%%%%%%%%%%%%%%%%%%%%
namespace fo {

kind tm type.
type app list tm -> tm.
type lam (tm -> tm) -> tm.
type uv  nat -> tm.
type c string -> tm.

typeabbrev subst list (option tm).

% [equal Subst T1 T2] check if two terms are equal for the OL
% note: T1 and T2 are never flexible elpi variables
type equal subst -> tm -> tm -> o.
equal _ X Y :- (var X ; var Y), halt "flex".
equal S (uv N) T1 :- assigned? N S T, equal S T T1.
equal S T1 (uv N) :- assigned? N S T, equal S T1 T.
equal S (app [uv N|Args]) T1 :- assigned? N S F, beta F Args T, equal S T T1.
equal S T1 (app [uv N|Args]) :- assigned? N S F, beta F Args T, equal S T1 T.
equal S (app L1) (app L2) :- forall2 (equal S) L1 L2.
equal S (lam F1) (lam F2) :- pi x\ equal S x x => equal S (F1 x) (F2 x).
equal _ (c X) (c X).
equal _ (uv N) (uv N).

% eta
equal S (lam F) T :- not (T = lam _), 
  pi x\ beta T [x] (T' x), equal S (lam F) (lam T').
equal S T (lam F) :- not (T = lam _), 
  pi x\ beta T [x] (T' x), equal S (lam T') (lam F).

% beta
equal S (app [lam X | TL]) T :- beta (lam X) TL T', equal S T' T.
equal S T (app [lam X | TL]) :- beta (lam X) TL T', equal S T T'.

% [alloc-subst T S S'] foraech var in T, alloc an uv N at place N in S' (that extends S)
type alloc-subst tm -> subst -> subst -> o.
alloc-subst (uv N) S S :- len S M, M >n N.
alloc-subst (uv N) S S' :- len S M, M >=n N, std.append S [none] S'.
alloc-subst (lam F) S S' :- pi x\ (pi S\alloc-subst x S S) => alloc-subst (F x) S S'.
alloc-subst (c _) S S.
alloc-subst (app L) S S1 :- fold alloc-subst L S S1.

type beta tm -> list tm -> tm -> o.
beta A [] A.
beta (lam Bo) [H | L] R :- beta (Bo H) L R.
beta (app A) L (app X) :- std.append A L X.
beta (uv N) L (app [uv N | L]).
beta (c H) L (app [c H | L]).

% [new S N S'] return S' which is S with none at pos N
type new subst -> nat -> subst -> o.
new [] z [none].
new [X|XS] (s N) [X|YS] :- new XS N YS.

type mk-app tm -> list tm -> tm -> o.
mk-app T L S :- beta T L S.

type eta-contract tm -> tm -> o.
eta-contract (c X) (c X).
eta-contract (app L) (app L1) :- forall2 eta-contract L L1.
eta-contract (lam F) T :- contract [] (lam F) T.
eta-contract (lam F) (lam F1) :- pi x\ eta-contract x x => eta-contract (F x) (F1 x).
eta-contract (uv X) (uv X).

type contract list tm -> tm -> tm -> o.
contract L (lam F) T :- 
  pi x\ contract [x|L] (F x) T. % also checks H Prefix does not see x
contract L (app [H|Args]) T :- 
  std.rev L LRev, std.appendR Prefix LRev Args,
  if (Prefix = []) (T = H) (T = app [H|Prefix]).

}

%%%%%%%%%%%%%%%%%%% the ML %%%%%%%%%%%%%%%%%%%%%

namespace ho {

typeabbrev subst list (option assignment).

kind assignment type.
type abs (tm -> assignment) -> assignment.
type val tm -> assignment.

kind tm type.
type app list tm -> tm.
type lam (tm -> tm) -> tm.
type uv  nat -> list tm -> tm.
type c string -> tm.

% [unif T1 T2 SOld SNew] check if T1 and T2 unify looking into SOld. SNew is the final substution
type unif tm -> tm -> subst -> subst ->  o.
% TODO: QUESTION HERE WE MAY GENERATE KIND OF ETA EXPANSION IN HO.SUBST WITH BETA-ABS
unif (uv N Args) T S S1 :- assigned? N S F, beta-abs F Args T1, unif T1 T S S1.
unif T (uv N Args) S S1 :- assigned? N S F, beta-abs F Args T1, unif T T1 S S1.
unif (uv N A) (uv N A) S S :- pattern-fragment A.

unif (uv N Args1) (uv M Args2) S S3 :- pattern-fragment Args1, pattern-fragment Args2, 
  std.spy(new S W S1, prunexx W Args1 Args2 Ass, assign N S1 Ass S2, assign M S2 Ass S3).

unif (uv N Args) T S S1 :- not (T = uv _ _), print "In here", std.do![not_occ N S T, pattern-fragment Args, bind Args T T1, assign N S T1 S1].
unif T (uv N Args) S S1 :- not (T = uv _ _), std.spy(not_occ N S T), pattern-fragment Args, bind Args T T1, assign N S T1 S1.

% TODO: here we make FO unification -> should be moved in 
% unif (app [uv N L | Args]) (app L1) S S1 :-
%   std.appendR Hd Args L1,
%   unif (uv N L) (app Hd) S S1.


unif (app L1) (app L2) S S1 :- fold2 unif L1 L2 S S1.
unif (lam F1) (lam F2) S S1 :- pi x\ (pi S\ unif x x S S) => unif (F1 x) (F2 x) S S1.
unif (c X) (c X) S S.

% Vorremmo saperli unificare, ma non ci sono nella nostra specifica (CoqTerms non unificano eta-beta in Elpi)
% % eta
% unif T (lam F) S S1 :- not (T = lam _), 
%   pi x\ beta T [x] (F' x), unif (lam F') (lam F) S S1.
% unif T (lam F) S S1 :- not (T = lam _), 
%   pi x\ beta T [x] (F' x), unif (lam F') (lam F) S S1.

% % beta
% unif (app [lam F | TL]) T S S1 :- beta (lam F) TL T', unif T' T S S1.
% unif T (app [lam F | TL]) S S1 :- beta (lam F) TL T', unif T T' S S1.

type prunexx nat -> list tm -> list tm -> assignment -> o.
prunexx N A1 A2 T :-
  prune-aux N A1 A2 [] T _.


type prunex nat -> list tm -> list tm -> subst -> subst -> o.
prunex N A1 A2 S S2 :-
  new S M S1,
  prune-aux M A1 A2 [] F ff,
  assign N S1 F S2.
prunex _ _ _ S S.

type prune-aux nat -> list tm -> list tm -> list tm -> assignment -> bool -> o.
prune-aux N [] [] ACC (val (uv N Args)) tt :- std.rev ACC Args.
prune-aux N [X|XS] [X|YS] ACC (abs F) O :- pi x\ prune-aux N XS YS [x|ACC] (F x) O.
prune-aux N [_|XS] [_|YS] ACC (abs F) _ :- pi x\ prune-aux N XS YS ACC (F x) tt.

type beta-abs assignment -> list tm -> tm -> o.
beta-abs (abs Bo) [H | L] R :- beta-abs (Bo H) L R.
beta-abs (val A)  [] A.
beta-abs (val (app A))  L (app X) :- std.append A L X.
beta-abs (val (uv N A)) L (uv N X) :- std.append A L X.
beta-abs (val (c H))    L (app [c H | L]).

type beta tm -> list tm -> tm -> o.
beta A [] A.
beta (lam Bo) [H | L] R :- beta (Bo H) L R.
beta (app A) L (app X) :- std.append A L X.
beta (uv N A) L (uv N A') :- std.append A L A'.
beta (c H) L (app [c H | L]).

% type occ_aux nat -> subst -> tm -> o.
% occ_aux N _S (uv N _).
% occ_aux N S (uv M Args) :- assigned? M S F, beta-abs F Args T, occ_aux N S T.
% occ_aux N S (app L) :- exists (occ_aux N S) L.
% occ_aux N S (lam F) :- pi x\ occ_aux N S (F x).
% 
% type occ  nat -> subst -> tm -> o.
% occ N _S (uv N _) :- !, fail.
% occ N S (uv M Args) :- assigned? M S F, !, beta-abs F Args T, occ N S T.
% occ N S T :- occ_aux N S T.

type not_occ_aux nat -> subst -> tm -> o.
not_occ_aux N S (uv M _) :- not(assigned? M S _), diff N M.
not_occ_aux N S (uv M Args) :- assigned? M S F, beta-abs F Args T, not_occ_aux N S T.
not_occ_aux N S (app L) :- forall1 (not_occ_aux N S) L.
not_occ_aux N S (lam F) :- pi x\ /*not_occ_aux N S x =>*/ not_occ_aux N S (F x).
not_occ_aux _ _ (c _).
not_occ_aux _ _ X :- name X.
 
type not_occ  nat -> subst -> tm -> o.
not_occ N S T :- print "not occ" N S T, fail.
not_occ N _ (uv N _).
not_occ N S (uv M Args) :- assigned? M S F, beta-abs F Args T, not_occ N S T.
not_occ _ _ (c _).
not_occ N S (app L) :- not_occ_aux N S (app L).
not_occ N S (lam L) :- not_occ_aux N S (lam L).
not_occ _ _ X :- name X.

type copy tm -> tm -> o.
copy (app L) (app L') :- forall2 copy L L'.
copy (lam T) (lam T') :- pi x\ copy x x => copy (T x) (T' x).
copy (uv N L) (uv N L') :- forall2 copy L L'.
copy (c C) (c C).

type bind list tm -> tm -> assignment -> o.
bind [] T (val T') :- copy T T'.
bind [X | TL] T (abs T') :- pi x\ copy X x => bind TL T (T' x).

type new subst -> nat -> subst -> o.
new [] z [none].
new [X|XS] (s N) [X|YS] :- new XS N YS.

type unif-assignment assignment -> assignment -> subst -> subst -> o.
unif-assignment (val T1) (val T2) H H1 :- unif T1 T2 H H1.
unif-assignment (abs F1) (abs F2) H H1 :- pi x\ (pi S\ unif x x S S) => unif-assignment (F1 x) (F2 x) H H1.
% unif-assignment (val T) (abs F) H H1 :- unif-assignment (abs x\ val {beta-abs (val T) [x]}) (abs F) H H1.
% unif-assignment (abs F) (val T) H H1 :- print "HERE", std.do![unif-assignment (abs F) (abs x\ val {beta-abs (val T) [x]}) H H1].

type equal subst -> tm -> tm -> o.
equal S (uv N Args) T1 :- assigned? N S F, beta-abs F Args T, equal S T T1.
equal S T1 (uv N Args) :- assigned? N S F, beta-abs F Args T, equal S T1 T.
equal S (app L1) (app L2) :- forall2 (equal S) L1 L2.
equal S (lam F1) (lam F2) :- pi x\ equal S x x => equal S (F1 x) (F2 x).
equal _ (c X) (c X).
equal _ (uv N A) (uv N A).

}

namespace comp {

kind link type.
type link nat -> nat -> nat -> link.

% type not-in list A -> A -> o.
% not-in [] _.
% not-in [X | TL] _ :- not (X = T), not-in TL _.

type not-in A -> list A -> o.
not-in _ [].
not-in T [X | TL] :- not (X = T), not-in T TL.

type split-pf list A -> list A -> list A -> list A -> o.
split-pf [] _ [] [].
split-pf [X | L] ACC [X | PF] NPF :- name X, not-in X ACC, !, 
  split-pf L [X | ACC] PF NPF.
split-pf L _ [] L.

type comp fo.tm -> ho.tm -> list link -> list link -> ho.subst -> ho.subst -> o.
comp (fo.c X)   (ho.c X) L L S S.
comp (fo.app [fo.uv N|Argsss]) TT L L3 S S3 :- %!,
  % TODO: here split-pf to enter dist. names into N
  % split-pf Argsss [] PF NPF,
  split-pf Argsss [] PF [], NPF = [], % TODO: compile to (uv N L) + link-fo-app
  print "In PF" PF NPF, 
  if (NPF = []) (TT = ho.uv M PF1) (TT = ho.app [ho.uv M PF1 | NPF1]),
  % pattern-fragment Args,
  fold4 comp PF PF1 L L1 S S1,
  fold4 comp NPF NPF1 L1 L2 S1 S2,
  ho.new S2 M S3,
  % TODO: maybe len can be given by split-pf
  len PF Len,
  L3 = [link N M Len| L2].
% TODO: if don't want to modify unif, we compile `fo.app [fo.c f, c0, c0, ho.c a]` into 
% `ho.app [ho.app[f, c0, c0], ho.c a]
comp (fo.app A) (ho.app A1) L L1 S S1 :- fold4 comp A A1 L L1 S S1.
comp (fo.lam F) (ho.lam F1) L L1 S S1 :- 
  (pi x y\ (pi A S\ comp x y A A S S) => comp (F x) (F1 y) L L1 S S1).
comp (fo.uv N) (ho.uv M []) L [link N M z|L] S S1 :- ho.new S M S1.

type solve-link list link -> list link -> ho.subst -> ho.subst -> o.
solve-link [link N M LenM|L] LR HO HO1 :- take-link L (link N M' LenM') L1, !, std.do! [
  same-assign M M' LenM LenM' W HO HO2,
  solve-link [link N W LenM|L1] LR HO2 HO1,
].
solve-link [L|LS] [L|LS'] HO HO1 :- solve-link LS LS' HO HO1.
solve-link [] [] X X.

type same-assign nat -> nat -> nat -> nat -> nat -> ho.subst -> ho.subst -> o.
same-assign M M' LenM LenM' W HO HO2 :- std.do![
  if (assigned? M HO T, W = M) true (eta LenM M [] T),
  if (assigned? M' HO T', W = M') true (eta LenM' M' [] T'),
  if (LenM = LenM')
     (std.spy(ho.unif-assignment T T' HO HO2))
     (hope-for-eta HO T Te,
      hope-for-eta HO T' Te',
      std.spy(not(LenM = LenM'),my-unif-assignment Te Te' HO HO2))
  ].
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
%%% nel test 15 abbiamo
%%%   Len=1  x\ app[f,Y x]
%%%   Len=0  X
%%%
%%% il codice sotto (my-unif-assignment) fa X = a\ app[f,Y a]
%%% e cambia arietà a X che non va bene
%%%
%%% T = x\ app[f,Y x] deve essere di arità zero
%%% allora o il T coq è (lam x\ app[f,Y x]) oppure f
%%%
%%% sempre nel test 15, dopo c'è g = X
%%% ora falliamo perche g != (lam x\ app[f,Y x])
%%% penso che dire Y x = x non sia "il più generale"
%%%
%%% ora mi sa che fallisce perchè g != lam
%%% che è "sbagliato" (forse) perchè potrebbe anche avere
%%% successo assegnado Y (in quel momento, ma non lo possiamo
%%% fare prima, nelle varie link...)
%%%
%%% in pratica mi pare che o perdiamo generalità (e assegnamo Y presto)
%%% o ritardiamo, restiamo corretti, ma sequenza di successi/fallimenti
%%% non è fedele.
%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
type my-unif-assignment ho.assignment -> ho.assignment -> ho.subst -> ho.subst -> o.
my-unif-assignment A B _ _ :- print A "===" B, fail.
my-unif-assignment (ho.val T1) (ho.val T2) H H1 :- ho.unif T1 T2 H H1.
my-unif-assignment (ho.abs F1) (ho.abs F2) H H1 :- pi x\ (pi S\ ho.unif x x S S) => my-unif-assignment (F1 x) (F2 x) H H1.
my-unif-assignment (ho.val V)  (ho.abs F2) H H1 :-
    deref H V (ho.uv N L),
    pi x\ (pi S\ ho.unif x x S S) =>
      sigma L1\ std.append L [x] L1,
       my-unif-assignment (ho.val (ho.uv N L1)) (F2 x) H H1.
my-unif-assignment (ho.val V)  (ho.abs F2) H H1 :-
    deref H V (ho.app L),
    pi x\ (pi S\ ho.unif x x S S) =>
      sigma L1\ std.append L [x] L1,
       my-unif-assignment (ho.val (ho.app L1)) (F2 x) H H1.
my-unif-assignment (ho.val V)  (ho.abs F2) H H1 :-
    deref H V (ho.c C),
    pi x\ (pi S\ ho.unif x x S S) =>
       my-unif-assignment (ho.val (ho.app [ho.c C,x])) (F2 x) H H1.

% tries to eta contract at each "depth", not just at the top
type hope-for-eta ho.subst -> ho.assignment -> ho.assignment -> o.
hope-for-eta H (ho.abs _ as F) G :- hope-contract H [] F G.
hope-for-eta H (ho.abs F) (ho.abs G) :-
  pi x\ deref H x x => hope-for-eta H (F x) (G x).
hope-for-eta _ (ho.val T) (ho.val T).

% given x\y\z\... it tries to contract against xyz, then xy, then x
type hope-contract ho.subst -> list ho.tm -> ho.assignment -> ho.assignment -> o.
hope-contract H L (ho.abs F) T :- 
  pi x\ deref H x x => hope-contract H [x|L] (F x) T.
hope-contract H L (ho.abs F) T :- 
  pi x\ deref H x x => hope-contract.aux H [x|L] (F x) T.

% checks if the term is xxx\ yyy\ app[...|xxx] -> yyy\ app[...]
type hope-contract.aux ho.subst -> list ho.tm -> ho.assignment -> ho.assignment -> o.
hope-contract.aux H L (ho.abs F) (ho.abs G) :- pi x\ deref H x x => hope-contract.aux H L (F x) (G x).
hope-contract.aux H L (ho.val V) (ho.val T) :- std.do! [
  deref H V (ho.app[Hd|Args]),
  std.rev L LRev,
  std.appendR Prefix LRev Args,
  if (Prefix = []) (T = Hd) (T = ho.app [Hd|Prefix]),
].

type test-hope-eta-1 o.
type test-hope-eta-2 o.
test-hope-eta-1 :- hope-for-eta [] (ho.abs x\ ho.abs y\ ho.val (ho.app[ho.c"f",ho.app[ho.c"g",x],y]))
                                   (ho.abs x\           ho.val (ho.app[ho.c"f",ho.app[ho.c"g",x]  ])).
test-hope-eta-2 :- hope-for-eta [] (ho.abs x\ ho.abs y\ ho.val (ho.app[ho.c"f",ho.app[ho.c"g",y],x]))
                                   (          ho.abs y\ ho.val (ho.app[ho.c"f",ho.app[ho.c"g",y]  ])).

type deref ho.subst -> ho.tm -> ho.tm -> o.
deref H (ho.uv N L) X :- assigned? N H T, ho.beta-abs T L X', deref H X' X.
deref H (ho.app L) (ho.app L1) :- forall2 (deref H) L L1.
deref _ (ho.c X) (ho.c X).
deref H (ho.uv X L) (ho.uv X L1) :- forall2 (deref H) L L1.
deref H (ho.lam F) (ho.lam G) :- pi x\ deref H x x => deref H (F x) (G x).

% [eta Arity VarName Acc Ass]
type eta nat -> nat -> list ho.tm -> ho.assignment -> o.
eta z     N Acc (ho.val (ho.uv N Acc')) :- std.rev Acc Acc'.
eta (s M) N Acc (ho.abs F) :- pi x\ eta M N [x | Acc] (F x).

type take-link list link -> link -> list link -> o.
take-link [L|XS] L XS.
take-link [L|XS] L' [L|YS] :- not(L = L'), take-link XS L' YS.

type assign-equal fo.subst -> nat -> fo.subst -> fo.tm -> fo.subst -> o.
assign-equal _ z (none :: L) Y (some Y :: L).
assign-equal S z (some A :: L) B (some A :: L) :- fo.equal S A B. 
assign-equal S (s N) (X :: L) Y (X :: L1) :- assign-equal S N L Y L1.

type assign-replace nat -> fo.subst -> fo.tm -> fo.subst -> o.
assign-replace z [_|S] X [some X |S].
assign-replace (s N) [A|S] X [A |S1] :- assign-replace N S X S1.

type decompl.aux list link -> list link -> ho.subst -> fo.subst -> fo.subst -> o.
decompl.aux [link N M Arity|L] LK HO FO FO1 :- assigned? M HO T, !, std.do! [
  % HERE the assign-equal
  decomp-assign LK HO T T0 FO FO',
  fo.eta-contract T0 T',
  % TODO: QUESTION: here we are assigning a solution to fo.subst, maybe we 
  %                 could authorize eta redexes between FO[N] and T'
  print "Assigning" N "to" T' "with arity" Arity,
  %assign-equal FO' N FO' T' FO2,
  assign-replace N FO' T' FO2,
  decompl.aux L LK HO FO2 FO1,
].
decompl.aux [_|L] LK HO FO FO1 :- decompl.aux L LK HO FO FO1.
decompl.aux [] _ _ X X.

type decompl list link -> list link -> ho.subst -> fo.subst -> fo.subst -> o.
decompl L LK HO FO FO1 :- std.do! [
  decompl.aux L LK HO FO NewFO,
  merge-fo NewFO NewFO FO FO1,
].

type merge-fo fo.subst -> fo.subst -> fo.subst -> fo.subst -> o.
merge-fo _ [] [] [].
merge-fo _ X [] X.
merge-fo S [some X|XS] [some Y|YS] [some Y|R] :- std.spy(fo.equal S X Y), merge-fo S XS YS R. % we keep the old
merge-fo S [none|XS] [some X|YS] [some X|R] :- merge-fo S XS YS R.
merge-fo S [some X|XS] [none|YS] [some X|R] :- merge-fo S XS YS R.
merge-fo S [none|XS] [none|YS] [none|R] :- merge-fo S XS YS R.

% we use links just to know if the variables are new
type decomp-assign list link -> ho.subst -> ho.assignment -> fo.tm -> fo.subst -> fo.subst -> o.
% decomp-assign LK HO (ho.abs F) F1 S S1 :-
%   pi x y\ (pi S\ decomp LK HO x y S S) => decomp-assign LK HO (F x) F1 S S1.

decomp-assign LK HO (ho.abs F) (fo.lam F1) S S1 :-
  pi x y\ (pi S\ decomp LK HO x y S S) => decomp-assign LK HO (F x) (F1 y) S S1.

decomp-assign LK HO (ho.val T) T1 S S1 :- decomp LK HO T T1 S S1.

type decomp list link -> ho.subst -> ho.tm -> fo.tm -> fo.subst -> fo.subst -> o.
decomp _ _ (ho.c X)   (fo.c X) S S.
decomp LK HO (ho.app L) SolOL S S1 :- 
  fold2 (decomp LK HO) L [HD|TL] S S1,
  fo.mk-app HD TL SolOL.
decomp LK HO (ho.lam F) (fo.lam F1) S S1 :-
  pi x y\ (pi S\ decomp LK HO x y S S) => decomp LK HO (F x) (F1 y) S S1.
decomp LK HO (ho.uv N Args) SolOL S S1 :- assigned? N HO T, !,
  ho.beta-abs T Args T1,
  decomp LK HO T1 SolOL S S1.
decomp LK HO (ho.uv N Args) SolOL S S1 :-
  fold2 (decomp LK HO) Args Args1 S S2,
  if (take-link LK (link X N _) _) (S1 = S2)
     (fo.new S2 X S1',
      if (assigned? N HO T)
         (decomp-assign LK HO T T' S1' S1'', assign X S1'' T' S1)
         (S1 = S1')),
  fo.mk-app (fo.uv X) Args1 SolOL.

/*
type eta-contract tm -> tm -> o.
eta-contract X X :- var X, !.
eta-contract (c X) (c X).
eta-contract (app L) (app L1) :- forall2 eta-contract L L1.
eta-contract (lam F) T :- contract [] (lam F) T.
eta-contract (lam F) (lam F1) :- pi x\ (pi X Y\ eta-contract X Y :- name X, X = Y) => eta-contract (F x) (F1 x).
eta-contract (uv X Args) (uv X Args).

type contract list tm -> tm -> tm -> o.
% contract A B _ :- print A B, fail.
contract L X T :- var X, !, fail.
contract L (lam F) T :- 
  pi x\ contract [x|L] (F x) T. % also checks H Prefix does not see x
contract L (app [H|Args]) T :- 
  %print "Base case",
  std.rev L LRev, std.appendR Prefix LRev Args,
  if (Prefix = []) (T = H) (T = app [H|Prefix]).
*/
    
}}

