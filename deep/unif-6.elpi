internal-test try6.comp.test-hope-eta-1.
internal-test try6.comp.test-hope-eta-2.

namespace try6 {

%%%%%%%%%%%%%%%%%%% the OL %%%%%%%%%%%%%%%%%%%%%
namespace fo {

% Common terms
kind fm type.
type fapp list fm -> fm.
type flam (fm -> fm) -> fm.
type fcon string -> fm.
type fuva  nat -> fm.

typeabbrev subst list (option fm).

type deref subst -> fm -> fm -> o.
deref _ X _ :- var X, halt "flex deref".
deref S (fuva N) T1 :- set? N S T, deref S T T1.
deref S (fapp [fuva N|L]) R :- set? N S T, !, beta T L R', deref S R' R.
deref S (fapp L1) (fapp L2) :- forall2 (deref S) L1 L2.
deref S (flam F1) (flam F2) :- pi x\ deref S x x => deref S (F1 x) (F2 x).
deref _ (fcon X) (fcon X).
deref _ (fuva N) (fuva N).
deref _ N N :- name N.
% deref A B V :- var V, halt "This is should be an error" B A.

% [equal T1 T2] check if two terms are equal for the OL
type (==o) fm -> fm -> o.

X ==o Y :- (var X ; var Y), halt "flex equal". % chekc to prevent implem errors
fapp L1 ==o fapp L2 :- forall2 (==o) L1 L2.
flam F1 ==o flam F2 :- pi x\ x ==o x => F1 x ==o F2 x.
fcon X ==o fcon X.
fuva N ==o fuva N.
flam F ==o T :- pi x\ beta T [x] (T' x), x ==o x => F x ==o T' x.
T ==o flam F :- pi x\ beta T [x] (T' x), x ==o x => T' x ==o F x.
fapp [flam X | TL] ==o T :- beta (flam X) TL T', T' ==o T.
T ==o fapp [flam X | TL] :- beta (flam X) TL T', T ==o T'.

% [extend-subst T S S'] forall fuva N in T, extends S with none at pos N
% this is used only in test to build the subst-map before running it
type extend-subst fm -> subst -> subst -> o.
extend-subst (fuva N) S S' :- extend-nat N S S'.
extend-subst (flam F) S S' :- pi x\ (pi S\extend-subst x S S) => extend-subst (F x) S S'.
extend-subst (fcon _) S S.
extend-subst (fapp L) S S1 :- fold extend-subst L S S1.

% aux function for extend-subst
type extend-nat nat -> subst -> subst -> o.
extend-nat z X Y :- std.append X [none] Y.
extend-nat (s N) [] [none | M] :- extend-nat N [] M.
extend-nat (s N) [X | L] [X | M] :- extend-nat N L M.

type beta fm -> list fm -> fm -> o.
beta A [] A.
beta (flam Bo) [H | L] R :- beta (Bo H) L R.
beta (fapp A) L (fapp X) :- std.append A L X.
beta (fuva N) L (fapp [fuva N | L]).
beta (fcon H) L (fapp [fcon H | L]).

% [new S N S'] returns a new free variable N in S' = S @ [none]
type new subst -> nat -> subst -> o.
new [] z [none].
new [X|XS] (s N) [X|YS] :- new XS N YS.

type mk-app fm -> list fm -> fm -> o.
mk-app T L S :- beta T L S.

type eta-contract fm -> fm -> o.
eta-contract (fcon X) (fcon X).
eta-contract (fapp L) (fapp L1) :- forall2 eta-contract L L1.
eta-contract (flam F) T :- contract [] (flam F) T.
eta-contract (flam F) (flam F1) :- pi x\ eta-contract x x => eta-contract (F x) (F1 x).
eta-contract (fuva X) (fuva X).
eta-contract X X :- name X.

type contract list fm -> fm -> fm -> o.
contract L (flam F) T :- 
  pi x\ contract [x|L] (F x) T. % also checks H Prefix does not see x
contract L (fapp [H|Args]) T :- 
  std.rev L LRev, std.appendR Prefix LRev Args,
  if (Prefix = []) (T = H) (T = fapp [H|Prefix]).

}

%%%%%%%%%%%%%%%%%%% the ML %%%%%%%%%%%%%%%%%%%%%

namespace ho {

typeabbrev subst list (option assignment).

kind assignment type.
type abs (tm -> assignment) -> assignment.
type val tm -> assignment.

kind tm  type.
type app list tm -> tm.
type lam (tm -> tm) -> tm.
type con string -> tm.
type uva  nat -> list tm -> tm.

% [unif T1 T2 SOld SNew] check if T1 and T2 unify looking into SOld. SNew is the final substution
type unif tm -> tm -> subst -> subst ->  o.
% Base cases
unif (app L1) (app L2) S S1 :- fold2 unif L1 L2 S S1.
unif (lam F1) (lam F2) S S1 :- 
  pi x\ (pi S\ unif x x S S) => unif (F1 x) (F2 x) S S1.
unif (con X) (con X) S S.
% Assigned variables
unif (uva N Args) T S S1 :- 
  set? N S F, move F Args T1, unif T1 T S S1.
unif T (uva N Args) S S1 :- 
  set? N S F, move F Args T1, unif T T1 S S1.
% Not assigned vars
unif (uva N A) (uva N A) S S :- pattern-fragment A.
unif (uva N Args1) (uva M Args2) S S3 :- 
  unset? N S, unset? M S,
  pattern-fragment Args1, pattern-fragment Args2, 
  new S W S1, prunexx W Args1 Args2 Ass, 
  assign N S1 Ass S2,
  if (unset? M S2) % M = N case
     (assign M S2 Ass S3)
     (S3 = S2),
  print "Assigning in uva N Args1" N M S1 Ass S3. 
unif (uva N Args) T S S1 :- 
  not (T = uva _ _), not_occ N S T, pattern-fragment Args, 
  bind T Args T1, print "Binding T to Args" T Args T1, assign N S T1 S1, print "Assing1 T1" T1.
unif T (uva N Args) S S1 :- 
  print "In this case before failing",
  std.spy-do![not (T = uva _ _), not_occ N S T, pattern-fragment Args, 
  bind T Args T1,print "Binding T to Args" T Args T1,  assign N S T1 S1, print "Assing2 T2" T1].

% Note: eta & beta for unification is not allowed in ML over terms of the OL

type prunexx nat -> list tm -> list tm -> assignment -> o.
prunexx N A1 A2 T :- prune-aux N A1 A2 [] T.

type prune-aux nat -> list tm -> list tm -> list tm -> assignment -> o.
prune-aux N [] [] ACC (val (uva N Args)) :- std.rev ACC Args.
prune-aux N [X|XS] [X|YS] ACC (abs F) :- pi x\ prune-aux N XS YS [x|ACC] (F x).
prune-aux N [_|XS] [_|YS] ACC (abs F) :- pi x\ prune-aux N XS YS ACC (F x).

% What is this for? We also lack of the case: move (abs Bo) [] _ => ??
type move assignment -> list tm -> tm -> o.
move (abs Bo)        [H|L] R :- move (Bo H) L R.
move (val A)         []    A.
move (val (app A))   L     (app X) :- std.append A L X.
move (val (uva N A)) L     (uva N X) :- std.append A L X.
move (val (con H))   L     (app [con H | L]).

type move-ass assignment -> list tm -> assignment -> o.
move-ass (abs Bo)        [H|L] R :- move-ass (Bo H) L R.
move-ass (abs Bo)        []    (abs Bo).
move-ass (val A)         []    (val A).
move-ass (val (app A))   L     (val (app X)) :- std.append A L X.
move-ass (val (uva N A)) L     (val (uva N X)) :- std.append A L X.
move-ass (val (con H))   L     (val (app [con H | L])).

type beta tm -> list tm -> tm -> o.
beta A [] A.
beta (lam Bo) [H | L] R :- beta (Bo H) L R.
beta (app A) L (app X) :- std.append A L X.
beta (uva N A) L (uva N A') :- std.append A L A'.
beta (con H) L (app [con H | L]).

type not_occ_aux nat -> subst -> tm -> o.
not_occ_aux N S (uva M _) :- not(set? M S _), diff N M.
not_occ_aux N S (uva M Args) :- set? M S F, move F Args T, not_occ_aux N S T.
not_occ_aux N S (app L) :- forall1 (not_occ_aux N S) L.
not_occ_aux N S (lam F) :- pi x\ /*not_occ_aux N S x =>*/ not_occ_aux N S (F x).
not_occ_aux _ _ (con _).
not_occ_aux _ _ X :- name X.
 
type not_occ  nat -> subst -> tm -> o.
% not_occ N S T :- print "not occ" N S T, fail.
not_occ N _ (uva N _).
not_occ N S (uva M Args) :- set? M S F, move F Args T, not_occ N S T.
not_occ N S (uva M Args) :- unset? M S, std.forall Args (not_occ_aux N S).
not_occ _ _ (con _).
not_occ N S (app L) :- not_occ_aux N S (app L).
not_occ N S (lam L) :- pi x\ not_occ N S (L x).
not_occ _ _ X :- name X.

type copy tm -> tm -> o.
copy (app L)   (app L') :- forall2 copy L L'.
copy (lam T)   (lam T') :- pi x\ copy x x => copy (T x) (T' x).
copy (uva N L) (uva N L') :- forall2 copy L L'.
copy (con C)   (con C).

type bind tm -> list tm -> assignment -> o.
% Replace lambdas with abstraction of the ML and abstracting the list of tm in L
% Note L is a list in the pattern fragment
bind (lam T) L (abs T') :- !, pi x\ copy x x => bind (T x) L (T' x).
bind T [] (val T') :- copy T T'.
bind T [X | TL] (abs T') :- pi x\ copy X x => bind T TL (T' x).

type new subst -> nat -> subst -> o.
new [] z [none].
new [X|XS] (s N) [X|YS] :- new XS N YS.

type unif-assignment assignment -> assignment -> subst -> subst -> o.
unif-assignment (val T1) (val T2) H H1 :- unif T1 T2 H H1.
unif-assignment (abs F1) (abs F2) H H1 :- pi x\ (pi S\ unif x x S S) => unif-assignment (F1 x) (F2 x) H H1.

type deref subst -> tm -> tm -> o.
deref H (uva N L) X :- set? N H T, move T L X', deref H X' X.
deref H (app L) (app L1) :- forall2 (deref H) L L1.
deref _ (con X) (con X).
deref H (uva X L) (uva X L1) :- forall2 (deref H) L L1.
deref H (lam F) (lam G) :- pi x\ deref H x x => deref H (F x) (G x).
deref _ N N :- name N.
% deref A B V :- var V, halt "This is should be an error" B A.

type assmt-deref subst -> assignment -> assignment -> o.
assmt-deref S (abs T) (abs R) :-
  pi x\ assmt-deref S (T x) (R x).
assmt-deref S (val T) (val R) :-
  deref S T R.
}

namespace comp {

shorten fo.{ (==o) }.

kind link type.
type link nat -> nat -> nat -> link.
type link-fo-align list ho.tm -> nat -> nat -> nat -> link.

% type link-eta list ho.tm 
% TODO: add link eta, in the case of added holes

% [maybe-eta i:T i:N i:EV o:A o:CV o:Arity]
% takes OL term, a name, a ML fresh variable
% returns an assignment and CV if T has the shape (flam x,y,...z. app[fuva CV|L])
% and N is in L: this should carru out a potential eta expansion if CV is assigned
% by a previous unif problem
type maybe-eta fo.fm -> fo.fm -> nat ->  ho.assignment -> nat -> nat -> o.
maybe-eta (fo.flam B) N EV (ho.abs A) R Arity :- pi x y\ (pi A S\ comp x y A A S S) => maybe-eta (B x) N EV (A y) R Arity.
% TODO: here I suppose that L is a list of Name, ie, R is in PF. This is not true generally
maybe-eta (fo.fapp[fo.fuva R | L]) N EV (ho.val (ho.uva EV L1)) R Arity :- 
  pattern-fragment L,
  fold4 comp L L1 [] [] S S, 
  mem L N, len L Arity.

type comp fo.fm -> ho.tm -> list link -> list link -> ho.subst -> ho.subst -> o.
comp (fo.fcon X)              (ho.con X) L L S S.
% TODO: this is wrong, since we should pass something in the scope of W
% comp (fo.flam F) (ho.uva W []) L L1 S S2 :-
  
%   pi x y\ (pi A S\ comp x y A A S S) => (
%     ho.new S W S1,
%     std.spy-do![maybe-eta (F x) x W (Ass y) CV Arity, !,
%     print "In comp hypoth eta",
%     assign W S1 (ho.abs Ass) S2,
%     L1 = [link CV W Arity| L]]).

comp (fo.flam F) (ho.lam F1) L L1 S S1 :- 
  pi x y\ (pi A S\ comp x y A A S S) => comp (F x) (F1 y) L L1 S S1.
comp (fo.fuva N)              (ho.uva M []) L [link N M z|L] S S1 :- ho.new S M S1.
comp (fo.fapp [fo.fuva N|Ag]) (ho.uva M PF1) L L3 S S3 :- !,
  split-pf Ag PF NPF,
  fold4 comp PF PF1 L L S S1,
  fold4 comp NPF NPF1 L L1 S1 S2,
  ho.new S2 M S3,
  len PF Len,
  % TODO: NYI NPF1 can contain non-closed terms (i.e. local vars...)
  if (NPF = []) (LinkType = link) (LinkType = link-fo-align NPF1),
  L3 = [LinkType N M Len | L1].
comp (fo.fapp A)              (ho.app A1) L L1 S S1 :- fold4 comp A A1 L L1 S S1.

% type collect-link link -> list link -> list link -> list link -> o.
% collect-link _ [] [] [].
% collect-link (link N _ _) [link N A B | TL] [link N A B | Xs] Ys :- !,
%   collect-link (link N _ _) TL Xs Ys.
% collect-link _ [link N A B | TL] Xs [link N A B | Ys] :- !,
%   collect-link (link N _ _) TL Xs Ys.

% type collect-links list link -> list (list link) -> o.
% collect-links [] [].
% collect-links [X|Xs] [[X | L1]|Ys] :-
%   collect-link X Xs L1 L2,
%   collect-links L2 Ys.

% type solve-link-- link -> list link -> list link -> ho.subst -> ho.subst -> o.
% solve-link-- _ [] [] H H.
% solve-link-- (link N M LenM) [link N M' LenM' | As] [link N W LenM|Bs] S S2 :-
%   same-assign M M' LenM LenM' W S S1,
%   solve-link-- (link N W LenM) As Bs S1 S2.

% type solve-link list link ->  list link -> ho.subst -> ho.subst -> o.
% solve-link L L1 S S' :-
%   std.spy-do![
%   collect-links L M,
%   fold (x\old\new\ sigma HD TL\ [HD|TL] = x, solve-link-- HD TL old new) M S S',
%   std.map M (x\y\ sigma A\ x = [y|A]) L1], !.
% solve-link A_ B_ D_ E_ :- halt "STOP".

% We test forall linked var of the ML, that they have the same assignment
type solve-link list link -> list link -> ho.subst -> ho.subst -> o.
solve-link [] [] X X.
solve-link [link N M LenM|L] LR HO HO1 :- take-link L (link N M' LenM') L1, !, std.spy-do! [
  print "Anchor same assign che fa cazzate",
  same-assign M M' LenM LenM' W HO HO2,
  print "Solve link recursive call",
  solve-link [link N W LenM|L1] LR HO2 HO1,
].
solve-link [L|LS] [L|LS'] HO HO1 :- solve-link LS LS' HO HO1.

type same-assign-aux nat -> nat -> ho.assignment -> ho.assignment -> ho.subst -> ho.subst -> o.
same-assign-aux L L T R HO HO2 :- !, std.spy(my-unif-assignment T R HO HO2).
same-assign-aux _ _ T R HO HO2 :- 
  hope-for-eta HO T Te,
  hope-for-eta HO R Re,
  print "Acnora più casino qui2",
  std.spy(my-unif-assignment Te Re HO HO2).
 
type same-assign nat -> nat -> nat -> nat -> nat -> ho.subst -> ho.subst -> o.
same-assign M N LenM LenN W HO HO2 :- set? M HO AM, set? N HO AN, W = M,
  same-assign-aux LenM LenN AM AN HO HO2.
same-assign M N LenM LenN W HO HO2 :- set? M HO AM, unset? N HO,  W = M, eta LenN N [] AN, print "Eta for" N "is" AN,
  same-assign-aux LenM LenN AM AN HO HO2.
same-assign M N LenM LenN W HO HO2 :- unset? M HO, set? N HO AN,  W = N, eta LenM M [] AM, print "Eta for" M "is" AM,
  same-assign-aux LenM LenN AM AN HO HO2.
same-assign M N LenM LenN W HO HO2 :- unset? M HO, unset? N HO,   W = M, eta LenN N [] AN, eta LenM M [] AM, print "Eta for" M "is" AM, print "Eta for" N "is" AN,
  same-assign-aux LenM LenN AM AN HO HO2.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
%%% nel test 15 abbiamo
%%%   Len=1  x\ app[f,Y x]
%%%   Len=0  X
%%%
%%% il codice sotto (my-unif-assignment) fa X = a\ app[f,Y a]
%%% e cambia arietà a X che non va bene
%%%
%%% T = x\ app[f,Y x] deve essere di arità zero
%%% allora o il T coq è (lam x\ app[f,Y x]) oppure f
%%%
%%% sempre nel test 15, dopo con'è g = X
%%% ora falliamo perche g != (lam x\ app[f,Y x])
%%% penso che dire Y x = x non sia "il più generale"
%%%
%%% ora mi sa che fallisce perchè g != lam
%%% che è "sbagliato" (forse) perchè potrebbe anche avere
%%% successo assegnado Y (in quel momento, ma non lo possiamo
%%% fare prima, nelle varie link...)
%%%
%%% in pratica mi pare che o perdiamo generalità (e assegnamo Y presto)
%%% o ritardiamo, restiamo corretti, ma sequenza di successi/fallimenti
%%% non è fedele.
%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Invariant, the assmt in entry are never on the form `ho.val (ho.abs _)`
type my-unif-assignment-aux ho.assignment -> ho.assignment -> ho.subst -> ho.subst -> o.

my-unif-assignment-aux (ho.val (ho.uva V L)) T H H1 :- !,
  abs->lam T T',
  ho.unif (ho.uva V L) T' H H1.
my-unif-assignment-aux T (ho.val (ho.uva V L)) H H1 :- !,
  abs->lam T T',
  ho.unif T' (ho.uva V L) H H1.

my-unif-assignment-aux (ho.val T1) (ho.val T2) H H1 :- print "@@@ Start unif between T1 and T2" T1 T2, ho.unif T1 T2 H H1, print "After unif" H H1.
my-unif-assignment-aux (ho.abs F1) (ho.abs F2) H H1 :- 
  pi x\ (pi S\ ho.unif x x S S) => my-unif-assignment-aux (F1 x) (F2 x) H H1.

my-unif-assignment-aux (ho.val T) (ho.abs F2) H H1 :-
  print "Enter aa",
  pi x\ sigma R\ unif-mk-app T x R, 
  (pi S\ ho.unif x x S S) => my-unif-assignment-aux (ho.val R) (F2 x) H H1,
  print "exit bb".

my-unif-assignment-aux (ho.abs F2) (ho.val T) H H1 :-
  pi x\ sigma R\ unif-mk-app T x R, 
  (pi S\ ho.unif x x S S) => my-unif-assignment-aux (F2 x) (ho.val R) H H1.

type lam->abs ho.assignment -> ho.assignment -> o.
lam->abs (ho.val (ho.lam T)) (ho.abs R) :- !, pi x\ lam->abs (ho.val (T x)) (R x).
lam->abs (ho.val A) (ho.val A).
lam->abs (ho.abs T) (ho.abs R) :- pi x\ lam->abs (T x) (R x).

type abs->lam ho.assignment -> ho.tm -> o.
abs->lam (ho.abs T) (ho.lam R)  :- !, pi x\ abs->lam (T x) (R x).
abs->lam (ho.val A) A.

type unif-mk-app ho.tm -> ho.tm -> ho.tm -> o.
unif-mk-app (ho.uva N L) T (ho.uva N R) :- appendR L [T] R.
unif-mk-app (ho.con C) T (ho.app [ho.con C, T]).
unif-mk-app (ho.app L) T (ho.app R) :- appendR L [T] R.

type my-unif-assignment ho.assignment -> ho.assignment -> ho.subst -> ho.subst -> o.
my-unif-assignment T R S1 S2 :-
  ho.assmt-deref S1 T TDeref,
  ho.assmt-deref S1 R RDeref,
  lam->abs TDeref TAbs,
  lam->abs RDeref RAbs,
  print "Start of unification aux between" TAbs "and" RAbs,
  my-unif-assignment-aux TAbs RAbs S1 S2.

% tries to eta contract at each "depth", not just at the top
type hope-for-eta ho.subst -> ho.assignment -> ho.assignment -> o.
hope-for-eta H (ho.abs _ as F) G :- hope-contract H [] F G.
hope-for-eta H (ho.abs F) (ho.abs G) :-
  pi x\ ho.deref H x x => hope-for-eta H (F x) (G x).
hope-for-eta _ (ho.val T) (ho.val T).

% given x\y\z\... it tries to contract against xyz, then xy, then x
type hope-contract ho.subst -> list ho.tm -> ho.assignment -> ho.assignment -> o.
hope-contract H L (ho.abs F) T :- 
  pi x\ ho.deref H x x => hope-contract H [x|L] (F x) T.
hope-contract H L (ho.abs F) T :- 
  pi x\ ho.deref H x x => hope-contract.aux H [x|L] (F x) T.

% checks if the term is xxx\ yyy\ app[...|xxx] -> yyy\ app[...]
type hope-contract.aux ho.subst -> list ho.tm -> ho.assignment -> ho.assignment -> o.
hope-contract.aux H L (ho.abs F) (ho.abs G) :- pi x\ ho.deref H x x => hope-contract.aux H L (F x) (G x).
hope-contract.aux H L (ho.val V) (ho.val T) :- std.do! [
  ho.deref H V (ho.app[Hd|Args]),
  std.rev L LRev,
  std.appendR Prefix LRev Args,
  if (Prefix = []) (T = Hd) (T = ho.app [Hd|Prefix]),
].

% [eta Arity VarName Acc Ass]
type eta nat -> nat -> list ho.tm -> ho.assignment -> o.
eta z     N Acc (ho.val (ho.uva N Acc')) :- std.rev Acc Acc'.
eta (s M) N Acc (ho.abs F) :- pi x\ eta M N [x | Acc] (F x).

type take-link list link -> link -> list link -> o.
take-link [L|XS] L XS.
take-link [L|XS] L' [L|YS] :- not(L = L'), take-link XS L' YS.

type assign-replace nat -> fo.subst -> fo.fm -> fo.subst -> o.
assign-replace z [none|S] X [some X |S].
assign-replace (s N) [A|S] X [A |S1] :- assign-replace N S X S1.

type decompl.aux list link -> list link -> ho.subst -> fo.subst -> fo.subst -> o.
decompl.aux [link N M _Arity|L] LK HO FO FO1 :- set? M HO T, !, 
  ho.assmt-deref HO T T'', print "In HERE", print "The terms assigned is" T "in memory HO" HO "dereferenced is" T'', std.spy-do! [
  decomp-assign LK HO T T0 FO FO',
  fo.eta-contract T0 T',
  assign-replace N FO' T' FO2,
  decompl.aux L LK HO FO2 FO1,
].

type get-head fo.fm -> nat -> list fo.fm -> fo.fm -> o.
get-head (fo.fapp L) z Args T :-
  appendR [Hd|Tl] Args L,
  fo.mk-app Hd Tl T.
get-head (fo.flam B) (s N) Args T :-
  pi x\ get-head (B x) N Args (R x),
  fo.eta-contract (fo.flam R) T.

% This is classic beta
decompl.aux [link-fo-align Args N M Arity_|L] LK HO FO FO1 :- set? M HO T, set? N FO R, !, std.spy-do! [
  decomp-assign LK HO T T0 FO FO'',
  fold2 (decomp LK HO) Args Args1 FO'' FO',
  fo.mk-app R Args1 T0,
  decompl.aux L LK HO FO' FO1,
].
% FO-approx
decompl.aux [link-fo-align Args N M Arity|L] LK HO FO FO1 :- set? M HO T, unset? N FO, !, std.spy-do! [
  decomp-assign LK HO T T0 FO FO'',
  fold2 (decomp LK HO) Args Args1 FO'' FO',
  get-head T0 Arity Args1 TTT,
  assign-replace N FO' TTT FO2,
  decompl.aux L LK HO FO2 FO1,
].
decompl.aux [_|L] LK HO FO FO1 :- decompl.aux L LK HO FO FO1.
decompl.aux [] _ _ X X.

type decompl list link -> list link -> ho.subst -> fo.subst -> fo.subst -> o.
decompl L LK HO FO FO1 :- std.do! [
  decompl.aux L LK HO FO NewFO,
  merge-fo NewFO NewFO FO FO1,
].

type merge-fo fo.subst -> fo.subst -> fo.subst -> fo.subst -> o.
merge-fo _ [] [] [].
merge-fo _ X [] X.
% TODO: returning [some Y|R] is incorrect, we should return [some Z|R] where
%       Z is the unification of X and Y in the OL
% TODO: instead of deref-deref-equal, we need unif 
% NOTE: Invariant: if X and Y are assigned, then they are equal (TODO: to be verified)
merge-fo S [some X|XS] [some Y|YS] [some Y|R] :- std.spy(fo.deref S X X', fo.deref S Y Y', std.spy-do![X' ==o Y']), merge-fo S XS YS R. 
merge-fo S [none|XS] [some X|YS] [some X|R] :- merge-fo S XS YS R.
merge-fo S [some X|XS] [none|YS] [some X|R] :- merge-fo S XS YS R.
merge-fo S [none|XS] [none|YS] [none|R] :- merge-fo S XS YS R.

% we use links just to know if the variables are new
type decomp-assign list link -> ho.subst -> ho.assignment -> fo.fm -> fo.subst -> fo.subst -> o.
% decomp-assign LK HO (ho.abs F) F1 S S1 :-
%   pi x y\ (pi S\ decomp LK HO x y S S) => decomp-assign LK HO (F x) F1 S S1.

decomp-assign LK HO (ho.abs F) (fo.flam F1) S S1 :-
  pi x y\ (pi S\ decomp LK HO x y S S) => decomp-assign LK HO (F x) (F1 y) S S1.

decomp-assign LK HO (ho.val T) T1 S S1 :- print "Before decomp LK HO", std.spy(decomp LK HO T T1 S S1).

type decomp list link -> ho.subst -> ho.tm -> fo.fm -> fo.subst -> fo.subst -> o.
decomp _ _ (ho.con X)   (fo.fcon X) S S :- print "OK for constant".
decomp LK HO (ho.app L) SolOL S S1 :- print "In decomp LK HO 2", std.spy-do![
  fold2 (decomp LK HO) L [HD|TL] S S1, 
  fo.mk-app HD TL SolOL].
decomp LK HO (ho.lam F) (fo.flam F1) S S1 :-
  pi x y\ (pi S\ decomp LK HO x y S S) => decomp LK HO (F x) (F1 y) S S1.
decomp LK HO (ho.uva N Args) SolOL S S1 :- set? N HO T, !, print "In set case of uva" T, std.spy-do![
  ho.move-ass T Args T1a,
  abs->lam T1a T1,
  % ho.move T Args T1,
  decomp LK HO T1 SolOL S S1].
decomp LK HO (ho.uva N Args) SolOL S S1 :- print "Entering uva decomp",
  fold2 (decomp LK HO) Args Args1 S S2,
  if (take-link LK (link X N _) _) (S1 = S2)
     (fo.new S2 X S1',
      if (set? N HO T)
         (decomp-assign LK HO T T' S1' S1'', assign X S1'' T' S1)
         (S1 = S1')),
  fo.mk-app (fo.fuva X) Args1 SolOL.

type test-hope-eta-1 o.
type test-hope-eta-2 o.
test-hope-eta-1 :- hope-for-eta [] (ho.abs x\ ho.abs y\ ho.val (ho.app[ho.con"f",ho.app[ho.con"g",x],y]))
                                   (ho.abs x\           ho.val (ho.app[ho.con"f",ho.app[ho.con"g",x]  ])).
test-hope-eta-2 :- hope-for-eta [] (ho.abs x\ ho.abs y\ ho.val (ho.app[ho.con"f",ho.app[ho.con"g",y],x]))
                                   (          ho.abs y\ ho.val (ho.app[ho.con"f",ho.app[ho.con"g",y]  ])).
}}

