internal-test comp.test-hope-eta-1.
internal-test comp.test-hope-eta-2.
% internal-test comp.test-hope-eta-3.
% internal-test comp.test-hope-eta-4.
% internal-test comp.test-hope-eta-5.
% internal-test comp.test-hope-eta-6.
internal-test ho.test-unif-1.
internal-test ho.test-unif-2.
internal-test ho.test-unif-3.
internal-test ho.test-unif-4.
internal-test ho.test-unif-5.
internal-test ho.test-unif-6.

%%%%%%%%%%%%%%%%%%% the OL %%%%%%%%%%%%%%%%%%%%%
namespace fo {

% Common terms
kind fm type.
type fapp list fm -> fm.
type flam (fm -> fm) -> fm.
type fcon string -> fm.
type fuva  addr -> fm.

type pp fm -> string -> o.
pp X "_" :- var X.
pp (fapp L) S :- !, std.string.concat " " {std.map L pp} X, S is "(@ " ^ X ^ ")".
pp (fcon S) S :- !.
pp (flam F) S :- !, pi x\ std.any->string x N, pp (F x) S1, S is "λ" ^ N ^ "." ^ S1.
pp (fuva N) S :- !, ppuva N S.
pp X S :- name X, !, std.any->string X S.
pp _ "ERROR".

type ppuva addr -> string -> o.
ppuva N S :- ppaddr N X, S is "C" ^ X.

typeabbrev subst list (option fm).

type ppsubst subst -> list string -> o.
ppsubst L S :- ppsubst.aux z L S.

type ppsubst.aux nat -> subst -> list string -> o.
ppsubst.aux _ [] [].
ppsubst.aux N [some X|XS] [L|LS] :- L is {ppuva (addr N)} ^ " := " ^ {pp X}, ppsubst.aux (s N) XS LS.
ppsubst.aux N [none|XS] [L|LS] :- L is {ppuva (addr N)} ^ " := _", ppsubst.aux (s N) XS LS.

type deref subst -> fm -> fm -> o.
deref _ X _ :- var X, fatal "flex deref".
deref S (fuva N) T1 :- set? N S T, deref S T T1.
deref S (fapp [fuva N|L]) R :- set? N S T, !, beta T L R', deref S R' R.
deref S (fapp L1) (fapp L2) :- forall2 (deref S) L1 L2.
deref S (flam F1) (flam F2) :- pi x\ deref S x x => deref S (F1 x) (F2 x).
deref _ (fcon X) (fcon X).
deref _ (fuva N) (fuva N).
deref _ N N :- name N.
% deref A B V :- var V, fatal "This is should be an error" B A.

% [equal T1 T2] check if two terms are equal for the OL
type (==o) fm -> fm -> o.

X ==o Y :- (var X ; var Y), fatal "flex equal". % chekc to prevent implem errors
fapp L1 ==o fapp L2 :- forall2 (==o) L1 L2.
flam F1 ==o flam F2 :- pi x\ x ==o x => F1 x ==o F2 x.
fcon X ==o fcon X.
fuva N ==o fuva N.
flam F ==o T :- pi x\ beta T [x] (T' x), x ==o x => F x ==o T' x.
T ==o flam F :- pi x\ beta T [x] (T' x), x ==o x => T' x ==o F x.
fapp [flam X | TL] ==o T :- beta (flam X) TL T', T' ==o T.
T ==o fapp [flam X | TL] :- beta (flam X) TL T', T ==o T'.

% [extend-subst T S S'] forall fuva N in T, extends S with none at pos N
% this is used only in test to build the subst-map before running it
type extend-subst fm -> subst -> subst -> o.
extend-subst (fuva N) S S' :- mem-alloc N S S'.
extend-subst (flam F) S S' :- pi x\ (pi S\extend-subst x S S) => extend-subst (F x) S S'.
extend-subst (fcon _) S S.
extend-subst (fapp L) S S1 :- fold extend-subst L S S1.

type beta fm -> list fm -> fm -> o.
beta A [] A.
beta (flam Bo) [H | L] R :- beta (Bo H) L R.
beta (fapp A) L (fapp X) :- std.append A L X.
beta (fuva N) L (fapp [fuva N | L]).
beta (fcon H) L (fapp [fcon H | L]).

type mk-app fm -> list fm -> fm -> o.
mk-app T L S :- beta T L S.

type eta-contract fm -> fm -> o.
eta-contract (fcon X) (fcon X).
eta-contract (fapp L) (fapp L1) :- forall2 eta-contract L L1.
eta-contract (flam F) T :- contract [] (flam F) T.
eta-contract (flam F) (flam F1) :- pi x\ eta-contract x x => eta-contract (F x) (F1 x).
eta-contract (fuva X) (fuva X).
eta-contract X X :- name X.

type contract list fm -> fm -> fm -> o.
contract L (flam F) T :- 
  pi x\ contract [x|L] (F x) T. % also checks H Prefix does not see x
contract L (fapp [H|Args]) T :- 
  std.rev L LRev, std.appendR Prefix LRev Args,
  if (Prefix = []) (T = H) (T = fapp [H|Prefix]).

}

%%%%%%%%%%%%%%%%%%% the ML %%%%%%%%%%%%%%%%%%%%%

namespace ho {

typeabbrev subst list (option assignment).

kind inctx type -> type.
type abs (tm -> inctx A) -> inctx A.
type val A -> inctx A.

typeabbrev assignment (inctx tm).

kind tm  type.
type app list tm -> tm.
type lam (tm -> tm) -> tm.
type con string -> tm.
type uva  addr -> list tm -> tm.

type pp tm -> string -> o.
pp (app L) S :- !, std.string.concat " " {std.map L pp} X, S is "(" ^ X ^ ")".
pp (con S) S :- !.
pp (lam F) S :- !, pi x\ std.any->string x N, pp (F x) S1, S is N ^ "\\ " ^ S1.
pp (uva N L) S :- !, std.string.concat " " {std.map L pp} X, !, S is {ppuva N} ^ " " ^ X.
pp X S :- name X, !, std.any->string X S.
pp _ "ERROR".

type ppuva addr -> string -> o.
ppuva N S :- S is "X" ^ {ppaddr N}.

type ppsubst subst -> list string -> o.
ppsubst L S :- ppsubst.aux z L S.
type ppsubst.aux nat -> subst -> list string -> o.
ppsubst.aux _ [] [].
ppsubst.aux N [some X|XS] [L|LS] :- L is {ppuva (addr N)} ^ " " ^ {ppass X}, ppsubst.aux (s N) XS LS.
ppsubst.aux N [none|XS] [L|LS] :- L is {ppuva (addr N)} ^ " := _", ppsubst.aux (s N) XS LS.

type ppass assignment -> string -> o.
ppass (abs F) S :- pi x\ std.any->string x N, ppass (F x) S1, S is N ^ " " ^ S1.
ppass (val T) S :- S is " := " ^ {pp T}.

% [unif T1 T2 SOld SNew] check if T1 and T2 unify looking into SOld. SNew is the final substution
type unif tm -> tm -> subst -> subst ->  o.
%unif A B _ _ :- print "## unif" {pp A} "=?=" {pp B}, fail.
% Base cases
unif (app L1) (app L2) S S1 :- fold2 unif L1 L2 S S1.
unif (lam F1) (lam F2) S S1 :- 
  pi x\ (pi S\ unif x x S S) => copy x x => unif (F1 x) (F2 x) S S1.
unif (con X) (con X) S S.
% Assigned variables
unif (uva N Args) T S S1 :- 
  set? N S F,!, move F Args T1, unif T1 T S S1.
unif T (uva N Args) S S1 :- 
  set? N S F,!, move F Args T1, unif T T1 S S1.
% Not assigned vars
unif (uva N A) (uva N A) S S :- !, pattern-fragment A.
unif (uva V A) (uva U A) S1 S2 :- !, pattern-fragment A,
  prune-same-args V A [] Ass, assign U S1 Ass S2.
unif (uva N Args1) (uva N Args2) S S2 :- % same var 
  unset? N S,
  std.assert!(len Args1 Len, len Args2 Len) "Not typechecking", !, % the length of args must be the same
  pattern-fragment Args1, pattern-fragment Args2, 
  std.do![mem-new S W S1, prune-same-variable W Args1 Args2 Ass, 
  assign N S1 Ass S2],
  print "Assigning in uva N Args1" N {ppsubst S1} "+" {ppass Ass} "=>" {ppsubst S2}. 
unif (uva N Args1) (uva M Args2) S S3 :- % Args with diff length
  unset? N S, unset? M S, !,
  print "Unifying" {pp (uva N Args1)} "and" {pp (uva M Args2)},
  pattern-fragment Args1, pattern-fragment Args2, 
  mem-new S W S1, (prune-smart W Args1 Args2 Ass1 Ass2), 
  std.do![
  assign N S1 Ass1 S2,
  (N = M; assign M S2 Ass2 S3)]
  % print "Assigning in uva with diff len" N M S1 "with solution" Ass1 "and" Ass2 "in subst" S3
  . 
unif (uva N Args) T S S1 :- 
  not (T = uva _ _), not_occ N S T, pattern-fragment Args, 
  bind T Args T1,
  print "Binding args" {std.map Args pp} "in" {pp T} "gives" {ppuva N} {ppass T1},
  assign N S T1 S1.
% TODO: we could unify (f c0) with X, this does not work since c0 is a name
unif T (uva N Args) S S1 :- 
  not (T = uva _ _), not_occ N S T, pattern-fragment Args, 
  bind T Args T1,
  print "Binding args" {std.map Args pp} "in" {pp T} "gives" {ppuva N} {ppass T1},
  assign N S T1 S1.

% Note: eta & beta for unification is not allowed in ML over terms of the OL

% prune in the case of same argumets for the two vars (e.g. uv X L and uv Y L)
type prune-same-args addr -> list tm -> list tm -> assignment -> o.
prune-same-args N [] Acc (val (uva N Args)) :- std.rev Acc Args.
prune-same-args N [_ | B] L (abs T) :- pi x\ prune-same-args N B [x | L] (T x).

% prune in the case of vars with args of same length (e.g. uv X L1, uv Y L2, len L1 = len L2)
type prune-same-variable addr -> list tm -> list tm -> assignment -> o.
prune-same-variable N A1 A2 T :- prune-same-variable-aux N A1 A2 [] T.

type prune-same-variable-aux addr -> list tm -> list tm -> list tm -> assignment -> o.
prune-same-variable-aux N [] [] ACC (val (uva N Args)) :- std.rev ACC Args.
prune-same-variable-aux N [X|XS] [X|YS] ACC (abs F) :- pi x\ prune-same-variable-aux N XS YS [x|ACC] (F x).
prune-same-variable-aux N [_|XS] [_|YS] ACC (abs F) :- pi x\ prune-same-variable-aux N XS YS ACC (F x).

type prune-diff-length-aux addr -> list tm -> list tm -> assignment -> o.
prune-diff-length-aux N [] Acc (val (uva N Acc)).
prune-diff-length-aux N [_|L] Acc (abs T) :- pi x\ prune-diff-length-aux N L Acc (T x).

% res = argomenti dell'altro se li vedo anche io (nell'ordine dell'altro)
type prune-diff-length addr -> list tm -> list tm -> list tm -> assignment -> assignment -> o.
prune-diff-length N [] Args2 Acc (val (uva N Args)) Ass2 :-  !,
  std.rev Acc Args, prune-diff-length-aux N Args2 Args Ass2.
prune-diff-length N Args1 [] Acc Ass1 (val (uva N Args)) :- !,
  std.rev Acc Args, prune-diff-length-aux N Args1 Args Ass1.
prune-diff-length N [X|XS] [X|YS] ACC (abs F) (abs G) :- pi x\ prune-diff-length N XS YS [x|ACC] (F x) (G x).
prune-diff-length N [_|XS] [_|YS] ACC (abs F) (abs G):- pi x\ prune-diff-length N XS YS ACC (F x) (G x).
prune-diff-length A B C D _ _:- fatal "Prune error" A B C D.

type keep list A -> A -> bool -> o.
keep L A tt :- mem L A, !.
keep _ _ ff.

type prune-build-ass1 addr -> list tm -> list bool -> assignment -> o.
prune-build-ass1 N Acc [] (ho.val (uva N Args)) :- std.rev Acc Args.
prune-build-ass1 N Acc [tt|L] (ho.abs T) :- pi x\ prune-build-ass1 N [x|Acc] L (T x).
prune-build-ass1 N Acc [ff|L] (ho.abs T) :- pi x\ prune-build-ass1 N Acc L (T x).

type list-init nat -> nat -> (nat -> A -> o) -> list A -> o.
list-init Len Len _ [].
list-init Len Pos F [A | TL] :- F Pos A, list-init Len (s Pos) F TL.

type index list A -> A -> nat -> o.
index [A|_] A z :- !.
index [_|TL] A (s P) :- index TL A P.

type nth nat -> list A -> A -> o.
nth z [A|_] A :- !.
nth (s N) [_|L] A :- !, nth N L A.

type build-order list nat -> list tm -> list tm -> o.
build-order L T R :-
  len L Len, list-init Len z (p\r\ sigma Index Elt\ index L p Index, nth Index T r) R.

type prune-build-ass2 addr -> list tm -> list bool -> list nat -> assignment -> o.
prune-build-ass2 N Acc [] Pos (ho.val (uva N Args)) :- std.rev Acc Acc', build-order Pos Acc' Args.
prune-build-ass2 N Acc [tt|L] Pos (ho.abs T) :- pi x\ prune-build-ass2 N [x|Acc] L Pos (T x).
prune-build-ass2 N Acc [ff|L] Pos (ho.abs T) :- pi x\ prune-build-ass2 N Acc L Pos (T x).

type prune-smart addr -> list tm -> list tm -> assignment -> assignment -> o.
prune-smart N Args1 Args2 Ass1 Ass2 :-
  std.do![std.map Args1 (keep Args2) Bits1, prune-build-ass1 N [] Bits1 Ass1,
  std.map Args2 (keep Args1) Bits2, 
  std.filter Args1 (mem Args2) ToKeep1,
  std.filter Args2 (mem Args1) ToKeep2,
  std.map ToKeep2 (index ToKeep1) Pos,
  prune-build-ass2 N [] Bits2 Pos Ass2].

type move assignment -> list tm -> tm -> o.
move (abs Bo)        [H|L] R :- move (Bo H) L R.
move (val A)         []    A :- !.
% move (val (app A))   L     (app X) :- std.append A L X.
move (val (uva N A)) L     (uva N X) :- std.append A L X.
% move (val (con H))   L     (app [con H | L]).
 move (abs A)         []    _ :- !, fatal "Invalid move call: too few args for abs" A.
 move A               L    _ :- !, fatal "Invalid move call:" A L.

type move-ass assignment -> list tm -> assignment -> o.
move-ass (abs Bo)        [H|L] R :- move-ass (Bo H) L R.
move-ass (abs Bo)        []    (abs Bo).
move-ass (val A)         []    (val A).
move-ass (val (app A))   L     (val (app X)) :- std.append A L X.
move-ass (val (uva N A)) L     (val (uva N X)) :- std.append A L X.
move-ass (val (con H))   L     (val (app [con H | L])).

type beta tm -> list tm -> tm -> o.
beta A [] A.
beta (lam Bo) [H | L] R :- beta (Bo H) L R.
beta (app A) L (app X) :- std.append A L X.
beta (uva N A) L (uva N A') :- std.append A L A'.
beta (con H) L (app [con H | L]).

type not_occ_aux addr -> subst -> tm -> o.
not_occ_aux N S (uva M _) :- std.do![unset? M S, not (N = M)].
not_occ_aux N S (uva M Args) :- std.do![set? M S F, move F Args T, not_occ_aux N S T].
not_occ_aux N S (app L) :- forall1 (not_occ_aux N S) L.
not_occ_aux N S (lam F) :- pi x\ /*not_occ_aux N S x =>*/ not_occ_aux N S (F x).
not_occ_aux _ _ (con _).
not_occ_aux _ _ X :- name X.
 
type not_occ  addr -> subst -> tm -> o.
% not_occ N S T :- print "not occ" N S T, fail.
not_occ N _ (uva N _).
not_occ N S (uva M Args) :- set? M S F, move F Args T, not_occ N S T.
not_occ N S (uva M Args) :- unset? M S, std.forall Args (not_occ_aux N S).
not_occ _ _ (con _).
not_occ N S (app L) :- not_occ_aux N S (app L).
not_occ N S (lam L) :- pi x\ not_occ N S (L x).
not_occ _ _ X :- name X.

type copy tm -> tm -> o.
copy (app L)   (app L') :- forall2 copy L L'.
copy (lam T)   (lam T') :- pi x\ copy x x => copy (T x) (T' x).
copy (uva N L) (uva N L') :- forall2 copy L L'.
copy (con C)   (con C).
copy N N :- not(scope-check), name N.

type scope-check o.

type bind tm -> list tm -> assignment -> o.
bind T [] (val T') :- scope-check => copy T T'.
bind T [X | TL] (abs T') :- pi x\ copy X x => bind T TL (T' x).

type unif-assignment assignment -> assignment -> subst -> subst -> o.
unif-assignment (val T1) (val T2) H H1 :- unif T1 T2 H H1.
unif-assignment (abs F1) (abs F2) H H1 :- pi x\ (pi S\ unif x x S S) => ho.copy x x => unif-assignment (F1 x) (F2 x) H H1.

type deref subst -> tm -> tm -> o.
deref H (uva N L)  X         :- set? N H T, move T L X', !, deref H X' X.
deref H (app L)   (app L1)   :- forall2 (deref H) L L1.
deref _ (con X)   (con X).
deref H (uva X L) (uva X L1) :- unset? X H, forall2 (deref H) L L1.
deref H (lam F)   (lam G)    :- pi x\ deref H (F x) (G x).
deref _ N         N          :- name N.
% deref A B V :- var V, fatal "This is should be an error" B A.

type assmt-deref subst -> assignment -> assignment -> o.
assmt-deref S (abs T) (abs R) :-
  pi x\ assmt-deref S (T x) (R x).
assmt-deref S (val T) (val R) :-
  deref S T R.


type eta-contract tm -> tm -> o.
eta-contract (con X)   (con X).
eta-contract (app L)   (app L1)   :- forall2 eta-contract L L1.
eta-contract (lam F)   T          :- contract [] (lam F) T.
eta-contract (lam F)   (lam F1)   :- pi x\ eta-contract x x => eta-contract (F x) (F1 x).
eta-contract (uva X L) (uva X L1) :- forall2 eta-contract L L1.
eta-contract X X :- name X.

type contract list tm -> tm -> tm -> o.
contract L (lam F) T :- 
  pi x\ contract [x|L] (F x) T. % also checks H Prefix does not see x
contract L (app [H|Args]) T :- 
  std.rev L LRev, std.appendR Prefix LRev Args,
  if (Prefix = []) (T = H) (T = app [H|Prefix]).
contract L (uva H Args) (uva H Prefix) :- 
  std.rev L LRev, std.appendR Prefix LRev Args.

type test-unif-1 o.
type test-unif-2 o.
type test-unif-3 o.
type test-unif-4 o.
type test-unif-5 o.
type test-unif-6 o.
test-unif-1 :- pi x\
  unif (uva (addr z) [x]) (uva (addr (s z)) []) [none, none] L,
  Z = (abs x\ val (uva X [])),
  SZ = val (uva X []),
  L = [some Z, some SZ|_].

test-unif-2 :- pi x y\
  unif (uva (addr z) [x, y]) (uva (addr (s z)) [y]) [none, none] L,
  Z = (abs x\ abs y\ val (uva X [y])),
  SZ = (abs x\ val (uva X [x])),
  L = [some Z, some SZ|_].

test-unif-3 :- pi x y w\
  unif (uva (addr z) [x, y]) (uva (addr (s z)) [x, w, y]) [none, none] L,
  Z = (abs x\ abs y\ val (uva X [x, y])),
  SZ = (abs x\ abs y\ abs z\ val (uva X [x, z])),
  L = [some Z, some SZ|_].

test-unif-4 :- pi x y\ 
  unif (uva (addr z) [x, y]) (uva (addr (s z)) [y, x]) [none, none] L,
  Z = (abs x\ abs y\ val (uva X [x, y])),
  SZ = (abs x\ abs y\ val (uva X [y, x])),
  L = [some Z, some SZ|_].

test-unif-5 :- pi x y zz w\
  unif (uva (addr z) [x, w, y]) (uva (addr (s z)) [y, zz, w]) [none, none] L,
  Z = (abs c0\ abs c1\ abs c2\ val (uva X [c1, c2])),
  SZ = (abs c0\ abs c1\ abs c2\ val (uva X [c2, c0])),
  L = [some Z, some SZ|_].

test-unif-6 :- pi x y zz w\
  unif (uva (addr (s z)) [y, zz, w]) (uva (addr z) [x, w, y]) [none, none] L,
  Z = (abs c0\ abs c1\ abs c2\ val (uva X [c2, c1])),
  SZ = (abs c0\ abs c1\ abs c2\ val (uva X [c0, c2])),
  L = [some Z, some SZ|_].
}

namespace comp {

kind arity type.
type arity nat -> arity.

kind fvariable type.
type fv addr -> fvariable.

kind hvariable type.
type hv addr -> arity -> hvariable.

kind mapping type.
type mapping fvariable -> hvariable -> mapping.
typeabbrev mappings (list mapping).

shorten fo.{ (==o) }.

typeabbrev scope (list ho.tm).

kind linkctx type.
% type link-fo-align list ho.tm -> nat -> nat -> nat -> link.
type link-eta ho.tm -> ho.tm -> linkctx.
% [link-fo-align Beta HeadVar PFvars NPFvars]
type link-fo-align addr -> addr -> scope -> scope -> linkctx.

typeabbrev linkabs (ho.inctx linkctx).

kind link type.
type link-abs linkabs -> link.

typeabbrev links (list link).

type pplinks links -> list string -> o.
pplinks [] [].
pplinks [L|Links] [S|PS] :-
  pplink L S,
  pplinks Links PS.

type pplink link -> string -> o.
pplink (link-abs A) S :-
  pplinkabs A S.

type ppmapping mapping -> string -> o.
ppmapping (mapping (fv N) (hv M (arity Len))) S :-
  S is {fo.ppuva N} ^ " -> " ^ {ho.ppuva M} ^ " (" ^ {ppnat Len} ^ ")".

type ppmappings mappings -> list string -> o.
ppmappings Map Str :- forall2 ppmapping Map Str.

type pplinkabs linkabs -> string -> o.
pplinkabs (ho.abs F) S :- pi x\ std.any->string x N, pplinkabs (F x) S1, S is N ^ " " ^ S1.
pplinkabs (ho.val (link-eta A B)) S :- S is "|- " ^ {ho.pp A} ^ " =η= " ^ {ho.pp B}.
pplinkabs (ho.val (link-fo-align _ _ _ _)) S :- S is "TODO pp fi align".

% [maybe-eta N T L] takes a name N a term T and a list of binder.
% return if T could be an eta expansion, possible cases:
%  - T = uva seing N (N is also the last of L)
%  - T = app L such that the last args of L are maybe-eta wrt L
type maybe-eta fo.fm -> fo.fm -> list fo.fm -> o.
maybe-eta N N _.
maybe-eta N (fo.fapp[fo.fuva _|Args]) _ :- !, mem Args N. % Head is flex -> if N is in Args, we can have eta
maybe-eta N (fo.flam B) L :- !, pi x\ maybe-eta N (B x) [x | L].
maybe-eta _ (fo.fapp [_ |Args]) L :-                      % Head is rigid -> to be an eta we consider also L
  last-n {len L} Args R, 
  forall2 (x\y\ maybe-eta y x [y]) R {std.rev L}.

type locale ho.tm -> o.
type get-scope ho.tm -> list ho.tm -> o.
get-scope (ho.con _) [].
get-scope (ho.uva _ L) L1 :- fold (x\y\r\ sigma R\ get-scope x R, std.append y R r) L [] L1.
get-scope (ho.lam B) L1 :- pi x\ locale x => get-scope (B x) L1.
get-scope (ho.app L) L1 :- fold (x\y\r\ sigma R\ get-scope x R, std.append y R r) L [] L1.
get-scope X [X] :- name X, not (locale X).
get-scope X [] :- name X, (locale X).

type close-links (ho.tm -> links) -> links -> o.
close-links (_\[]) [].
close-links (v\[link-abs L|XS v]) [link-abs L|YS] :- !, close-links XS YS.
close-links (v\[link-abs(L v)|XS v]) [link-abs(ho.abs L)|YS] :- !, close-links XS YS.

type comp-lam (fo.fm -> fo.fm) -> (ho.tm -> ho.tm) -> mappings -> mappings -> links -> links -> ho.subst -> ho.subst -> o.
comp-lam F F1 Mappings1 Mappings2 L L2 S S1 :-
  pi x y\ (pi M L S\ comp x y M M L L S S) => comp (F x) (F1 y) Mappings1 Mappings2 L (L1 y) S S1, close-links L1 L2.

type comp fo.fm -> ho.tm -> mappings -> mappings -> links -> links -> ho.subst -> ho.subst -> o.
comp (fo.fcon X)              (ho.con X) Mappings Mappings L L S S.
% TODO: this is wrong, since we should pass something in the scope of W
comp (fo.flam F) (ho.uva E0 Scope) Mappings1 Mappings2  L L2 S S2 :-
  %print "## comp eta" {fo.pp (fo.flam F)},
  (pi x\ not (F x = x), (maybe-eta x (F x)) [x]), !,
  % (pi x\ print {fo.pp (F x)} "is maybe eta"),
  std.do![
    mem-new S E0 S1,
    comp-lam F F1 Mappings1 Mappings2 L L1 S1 S2,
    names N,
    (pi x\ locale x => get-scope (F1 x) ScopeDuplicata), 
    std.filter N (mem ScopeDuplicata) Scope,
    % hack
    % (
    %   (F1 = (x\ho.uva _ [V1,x]), Scope = [V1]) ;
    %   (F1 = (x\ho.uva _ [V1,V2,x]), Scope = [V1,V2]) ;
    %   (F1 = (x\ho.uva _ [x, V1]), Scope = [V1]) ; % TODO this is needed for test 10
    %   % (F1 = (x\ho.app[ho.con _,uva ...V1,V2,x]), Scope = [V1,V2]) ;
    %   Scope = []),
    NewLink = link-abs (ho.val(link-eta (ho.uva E0 Scope) (ho.lam F1))),
  ], L2 = [NewLink| L1].
  % , % TODO save Scope in E0, somehow
  % print "------------------ END ETA -------------------",
  % print "with new link:" {pplinks [NewLink]},
  % print "----------------------------------------------".

comp (fo.flam F) (ho.lam F1) Mappings1 Mappings2 L L2 S S1 :- comp-lam F F1 Mappings1 Mappings2 L L2 S S1.
comp (fo.fuva N)              (ho.uva M []) Mappings Mappings1 L L S S1 :- alloc Mappings Mappings1 (fv N) (hv M (arity z)) S S1.
comp (fo.fapp [fo.fuva N|Ag]) (ho.uva MM PF1) Mappings1 Mappings3 L L3 S S4 :- !,
  split-pf Ag PF NPF,
  fold6 comp PF PF1 Mappings1 Mappings1 L L S S1,                                 % Note : PF is a list of names -> Mappings1 and L not change
  fold6 comp NPF NPF1 Mappings1 Mappings2 L L1 S1 S2,
  len PF Len,
  alloc Mappings2 Mappings3 (fv N) (hv M (arity Len)) S2 S3, % mem-new S2 M S3,
  % TODO: NYI NPF1 can contain non-closed terms (i.e. local vars...)
  if (NPF = []) (L3 = L1, S3 = S4, MM = M) 
    ( mem-new S3 MM S4,
      L3 = [link-abs(ho.val(link-fo-align MM M PF1 NPF1)) | L1])
  .
comp (fo.fapp A)              (ho.app A1) Mappings1 Mappings2 L L1 S S1 :- fold6 comp A A1 Mappings1 Mappings2 L L1 S S1.

type put-abs-uva nat -> addr -> list ho.tm -> ho.assignment -> o.
put-abs-uva z Ad L (ho.val (ho.uva Ad L1)) :- std.rev L L1.
put-abs-uva (s N) MV L (ho.abs B) :- pi x\ put-abs-uva N MV [x|L] (B x).

type post-comp mappings -> mappings -> ho.subst -> ho.subst -> links -> links -> o.
post-comp [] [] H H L L.
% Same fv-variable, with same arity appearing twice: the first is removed and
% the two hv-vars are unified
post-comp [mapping (fv O) (hv M1 (arity Arity)) | Map1] Map2 H1 H3 L1 L2 :- 
  mem Map1 (mapping (fv O) (hv M2 (arity Arity))), !,
  put-abs-uva Arity M1 [] Ass1,
  put-abs-uva Arity M2 [] Ass2,
  ho.unif-assignment Ass1 Ass2 H1 H2,
  post-comp Map1 Map2 H2 H3 L1 L2.
post-comp [(mapping (fv O) (hv M (arity LenM)) as X1) | Map1] Map2 H1 H2 L1 L3 :-
  take-list Map1 (mapping (fv O) (hv M' (arity LenM'))) _, LenM' >n LenM, !, std.do! [
    print "arity-fix links:" {ppmapping X1} "~<~" {ppmapping (mapping (fv O) (hv M' (arity LenM')))}, 
    make-eta-link LenM' LenM M M' [] New,
    print "new eta link" {pplinkabs New},
    L2 = [link-abs New | L1],
    post-comp Map1 Map2 H1 H2 L2 L3
  ].
post-comp [(mapping (fv O) (hv M (arity LenM)) as X1) | Map1] Map2 H1 H2 L1 L3 :-
  take-list Map1 (mapping (fv O) (hv M' (arity LenM'))) _, LenM >n LenM', !, std.do! [
    print "arity-fix links:" {ppmapping X1} "~<~" {ppmapping (mapping (fv O) (hv M' (arity LenM')))}, 
    make-eta-link LenM LenM' M' M [] New,
    print "new eta link" {pplinkabs New},
    L2 = [link-abs New | L1],
    post-comp Map1 Map2 H1 H2 L2 L3
  ].
post-comp [A|As] [A|Bs] H1 H2 L1 L2 :- post-comp As Bs H1 H2 L1 L2, !.
post-comp [A|_] _ H _ _ _ :- halt {ppmapping A} {ho.ppsubst H}.

type alloc mappings -> mappings -> fvariable -> hvariable -> ho.subst -> ho.subst -> o.
alloc Map Map N M H H :- std.mem Map (mapping N M), !.
alloc Map [mapping (fv N) (hv M Arity)|Map] (fv N) (hv M Arity) H H1 :- mem-new H M H1.
  

type eta-contract-ass ho.assignment -> ho.assignment -> o.
eta-contract-ass (ho.abs F) (ho.abs G) :- pi x\ eta-contract-ass (F x) (G x).
eta-contract-ass (ho.val T) (ho.val T1) :- ho.eta-contract T T1.

type rigid-head ho.tm -> o.
rigid-head (ho.lam X) :- !, pi x\ rigid-head (X x).
rigid-head T :- not (T = ho.uva _ _).

type fo-align ho.assignment -> ho.assignment -> list ho.tm -> ho.subst -> ho.subst -> o.
fo-align (ho.val(ho.uva N Args1)) (ho.val(ho.app Args2)) L_ S S1 :-
  appendR [Hd|Tl] Args1 Args2,
  ho.beta Hd Tl T,
  my-unif-assignment (ho.val (ho.uva N [])) (ho.val T) S S1.
fo-align (ho.abs X) (ho.abs Y) L S S1 :- pi x\
  (pi S\ ho.unif x x S S) => fo-align (X x) (Y x) [x|L] S S1.
fo-align A B S _ _ :- fatal "FO_align" A B S.

type count->lam ho.tm -> nat -> o.
count->lam (ho.lam B) (s X) :- !, pi x\ count->lam (B x) X.
count->lam _ z.

type eta-expand ho.tm -> nat -> ho.tm -> o.
eta-expand T z T.
eta-expand T (s N) (ho.lam R2) :- pi x\ unif-mk-app T x (R1 x), eta-expand (R1 x) N (R2 x). 

macro @one :- s z.

type contract-rigid list ho.tm -> ho.tm -> ho.tm -> o.
contract-rigid L (ho.lam F) T :- 
  pi x\ contract-rigid [x|L] (F x) T. % also checks H Prefix does not see x
contract-rigid L (ho.app [H|Args]) T :- 
  std.rev L LRev, std.appendR Prefix LRev Args,
  if (Prefix = []) (T = H) (T = ho.app [H|Prefix]).


% invariante: a sx non c'è mai una eta espansione, a destra c'è una lam, altrimenti il link eta è buttato via
type progress-eta-link ho.tm -> ho.tm -> ho.subst -> ho.subst -> bool -> o.
progress-eta-link (ho.app _ as T) (ho.lam x\ _ as T1) H H1 ff :- !, print "progress 1", ho.unif {eta-expand T @one} T1 H H1.
progress-eta-link (ho.con _ as T) (ho.lam x\ _ as T1) H H1 ff :- !, print "progress 2", ho.unif {eta-expand T @one} T1 H H1.
progress-eta-link (ho.lam _ as T) T1 H H1 ff :- !, print "progress 3", ho.unif T T1 H H1.

% progress-eta-link (ho.con _ as T) (ho.uva _ _ as T1) H H1 :- !, print "progrss 2.1", std.assert!(ho.unif T T1 H H1) "WHY?".
% progress-eta-link (ho.lam B) (ho.lam C) H H1 :- !, print "progress 3", pi x\ (pi S\ ho.unif x x S S) => ho.copy x x => progress-eta-link (B x) (C x) H H1. % fatal "progress eta lam".


% todo: guardare lo scope della uva di dx e allinearlo con quello di sx
progress-eta-link (ho.uva _ _ as X) T H H1 ff :- contract-rigid [] T T1, !, print "progress 4", ho.unif X T1 H H1. % TODO remove this link from Links
progress-eta-link _ _ H H tt :- print "no progress". % NO PROGRESS

type solve-link-abs linkabs -> option linkabs -> ho.subst -> ho.subst -> o.
solve-link-abs (ho.abs X) R H H1 :- 
  % print "solve-link-abs under abs",
  pi x\ (pi S\ ho.unif x x S S) => ho.copy x x => (pi S\ ho.deref S x x) => solve-link-abs (X x) (R' x) H H1,
  if ((R' x) = some (R'' x)) (R = some (ho.abs R'')) (R = none)
  .
solve-link-abs (ho.val (link-eta A B) as L) Keep S S1 :- !,
  print "In progress eta link for" {ho.pp A} {ho.pp B},
  progress-eta-link A B S S1 R,
  if (R = tt) (Keep = some L) (Keep = none).
  % print "finish progress". % TODO: remove link if L is no more an eta
% solve-link-abs (ho.val (link-fo-align Beta Head PF NPF) as L) (some L) S S1 :- 
%   ho.deref S (ho.uva Head {std.append PF NPF}) BetaHead,  rigid-head BetaHead, !,
%   ho.deref S (ho.uva Beta {std.append PF NPF}) BetaAss, ho.unif BetaHead BetaAss S S1.

solve-link-abs L _ _ _ :- fatal "solve-link-abs" L.
% % classic beta: the head of the application is rigid
% solve-links [link-fo-align V Hd_ T|L1] L2 S S2 :-
%   % if Hd is set then beta (note assmt-deref does the beta-redex)
%   ho.assmt-deref S T Ass2,  rigid-head Ass2, !,
%   print "Solve link beta",
%   if (set? V S Ass1) (print "ass1 is" Ass2, my-unif-assignment Ass1 Ass2 S S1) (assign V S Ass2 S1),
%   solve-links L1 L2 S1 S2.

% solve-links [link-fo-align V Hd_ T|L1] L2 S S2 :-
%   % TODO: if Hd is not set, the we do Fo-approx
%   ho.assmt-deref S T Ass2, (not (rigid-head Ass2)), !,
%   print "In second link fo align" Ass1 "et" Ass2,
%   % set? is always true, since before we have done a unif
%   if (set? V S Ass1) (
%     fo-align Ass2 Ass1 [] S S1
%   ) (print "It is not assigned?", assign V S Ass2 S1),
%   solve-links L1 L2 S1 S2.

% type solve-links links -> links -> ho.subst -> ho.subst -> o.
% solve-links [] [] S S.
% solve-links [A|As] Bs S S2 :-
%   solve-links A S S1,
%   solve-links As Bs S1 S2.
% solve-links [A|As] [A|Bs] S S1 :- solve-links As Bs S S1.

type link-occur-check links -> links -> ho.subst -> ho.subst -> o.
link-occur-check [] _ H H.
link-occur-check [link-abs A|L] Links H H2 :-
  link-abs-occur-check A Links H H1, link-occur-check L Links H1 H2.

type link-abs-occur-check linkabs -> links -> ho.subst -> ho.subst -> o.
link-abs-occur-check (ho.abs L) Links H H1 :- pi x\ (pi s\ ho.deref s x x :- !) => ho.copy x x => (pi h\ ho.unif x x h h) => link-abs-occur-check (L x) Links H H1.
link-abs-occur-check (ho.val (link-fo-align _ _ _ _)) _ H H.
link-abs-occur-check (ho.val (link-eta(ho.uva N0 S0) T)) Links H H1 :-
  ho.deref H (ho.uva N0 S0) (ho.uva N S), !,
  print "test OC" N0 "->" N "on" T "and" H,
  ho.deref H T T1, !,
%  ((lam-occur-check N Links T1 H, print "OC, no problem with" N, H1 = H) ; (print "OC error, force progress", force-progress (link-eta N S T1) H H1)).
  (lam-occur-check N Links T1 H T2, print "OC, progress", ho.unif {eta-expand (ho.uva N []) {len S}} T2 H H1) ; true. %TODO: in case OF fails we should fail
link-abs-occur-check (ho.val (link-eta N _)) _ H H :- print "OC skip" N.

type lam-occur-check addr -> links -> ho.tm -> ho.subst -> ho.tm -> o.
lam-occur-check _ _ (ho.con X) _ (ho.con X).
% lam-occur-check N Links (ho.app L) H H1 :- fold ... L.
lam-occur-check N Links (ho.lam F) H (ho.lam F1) :- pi x\ lam-occur-check N Links (F x) H (F1 x).
lam-occur-check N _Links (ho.uva N S) _H (ho.uva N S) :- !.
lam-occur-check N Links (ho.uva M S) H T :-
  exists (l\deref-link-occur-check l Links M S N H T) Links.

type deref-link-occur-check link -> links -> addr -> list ho.tm -> addr -> ho.subst -> ho.tm -> o.
% deref-link-occur-check (link M X LenX) Links M S N H T :-
%   if (LenX = s _) (halt "len" S) true,
%   lam-occur-check N Links (ho.uva X []) H T.
deref-link-occur-check (link-abs A) Links M S N H T :-
  deref-link-abs-occur-check A Links M S N H T.

type deref-link-abs-occur-check linkabs -> links -> addr -> list ho.tm -> addr -> ho.subst -> ho.tm -> o.
deref-link-abs-occur-check (ho.abs A) Links M [V|S] N H T :- deref-link-abs-occur-check (A V) Links M S N H T.
deref-link-abs-occur-check (ho.val (link-eta (ho.uva M _) T)) Links M S N H T3 :- !,
  print "OC follow " link-eta M "->" T,
  ho.deref H T T1,
  ho.beta T1 S T2,
  print "OC rec on" T2,
  lam-occur-check N Links T2 H T3.

:index(_ 1)
type deref-links ho.subst -> links -> links -> o.
deref-links _ [] [].
% deref-links H [link N M L|XS] [link N M L|YS] :- deref-links H XS YS.
deref-links H [link-abs A|XS] [link-abs A1|YS] :- std.assert! (deref-link-abs H A A1) "bug deref links", deref-links H XS YS.

type deref-link-abs ho.subst -> linkabs -> linkabs -> o.
deref-link-abs H (ho.abs F) (ho.abs G) :- pi x\ deref-link-abs H (F x) (G x).
deref-link-abs H (ho.val (link-eta A B)) (ho.val (link-eta A1 B1)) :-
  ho.deref H A A1, ho.deref H B B1.
deref-link-abs _ (ho.val (link-fo-align A B C D)) (ho.val (link-fo-align A B C D)).

% We test forall linked var of the ML, that they have the same assignment
type solve-links-fixpoint links -> links -> ho.subst -> ho.subst -> o.
solve-links-fixpoint L0 L2 H H2 :- std.do! [
  deref-links H L0 L, !,
  print "\nfixpoint iteration on:" {pplinks L}, !,
  solve-links L L1 H H1, !,
  %H1 = H0,
  %link-occur-check L1 L1 H0 H1, !,
  if (L = L1, H = H1)
     (print "end fixpoint", deref-links H L L2 , H2 = H)
     (print "## Subst is" {ho.ppsubst H1}, print "## Links are" {pplinks {deref-links H1 L1}}, !, solve-links-fixpoint L1 L2 H1 H2)
].
type make-eta-link nat -> nat -> addr -> addr -> list ho.tm -> linkabs -> o.
make-eta-link (s  X) z     M' M Vars L :- std.rev Vars Scope, eta-expand (ho.uva M Scope) (s X) T, make-eta-link.aux (s X) M' T Vars L.
make-eta-link (s  X) (s Y) M' M Vars L :- make-eta-link X Y M M' Vars L.
%make-eta-link (s  X) (s Y) M' M Vars (ho.abs x\ L x) :- pi x\ make-eta-link X Y M M' [x|Vars] (L x).
make-eta-link.aux z     M' T Vars (ho.val (link-eta (ho.uva M' Scope) T)) :- std.rev Vars Scope.
make-eta-link.aux (s X) M' T Vars L :- make-eta-link.aux X M' T Vars L.
% make-eta-link.aux (s X) M' T Vars (ho.abs L) :- pi x\ make-eta-link.aux X M' T [x|Vars] (L x).

type solve-links links -> links -> ho.subst -> ho.subst -> o.
solve-links [] [] X X :- print "end solve links".

% TODO: THIS IS TO CHECK BETTER
% solve-links [(link N M LenM as X)|L] LR HO HO1 :- take-list L (link N M' LenM') L1, not (unset? M HO, unset? M' HO), !, std.do! [
%   print "deduplicating links:" {pplink X} "===" {pplink (link N M' LenM')}, 
%   same-assign M M' LenM LenM' W HO HO2,
%   solve-links [link N W LenM|L1] LR HO2 HO1,
% ].

solve-links [link-abs A|L1] [link-abs A|L3] S S2 :- take-link-abs A L1 B L2, !, std.do! [
  print "deduplicating links:" {pplinkabs A} "===" {pplinkabs B}, 
  same-link-abs A B S S1, 
  solve-links L2 L3 S1 S2,
].

solve-links [link-abs L|L1] L3 S S2 :-
  print "considering link for progress:" {pplinkabs L},
  (solve-link-abs L R S S1), !,
  if (R = some L')
     (solve-links L1 L2 S1 S2, L3 = [link-abs L'|L2])
     (print {pplinkabs L} "is removed", solve-links L1 L3 S1 S2) .

type same-link-abs linkabs -> linkabs -> ho.subst -> ho.subst -> o.
same-link-abs (ho.abs F) B H H1 :- pi x\ same-link-abs (F x) B H H1.
same-link-abs A (ho.abs G) H H1 :- pi x\ same-link-abs A (G x) H H1.
same-link-abs (ho.val (link-eta (ho.uva N S1) A))
              (ho.val (link-eta (ho.uva N S2) B)) H H1 :- std.do! [
  std.assert! (std.length S1 {std.length S2}) "no same scope",
  std.map2 S1 S2 (x\y\r\ r = ho.copy x y) Perm,
  Perm => ho.copy A A',
  %print {ho.pp A'} "=?=" {ho.pp B},
  ho.unif A' B H H1,
].

% TODO:
type same-assign-aux nat -> nat -> ho.assignment -> ho.assignment -> ho.subst -> ho.subst -> o.
same-assign-aux L L T R HO HO2 :- !, my-unif-assignment T R HO HO2.
same-assign-aux _ _ T R HO HO2 :- 
  hope-for-eta HO T Te,
  hope-for-eta HO R Re,
  my-unif-assignment Te Re HO HO2.
 
type same-assign addr -> addr -> nat -> nat -> addr -> ho.subst -> ho.subst -> o.
same-assign M N LenM LenN W HO HO2 :- set? M HO AM, set? N HO AN, !, W = M,
  same-assign-aux LenM LenN AM AN HO HO2.
same-assign M N LenM LenN W HO HO2 :- set? M HO AM, unset? N HO,  W = M, eta LenN N [] AN, print "Eta for" N "is" AN,
  same-assign-aux LenM LenN AM AN HO HO2.
same-assign M N LenM LenN W HO HO2 :- unset? M HO, set? N HO AN,  W = N, eta LenM M [] AM, print "Eta for" M "is" AM,
  same-assign-aux LenM LenN AM AN HO HO2.
% same-assign M N LenM LenN W HO HO2 :- unset? M HO, unset? N HO,   W = M, eta LenN N [] AN, eta LenM M [] AM, print "Eta for" M "is" AM, print "Eta for" N "is" AN,
%   same-assign-aux LenM LenN AM AN HO HO2.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
%%% nel test 15 abbiamo
%%%   Len=1  x\ app[f,Y x]
%%%   Len=0  X
%%%
%%% il codice sotto (my-unif-assignment) fa X = a\ app[f,Y a]
%%% e cambia arietà a X che non va bene
%%%
%%% T = x\ app[f,Y x] deve essere di arità zero
%%% allora o il T coq è (lam x\ app[f,Y x]) oppure f
%%%
%%% sempre nel test 15, dopo con'è g = X
%%% ora falliamo perche g != (lam x\ app[f,Y x])
%%% penso che dire Y x = x non sia "il più generale"
%%%
%%% ora mi sa che fallisce perchè g != lam
%%% che è "sbagliato" (forse) perchè potrebbe anche avere
%%% successo assegnado Y (in quel momento, ma non lo possiamo
%%% fare prima, nelle varie link...)
%%%
%%% in pratica mi pare che o perdiamo generalità (e assegnamo Y presto)
%%% o ritardiamo, restiamo corretti, ma sequenza di successi/fallimenti
%%% non è fedele.
%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Invariant, the assmt in entry are never on the form `ho.val (ho.abs _)`
type my-unif-assignment-aux ho.assignment -> ho.assignment -> ho.subst -> ho.subst -> o.

my-unif-assignment-aux (ho.val T1) (ho.val T2) H H1 :- 
  print "@@@ Start unif between T1 and T2" T1 T2 "in" H, 
  (ho.unif T1 T2 H H1), 
  print "After unif" H H1.
my-unif-assignment-aux (ho.abs F1) (ho.abs F2) H H1 :- 
  pi x\ (pi S\ ho.unif x x S S) => ho.copy x x => my-unif-assignment-aux (F1 x) (F2 x) H H1.

my-unif-assignment-aux (ho.val T) (ho.abs F2) H H1 :-
  print "Enter aa",
  pi x\ sigma R\ unif-mk-app T x R, 
  (pi S\ ho.unif x x S S) => ho.copy x x => my-unif-assignment-aux (ho.val R) (F2 x) H H1,
  print "exit bb".

my-unif-assignment-aux (ho.abs F2) (ho.val T) H H1 :-
  pi x\ sigma R\ unif-mk-app T x R, 
  (pi S\ ho.unif x x S S) => ho.copy x x => my-unif-assignment-aux (F2 x) (ho.val R) H H1.

type lam->abs ho.assignment -> ho.assignment -> o.
lam->abs (ho.val (ho.lam T)) (ho.abs R) :- !, pi x\ lam->abs (ho.val (T x)) (R x).
lam->abs (ho.val A) (ho.val A).
lam->abs (ho.abs T) (ho.abs R) :- pi x\ lam->abs (T x) (R x).

type abs->lam ho.assignment -> ho.tm -> o.
abs->lam (ho.abs T) (ho.lam R)  :- !, pi x\ abs->lam (T x) (R x).
abs->lam (ho.val A) A.

type unif-mk-app ho.tm -> ho.tm -> ho.tm -> o.
unif-mk-app (ho.uva N L) T (ho.uva N R) :- appendR L [T] R.
unif-mk-app (ho.con C) T (ho.app [ho.con C, T]).
unif-mk-app (ho.app L) T (ho.app R) :- appendR L [T] R.

type my-unif-assignment ho.assignment -> ho.assignment -> ho.subst -> ho.subst -> o.
my-unif-assignment T R S1 S2 :-
  ho.assmt-deref S1 T TDeref,
  ho.assmt-deref S1 R RDeref,
  % lam->abs TDeref TAbs,
  % lam->abs RDeref RAbs,
  TAbs = TDeref, RAbs = RDeref,
  print "Start of unification aux between" TAbs "and" RAbs,
  print "In substitution" S1,
  (my-unif-assignment-aux TAbs RAbs S1 S2).

type hope-for-eta  ho.subst -> ho.assignment -> ho.assignment -> o.
hope-for-eta H A1 A2 :-
  ho.assmt-deref H A1 A1Deref,
  hope-for-eta1 A1Deref A2.

% tries to eta contract at each "depth", not just at the top
type hope-for-eta1 ho.assignment -> ho.assignment -> o.
hope-for-eta1 (ho.abs _ as F) G :- hope-contract [] F G.
hope-for-eta1 (ho.abs F) (ho.abs G) :- pi x\ hope-for-eta1 (F x) (G x).
hope-for-eta1 (ho.val T) (ho.val T).

% given x\y\z\... it tries to contract against xyz, then xy, then x
type hope-contract list ho.tm -> ho.assignment -> ho.assignment -> o.
hope-contract L (ho.abs F) T :- pi x\ hope-contract [x|L] (F x) T.
hope-contract L (ho.abs F) T :- pi x\ hope-contract.aux [x|L] (F x) T.

% checks if the term is xxx\ yyy\ app[...|xxx] -> yyy\ app[...]
type hope-contract.aux list ho.tm -> ho.assignment -> ho.assignment -> o.
hope-contract.aux L (ho.abs F) (ho.abs G) :- pi x\ hope-contract.aux L (F x) (G x).
hope-contract.aux L (ho.val V) (ho.val T) :- std.do! [
  V = ho.app[Hd|Args],
  std.rev L LRev,
  std.appendR Prefix LRev Args,
  if (Prefix = []) (T = Hd) (T = ho.app [Hd|Prefix]),
].

% [eta Arity VarName Acc Ass]
type eta nat -> addr -> list ho.tm -> ho.assignment -> o.
eta z     N Acc (ho.val (ho.uva N Acc')) :- std.rev Acc Acc'.
eta (s M) N Acc (ho.abs F) :- pi x\ eta M N [x | Acc] (F x).

type take-list list A -> A -> list A -> o.
take-list [L|XS] L XS.
take-list [L|XS] L' [L|YS] :- not(L = L'), take-list XS L' YS.

type take-link-abs linkabs -> links -> linkabs -> links -> o.
take-link-abs A [link-abs B|XS] B XS :- link-abs-same-lhs A B, !.
take-link-abs A [L|XS] B [L|YS] :- take-link-abs A XS B YS.

type link-abs-same-lhs linkabs -> linkabs -> o.
link-abs-same-lhs (ho.abs F) B :- pi x\ link-abs-same-lhs (F x) B.
link-abs-same-lhs A (ho.abs G) :- pi x\ link-abs-same-lhs A (G x).
link-abs-same-lhs (ho.val (link-eta (ho.uva N _) _)) (ho.val (link-eta (ho.uva N _) _)).

type decompl-eta-aux linkabs -> ho.subst -> ho.subst -> list ho.tm -> o.
decompl-eta-aux (ho.val (link-eta T1 T2)) H H1 _ :- ho.unif T1 T2 H H1.
decompl-eta-aux (ho.abs B) H H1 L :- pi x\ decompl-eta-aux (B x) H H1 [x|L].

type decompl-eta links -> links -> ho.subst -> ho.subst -> o.
decompl-eta [] [] H H.
decompl-eta [link-abs Abs| Links] L H H2 :- decompl-eta-aux Abs H H1 [], !, decompl-eta Links L H1 H2.
decompl-eta [Hd | Tl] [Hd | L] H H1 :- decompl-eta Tl L H H1.

type put-abs nat -> ho.tm -> ho.assignment -> o.
put-abs z T (ho.val T).
put-abs (s N) T (ho.abs B) :- pi x\ sigma T'\ ho.beta T [x] T', put-abs N T' (B x).

% Invariant: links are only on the form (link VO VM Arity), each VO appears once and each VM appears once
type decompl-mapping mappings -> mappings -> ho.subst -> fo.subst -> fo.subst -> o.
decompl-mapping _ [A|_] _ _ _ :- print "Solving" {ppmapping A}, fail.
decompl-mapping _ [] _ F F.
decompl-mapping Map [mapping (fv VO) (hv VM _)|Tl] H F F2 :- set? VM H T, !, % TODO: is the res of set? always a val?
  print {ho.ppsubst H} {ho.ppass T},
  std.assert!((ho.assmt-deref H T TTT)) "Should not fail",
  abs->lam TTT T', decomp Map T' T1, fo.eta-contract T1 T2, assign VO F T2 F1,
  decompl-mapping Map Tl H F1 F2. 
decompl-mapping Map [mapping _ (hv VM _)|Tl] H F F2 :- unset? VM H, decompl-mapping Map Tl H F F2.
decompl-mapping _ [L|_] H _ _ :- halt "Decompl mapping: failed on" {ppmapping L} {ho.ppsubst H}.

type decomp mappings -> ho.tm -> fo.fm -> o.
decomp _ (ho.con C)  (fo.fcon C).
decomp L (ho.lam B1) (fo.flam B2) :- pi x y\ decomp _ x y => decomp L (B1 x) (B2 y).
decomp L (ho.app L1) T :-
  forall2 (decomp L) L1 [Hd|Tl],
  fo.mk-app Hd Tl T.
decomp L (ho.uva VM TL) T :-
  forall2 (decomp L) TL T1,
  std.assert! (len {std.findall (mem L (mapping (fv VO) (hv VM _)))} (s z)) "Sanity check decompl1",
  fo.mk-app (fo.fuva VO) T1 T.
decomp L H _ :- halt "Fail in decomp" {ppmappings L} {ho.pp H}.

type add-new-links-aux ho.subst -> list ho.tm -> mappings -> mappings ->  fo.subst -> fo.subst -> o.
add-new-links-aux _ [] _ [] S S.
add-new-links-aux H [T|Ts] L L2 S S2 :- add-new-link H T L L1 S S1, add-new-links-aux H Ts L1 L2 S1 S2.

type add-new-link ho.subst -> ho.tm -> mappings -> mappings ->  fo.subst -> fo.subst -> o.
add-new-link _ (ho.uva N _) Links [] F1 F1 :- mem Links (mapping _ (hv N _)), !.
add-new-link H (ho.uva N L) Links [Link1 | Links1] F1 F3 :-              % Build new link
  mem-new F1 M F2,
  len L Arity, Link1 = mapping (fv M) (hv N (arity Arity)),
  add-new-link H (ho.app L) [Link1 | Links] Links1 F2 F3.
add-new-link H (ho.lam B) Links NewLinks F1 F2 :- pi x\ add-new-link H (B x) Links NewLinks F1 F2.
add-new-link H (ho.app L) Links NewLinks F1 F3 :- add-new-links-aux H L Links NewLinks F1 F3.
add-new-link _ (ho.con _) _ [] F F :- !.
add-new-link _ N _ [] F F :- name N.

type add-new-link-ass ho.subst -> ho.assignment -> mappings -> mappings ->  fo.subst -> fo.subst -> o.
add-new-link-ass H (ho.val Val) Links1 Links2 F1 F2 :- add-new-link H Val Links1 Links2 F1 F2.
add-new-link-ass H (ho.abs Abs) Links1 Links2 F1 F2 :- pi x\ add-new-link-ass H (Abs x) Links1 Links2 F1 F2.

type complete-link ho.subst -> ho.subst -> mappings -> mappings -> fo.subst -> fo.subst -> o.
complete-link _ [] L L F F.
complete-link H [none | Tl] L1 L2 F1 F2 :- complete-link H Tl L1 L2 F1 F2.
complete-link H [some T0 | Tl] L1 L3 F1 F3 :-
  ho.assmt-deref H T0 T,
  add-new-link-ass H T L1 L2 F1 F2, 
  std.append L1 L2 LAll,
  complete-link H Tl LAll L3 F2 F3.

type decompl mappings -> links -> ho.subst -> fo.subst -> fo.subst -> o.
decompl Map1 L HO FO FO2 :- std.do! [
  decompl-eta L L1_ HO HO1,                                                          % L1 conaints no link-eta (it may contain beta)
  print "# After decompl-eta, subst is" {ho.ppsubst HO1} "with links" {pplinks L1_},
  complete-link HO1 HO1 Map1 Map2 FO FO1,                                            % Foreach VM not mapped to OL, we build a link
  print "# After complete-link, mappings are" {ppmappings Map2} "with ho-subst" {ho.ppsubst HO1}, 
  decompl-mapping Map2 Map2 HO1 FO1 FO2,
].

type test-hope-eta-1 o.
type test-hope-eta-2 o.
type test-hope-eta-3 o.
type test-hope-eta-4 o.
type test-hope-eta-5 o.
type test-hope-eta-6 o.
test-hope-eta-1 :- hope-for-eta [] (ho.abs x\ ho.abs y\ ho.val (ho.app[ho.con"f",ho.app[ho.con"g",x],y]))
                                   (ho.abs x\           ho.val (ho.app[ho.con"f",ho.app[ho.con"g",x]  ])).
test-hope-eta-2 :- hope-for-eta [] (ho.abs x\ ho.abs y\ ho.val (ho.app[ho.con"f",ho.app[ho.con"g",y],x]))
                                   (          ho.abs y\ ho.val (ho.app[ho.con"f",ho.app[ho.con"g",y]  ])).
test-hope-eta-3 :- hope-for-eta [] (ho.abs x\ ho.abs y\ ho.val (ho.uva (addr z) [y]))
                                   (ho.abs x\           ho.val (ho.uva (addr z) [])).
test-hope-eta-4 :- hope-for-eta [] (ho.abs x\ ho.abs y\ ho.val (ho.uva (addr z) [x]))
                                   (          ho.abs y\ ho.val (ho.uva (addr z) [])).
test-hope-eta-5 :- hope-for-eta [] (ho.abs x\ ho.abs y\ ho.val (ho.uva (addr z) [x, y]))
                                   (ho.val (ho.uva (addr z) [])).
test-hope-eta-6 :- hope-for-eta [] (ho.abs x\ ho.abs y\ ho.val (ho.uva (addr z) [y, x]))
                                   (ho.abs x\ ho.abs y\ ho.val (ho.uva (addr z) [y, x])).
}