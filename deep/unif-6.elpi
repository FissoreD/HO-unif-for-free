internal-test try6.comp.test-hope-eta-1.
internal-test try6.comp.test-hope-eta-2.
% internal-test try6.comp.test-hope-eta-3.
% internal-test try6.comp.test-hope-eta-4.
% internal-test try6.comp.test-hope-eta-5.
% internal-test try6.comp.test-hope-eta-6.
internal-test try6.ho.test-unif-1.
internal-test try6.ho.test-unif-2.
internal-test try6.ho.test-unif-3.
internal-test try6.ho.test-unif-4.
internal-test try6.ho.test-unif-5.
internal-test try6.ho.test-unif-6.

namespace try6 {

%%%%%%%%%%%%%%%%%%% the OL %%%%%%%%%%%%%%%%%%%%%
namespace fo {

% Common terms
kind fm type.
type fapp list fm -> fm.
type flam (fm -> fm) -> fm.
type fcon string -> fm.
type fuva  nat -> fm.

typeabbrev subst list (option fm).

type deref subst -> fm -> fm -> o.
deref _ X _ :- var X, fatal "flex deref".
deref S (fuva N) T1 :- set? N S T, deref S T T1.
deref S (fapp [fuva N|L]) R :- set? N S T, !, beta T L R', deref S R' R.
deref S (fapp L1) (fapp L2) :- forall2 (deref S) L1 L2.
deref S (flam F1) (flam F2) :- pi x\ deref S x x => deref S (F1 x) (F2 x).
deref _ (fcon X) (fcon X).
deref _ (fuva N) (fuva N).
deref _ N N :- name N.
% deref A B V :- var V, fatal "This is should be an error" B A.

% [equal T1 T2] check if two terms are equal for the OL
type (==o) fm -> fm -> o.

X ==o Y :- (var X ; var Y), fatal "flex equal". % chekc to prevent implem errors
fapp L1 ==o fapp L2 :- forall2 (==o) L1 L2.
flam F1 ==o flam F2 :- pi x\ x ==o x => F1 x ==o F2 x.
fcon X ==o fcon X.
fuva N ==o fuva N.
flam F ==o T :- pi x\ beta T [x] (T' x), x ==o x => F x ==o T' x.
T ==o flam F :- pi x\ beta T [x] (T' x), x ==o x => T' x ==o F x.
fapp [flam X | TL] ==o T :- beta (flam X) TL T', T' ==o T.
T ==o fapp [flam X | TL] :- beta (flam X) TL T', T ==o T'.

% [extend-subst T S S'] forall fuva N in T, extends S with none at pos N
% this is used only in test to build the subst-map before running it
type extend-subst fm -> subst -> subst -> o.
extend-subst (fuva N) S S' :- extend-nat N S S'.
extend-subst (flam F) S S' :- pi x\ (pi S\extend-subst x S S) => extend-subst (F x) S S'.
extend-subst (fcon _) S S.
extend-subst (fapp L) S S1 :- fold extend-subst L S S1.

% aux function for extend-subst
type extend-nat nat -> subst -> subst -> o.
extend-nat z X Y :- std.append X [none] Y.
extend-nat (s N) [] [none | M] :- extend-nat N [] M.
extend-nat (s N) [X | L] [X | M] :- extend-nat N L M.

type beta fm -> list fm -> fm -> o.
beta A [] A.
beta (flam Bo) [H | L] R :- beta (Bo H) L R.
beta (fapp A) L (fapp X) :- std.append A L X.
beta (fuva N) L (fapp [fuva N | L]).
beta (fcon H) L (fapp [fcon H | L]).

% [new S N S'] returns a new free variable N in S' = S @ [none]
type new subst -> nat -> subst -> o.
new [] z [none].
new [X|XS] (s N) [X|YS] :- new XS N YS.

type mk-app fm -> list fm -> fm -> o.
mk-app T L S :- beta T L S.

type eta-contract fm -> fm -> o.
eta-contract (fcon X) (fcon X).
eta-contract (fapp L) (fapp L1) :- forall2 eta-contract L L1.
eta-contract (flam F) T :- contract [] (flam F) T.
eta-contract (flam F) (flam F1) :- pi x\ eta-contract x x => eta-contract (F x) (F1 x).
eta-contract (fuva X) (fuva X).
eta-contract X X :- name X.

type contract list fm -> fm -> fm -> o.
contract L (flam F) T :- 
  pi x\ contract [x|L] (F x) T. % also checks H Prefix does not see x
contract L (fapp [H|Args]) T :- 
  std.rev L LRev, std.appendR Prefix LRev Args,
  if (Prefix = []) (T = H) (T = fapp [H|Prefix]).

}

%%%%%%%%%%%%%%%%%%% the ML %%%%%%%%%%%%%%%%%%%%%

namespace ho {

typeabbrev subst list (option assignment).

kind inctx type -> type.
type abs (tm -> inctx A) -> inctx A.
type val A -> inctx A.

typeabbrev assignment (inctx tm).

kind tm  type.
type app list tm -> tm.
type lam (tm -> tm) -> tm.
type con string -> tm.
type uva  nat -> list tm -> tm.

% [unif T1 T2 SOld SNew] check if T1 and T2 unify looking into SOld. SNew is the final substution
type unif tm -> tm -> subst -> subst ->  o.
unif A B _ _ :- print "--------------" A B, fail.
% Base cases
unif (app L1) (app L2) S S1 :- fold2 unif L1 L2 S S1.
unif (lam F1) (lam F2) S S1 :- 
  pi x\ (pi S\ unif x x S S) => copy x x => unif (F1 x) (F2 x) S S1.
unif (con X) (con X) S S.
% Assigned variables
unif (uva N Args) T S S1 :- 
  set? N S F,!, move F Args T1, unif T1 T S S1.
unif T (uva N Args) S S1 :- 
  set? N S F,!, print "In set branch", move F Args T1, print "after move" F Args T1, unif T T1 S S1.
% Not assigned vars
unif (uva N A) (uva N A) S S :- !, pattern-fragment A.
unif (uva V A) (uva U A) S1 S2 :- !, pattern-fragment A,
  prune-same-args V A [] Ass, assign U S1 Ass S2.
unif (uva N Args1) (uva N Args2) S S2 :- % same var 
  unset? N S,
  std.assert!(len Args1 Len, len Args2 Len) "Not typechecking", !, % the length of args must be the same
  pattern-fragment Args1, pattern-fragment Args2, 
  std.do![new S W S1, prune-same-variable W Args1 Args2 Ass, 
  assign N S1 Ass S2],
  print "Assigning in uva N Args1" N S1 Ass S2. 
unif (uva N Args1) (uva M Args2) S S3 :- % Args with diff length
  unset? N S, unset? M S, !,
  print "Unifying" (uva N Args1) "and" (uva M Args2),
  pattern-fragment Args1, pattern-fragment Args2, 
  new S W S1, (prune-smart W Args1 Args2 Ass1 Ass2), 
  std.do![
  assign N S1 Ass1 S2,
  (N = M; assign M S2 Ass2 S3)]
  % print "Assigning in uva with diff len" N M S1 "with solution" Ass1 "and" Ass2 "in subst" S3
  . 
unif (uva N Args) T S S1 :- 
  not (T = uva _ _), not_occ N S T, pattern-fragment Args, 
  bind T Args T1, print "Binding T to Args" T Args T1, assign N S T1 S1, print "Assing1" N "to" T1.
% TODO: we could unify (f c0) with X, this does not work since c0 is a name
unif T (uva N Args) S S1 :- 
  print "Unif complex:" T (uva N Args),
  std.do![not (T = uva _ _), not_occ N S T, pattern-fragment Args, 
  bind T Args T1,print "Binding T to Args" T Args T1,  assign N S T1 S1, print "Assing2 T2" T1].

% Note: eta & beta for unification is not allowed in ML over terms of the OL

% prune in the case of same argumets for the two vars (e.g. uv X L and uv Y L)
type prune-same-args nat -> list tm -> list tm -> assignment -> o.
prune-same-args N [] Acc (val (uva N Args)) :- std.rev Acc Args.
prune-same-args N [_ | B] L (abs T) :- pi x\ prune-same-args N B [x | L] (T x).

% prune in the case of vars with args of same length (e.g. uv X L1, uv Y L2, len L1 = len L2)
type prune-same-variable nat -> list tm -> list tm -> assignment -> o.
prune-same-variable N A1 A2 T :- prune-same-variable-aux N A1 A2 [] T.

type prune-same-variable-aux nat -> list tm -> list tm -> list tm -> assignment -> o.
prune-same-variable-aux N [] [] ACC (val (uva N Args)) :- std.rev ACC Args.
prune-same-variable-aux N [X|XS] [X|YS] ACC (abs F) :- pi x\ prune-same-variable-aux N XS YS [x|ACC] (F x).
prune-same-variable-aux N [_|XS] [_|YS] ACC (abs F) :- pi x\ prune-same-variable-aux N XS YS ACC (F x).

type prune-diff-length-aux nat -> list tm -> list tm -> assignment -> o.
prune-diff-length-aux N [] Acc (val (uva N Acc)).
prune-diff-length-aux N [_|L] Acc (abs T) :- pi x\ prune-diff-length-aux N L Acc (T x).

% res = argomenti dell'altro se li vedo anche io (nell'ordine dell'altro)
type prune-diff-length nat -> list tm -> list tm -> list tm -> assignment -> assignment -> o.
prune-diff-length N [] Args2 Acc (val (uva N Args)) Ass2 :-  !,
  std.rev Acc Args, prune-diff-length-aux N Args2 Args Ass2.
prune-diff-length N Args1 [] Acc Ass1 (val (uva N Args)) :- !,
  std.rev Acc Args, prune-diff-length-aux N Args1 Args Ass1.
prune-diff-length N [X|XS] [X|YS] ACC (abs F) (abs G) :- pi x\ prune-diff-length N XS YS [x|ACC] (F x) (G x).
prune-diff-length N [_|XS] [_|YS] ACC (abs F) (abs G):- pi x\ prune-diff-length N XS YS ACC (F x) (G x).
prune-diff-length A B C D _ _:- fatal "Prune error" A B C D.

type keep list A -> A -> bool -> o.
keep L A tt :- mem L A, !.
keep _ _ ff.

type prune-build-ass1 nat -> list tm -> list bool -> assignment -> o.
prune-build-ass1 N Acc [] (ho.val (uva N Args)) :- std.rev Acc Args.
prune-build-ass1 N Acc [tt|L] (ho.abs T) :- pi x\ prune-build-ass1 N [x|Acc] L (T x).
prune-build-ass1 N Acc [ff|L] (ho.abs T) :- pi x\ prune-build-ass1 N Acc L (T x).

type list-init nat -> nat -> (nat -> A -> o) -> list A -> o.
list-init Len Len _ [].
list-init Len Pos F [A | TL] :- F Pos A, list-init Len (s Pos) F TL.

type index list A -> A -> nat -> o.
index [A|_] A z :- !.
index [_|TL] A (s P) :- index TL A P.

type nth nat -> list A -> A -> o.
nth z [A|_] A :- !.
nth (s N) [_|L] A :- !, nth N L A.

type build-order list nat -> list tm -> list tm -> o.
build-order L T R :-
  len L Len, list-init Len z (p\r\ sigma Index Elt\ index L p Index, nth Index T r) R.

type prune-build-ass2 nat -> list tm -> list bool -> list nat -> assignment -> o.
prune-build-ass2 N Acc [] Pos (ho.val (uva N Args)) :- std.rev Acc Acc', build-order Pos Acc' Args.
prune-build-ass2 N Acc [tt|L] Pos (ho.abs T) :- pi x\ prune-build-ass2 N [x|Acc] L Pos (T x).
prune-build-ass2 N Acc [ff|L] Pos (ho.abs T) :- pi x\ prune-build-ass2 N Acc L Pos (T x).

type prune-smart nat -> list tm -> list tm -> assignment -> assignment -> o.
prune-smart N Args1 Args2 Ass1 Ass2 :-
  std.do![std.map Args1 (keep Args2) Bits1, prune-build-ass1 N [] Bits1 Ass1,
  std.map Args2 (keep Args1) Bits2, 
  std.filter Args1 (mem Args2) ToKeep1,
  std.filter Args2 (mem Args1) ToKeep2,
  std.map ToKeep2 (index ToKeep1) Pos,
  prune-build-ass2 N [] Bits2 Pos Ass2].

type move assignment -> list tm -> tm -> o.
move (abs Bo)        [H|L] R :- move (Bo H) L R.
move (val A)         []    A :- !.
% move (val (app A))   L     (app X) :- std.append A L X.
move (val (uva N A)) L     (uva N X) :- std.append A L X.
% move (val (con H))   L     (app [con H | L]).
 move (abs _)         []    _ :- fatal "Invalid move call: too few args for abs".
 move A               L    _ :- fatal "Invalid move call:" A L.

type move-ass assignment -> list tm -> assignment -> o.
move-ass (abs Bo)        [H|L] R :- move-ass (Bo H) L R.
move-ass (abs Bo)        []    (abs Bo).
move-ass (val A)         []    (val A).
move-ass (val (app A))   L     (val (app X)) :- std.append A L X.
move-ass (val (uva N A)) L     (val (uva N X)) :- std.append A L X.
move-ass (val (con H))   L     (val (app [con H | L])).

type beta tm -> list tm -> tm -> o.
beta A [] A.
beta (lam Bo) [H | L] R :- beta (Bo H) L R.
beta (app A) L (app X) :- std.append A L X.
beta (uva N A) L (uva N A') :- std.append A L A'.
beta (con H) L (app [con H | L]).

type not_occ_aux nat -> subst -> tm -> o.
not_occ_aux N S (uva M _) :- std.do![unset? M S, diff N M].
not_occ_aux N S (uva M Args) :- std.do![set? M S F, move F Args T, not_occ_aux N S T].
not_occ_aux N S (app L) :- forall1 (not_occ_aux N S) L.
not_occ_aux N S (lam F) :- pi x\ /*not_occ_aux N S x =>*/ not_occ_aux N S (F x).
not_occ_aux _ _ (con _).
not_occ_aux _ _ X :- name X.
 
type not_occ  nat -> subst -> tm -> o.
% not_occ N S T :- print "not occ" N S T, fail.
not_occ N _ (uva N _).
not_occ N S (uva M Args) :- set? M S F, move F Args T, not_occ N S T.
not_occ N S (uva M Args) :- unset? M S, std.forall Args (not_occ_aux N S).
not_occ _ _ (con _).
not_occ N S (app L) :- not_occ_aux N S (app L).
not_occ N S (lam L) :- pi x\ not_occ N S (L x).
not_occ _ _ X :- name X.

type copy tm -> tm -> o.
copy (app L)   (app L') :- forall2 copy L L'.
copy (lam T)   (lam T') :- pi x\ copy x x => copy (T x) (T' x).
copy (uva N L) (uva N L') :- forall2 copy L L'.
copy (con C)   (con C).
copy N N :- not(scope-check), name N.

type scope-check o.


type bind tm -> list tm -> assignment -> o.
bind T [] (val T') :- scope-check => copy T T'.
bind T [X | TL] (abs T') :- pi x\ copy X x => bind T TL (T' x).

type new subst -> nat -> subst -> o.
new [] z [none].
new [X|XS] (s N) [X|YS] :- new XS N YS.

type unif-assignment assignment -> assignment -> subst -> subst -> o.
unif-assignment (val T1) (val T2) H H1 :- unif T1 T2 H H1.
unif-assignment (abs F1) (abs F2) H H1 :- pi x\ (pi S\ unif x x S S) => ho.copy x x => unif-assignment (F1 x) (F2 x) H H1.

type deref subst -> tm -> tm -> o.
deref H (uva N L)  X         :- set? N H T, move T L X', !, deref H X' X.
deref H (app L)   (app L1)   :- forall2 (deref H) L L1.
deref _ (con X)   (con X).
deref H (uva X L) (uva X L1) :- unset? X H, forall2 (deref H) L L1.
deref H (lam F)   (lam G)    :- pi x\ deref H (F x) (G x).
deref _ N         N          :- name N.
% deref A B V :- var V, fatal "This is should be an error" B A.

type assmt-deref subst -> assignment -> assignment -> o.
assmt-deref S (abs T) (abs R) :-
  pi x\ assmt-deref S (T x) (R x).
assmt-deref S (val T) (val R) :-
  deref S T R.


type eta-contract tm -> tm -> o.
eta-contract (con X)   (con X).
eta-contract (app L)   (app L1)   :- forall2 eta-contract L L1.
eta-contract (lam F)   T          :- contract [] (lam F) T.
eta-contract (lam F)   (lam F1)   :- pi x\ eta-contract x x => eta-contract (F x) (F1 x).
eta-contract (uva X L) (uva X L1) :- forall2 eta-contract L L1.
eta-contract X X :- name X.

type contract list tm -> tm -> tm -> o.
contract L (lam F) T :- 
  pi x\ contract [x|L] (F x) T. % also checks H Prefix does not see x
contract L (app [H|Args]) T :- 
  std.rev L LRev, std.appendR Prefix LRev Args,
  if (Prefix = []) (T = H) (T = app [H|Prefix]).
contract L (uva H Args) (uva H Prefix) :- 
  std.rev L LRev, std.appendR Prefix LRev Args.


type test-unif-1 o.
type test-unif-2 o.
type test-unif-3 o.
type test-unif-4 o.
type test-unif-5 o.
type test-unif-6 o.
test-unif-1 :- pi x\
  unif (uva z [x]) (uva (s z) []) [none, none] L,
  Z = (abs x\ val (uva X [])),
  SZ = val (uva X []),
  L = [some Z, some SZ|_].

test-unif-2 :- pi x y\
  unif (uva z [x, y]) (uva (s z) [y]) [none, none] L,
  Z = (abs x\ abs y\ val (uva X [y])),
  SZ = (abs x\ val (uva X [x])),
  L = [some Z, some SZ|_].

test-unif-3 :- pi x y w\
  unif (uva z [x, y]) (uva (s z) [x, w, y]) [none, none] L,
  Z = (abs x\ abs y\ val (uva X [x, y])),
  SZ = (abs x\ abs y\ abs z\ val (uva X [x, z])),
  L = [some Z, some SZ|_].

test-unif-4 :- pi x y\ 
  unif (uva z [x, y]) (uva (s z) [y, x]) [none, none] L,
  Z = (abs x\ abs y\ val (uva X [x, y])),
  SZ = (abs x\ abs y\ val (uva X [y, x])),
  L = [some Z, some SZ|_].

test-unif-5 :- pi x y zz w\
  unif (uva z [x, w, y]) (uva (s z) [y, zz, w]) [none, none] L,
  Z = (abs c0\ abs c1\ abs c2\ val (uva X [c1, c2])),
  SZ = (abs c0\ abs c1\ abs c2\ val (uva X [c2, c0])),
  L = [some Z, some SZ|_].

test-unif-6 :- pi x y zz w\
  unif (uva (s z) [y, zz, w]) (uva z [x, w, y]) [none, none] L,
  Z = (abs c0\ abs c1\ abs c2\ val (uva X [c2, c1])),
  SZ = (abs c0\ abs c1\ abs c2\ val (uva X [c0, c2])),
  L = [some Z, some SZ|_].
}

namespace comp {

shorten fo.{ (==o) }.

typeabbrev scope (list ho.tm).

kind linkctx type.
% type link-fo-align list ho.tm -> nat -> nat -> nat -> link.
type link-eta nat -> scope -> ho.tm -> linkctx.
% [link-fo-align Beta HeadVar PFvars NPFvars]
type link-fo-align nat -> nat -> scope -> scope -> linkctx.

typeabbrev linkctx1 (ho.inctx linkctx).

kind link type.
type link-abs linkctx1 -> link.
type link nat -> nat -> nat -> link.

% [maybe-eta-aux N T] takes a name N and a term T.
% return if T could be an eta expansion if T = app L and the last
% arg T of L can be reduced to N : T is either N or a Uvar seeing N
type maybe-eta-aux fo.fm -> fo.fm -> o.
maybe-eta-aux N N.
maybe-eta-aux N (fo.fapp[fo.fuva _|L]) :- !, mem L N.
maybe-eta-aux N (fo.flam B) :- !, pi x\ maybe-eta-aux N (B x).
maybe-eta-aux N (fo.fapp L) :-
  last L T, maybe-eta-aux N T.

type locale ho.tm -> o.
type get-scope ho.tm -> list ho.tm -> o.
get-scope (ho.con _) [].
get-scope (ho.uva _ L) L1 :- fold (x\y\r\ sigma R\ get-scope x R, std.append y R r) L [] L1.
get-scope (ho.lam B) L1 :- pi x\ locale x => get-scope (B x) L1.
get-scope (ho.app L) L1 :- fold (x\y\r\ sigma R\ get-scope x R, std.append y R r) L [] L1.
get-scope X [X] :- name X, not (locale X).
get-scope X [] :- name X, (locale X).

type close-links (ho.tm -> list link) -> list link -> o.
close-links (_\[]) [].
close-links (v\[link N M A|XS v]) [link N M A|YS] :- close-links XS YS.
close-links (v\[link-abs L|XS v]) [link-abs L|YS] :- !, close-links XS YS.
close-links (v\[link-abs(L v)|XS v]) [link-abs(ho.abs L)|YS] :- !, close-links XS YS.

type comp-lam (fo.fm -> fo.fm) -> (ho.tm -> ho.tm) -> list link -> list link -> ho.subst -> ho.subst -> o.
comp-lam F F1 L L2 S S1 :-
  pi x y\ (pi A S\ comp x y A A S S) => comp (F x) (F1 y) L (L1 y) S S1, close-links L1 L2.

type comp fo.fm -> ho.tm -> list link -> list link -> ho.subst -> ho.subst -> o.
comp (fo.fcon X)              (ho.con X) L L S S.
% TODO: this is wrong, since we should pass something in the scope of W
comp (fo.flam F) (ho.uva E0 Scope) L L2 S S2 :- print "EEEEEEEE with" F,
  (pi x\ not (F x = x), (maybe-eta-aux x (F x))), !,
  std.do![
    ho.new S E0 S1,
    comp-lam F F1 L L1 S1 S2,
    names N,
    (pi x\ locale x => get-scope (F1 x) ScopeDuplicata), 
    std.filter N (mem ScopeDuplicata) Scope,
    % hack
    % (
    %   (F1 = (x\ho.uva _ [V1,x]), Scope = [V1]) ;
    %   (F1 = (x\ho.uva _ [V1,V2,x]), Scope = [V1,V2]) ;
    %   (F1 = (x\ho.uva _ [x, V1]), Scope = [V1]) ; % TODO this is needed for test 10
    %   % (F1 = (x\ho.app[ho.con _,uva ...V1,V2,x]), Scope = [V1,V2]) ;
    %   Scope = []),
  ], L2 = [link-abs (ho.val(link-eta E0 Scope (ho.lam F1))) | L1], % TODO save Scope in E0, somehow
  print "------------------ END ETA -------------------",
  print "with new link: " link-eta E0 (ho.val (ho.lam F1)),
  print "----------------------------------------------".

comp (fo.flam F) (ho.lam F1) L L2 S S1 :- comp-lam F F1 L L2 S S1.
comp (fo.fuva N)              (ho.uva M []) L L1 S S1 :- alloc L L1 N M z S S1.
comp (fo.fapp [fo.fuva N|Ag]) (ho.uva MM PF1) L L3 S S4 :- !,
  split-pf Ag PF NPF,
  fold4 comp PF PF1 L L S S1,
  fold4 comp NPF NPF1 L L1 S1 S2,
  len PF Len,
  alloc L1 L2 N M Len S2 S3, % ho.new S2 M S3,
  % TODO: NYI NPF1 can contain non-closed terms (i.e. local vars...)
  if (NPF = []) (L3 = L2, S3 = S4, MM = M) 
    ( ho.new S3 MM S4,
      L3 = [link-abs(ho.val(link-fo-align MM M PF1 NPF1)) | L2])
  .
comp (fo.fapp A)              (ho.app A1) L L1 S S1 :- fold4 comp A A1 L L1 S S1.

type alloc list link -> list link -> nat -> nat -> nat -> ho.subst -> ho.subst -> o.
alloc Links Links N M Len H H :- std.mem Links (link N M Len), !.
alloc Links [link N M Len|Links] N M Len H H1 :- ho.new H M H1.
  

type eta-contract-ass ho.assignment -> ho.assignment -> o.
eta-contract-ass (ho.abs F) (ho.abs G) :- pi x\ eta-contract-ass (F x) (G x).
eta-contract-ass (ho.val T) (ho.val T1) :- ho.eta-contract T T1.

type rigid-head ho.tm -> o.
rigid-head (ho.lam X) :- !, pi x\ rigid-head (X x).
rigid-head T :- not (T = ho.uva _ _).

type fo-align ho.assignment -> ho.assignment -> list ho.tm -> ho.subst -> ho.subst -> o.
fo-align (ho.val(ho.uva N Args1)) (ho.val(ho.app Args2)) L_ S S1 :-
  appendR [Hd|Tl] Args1 Args2,
  ho.beta Hd Tl T,
  my-unif-assignment (ho.val (ho.uva N [])) (ho.val T) S S1.
fo-align (ho.abs X) (ho.abs Y) L S S1 :- pi x\
  (pi S\ ho.unif x x S S) => fo-align (X x) (Y x) [x|L] S S1.
fo-align A B S _ _ :- fatal "FO_align" A B S.

type count->lam ho.tm -> nat -> o.
count->lam (ho.lam B) (s X) :- !, pi x\ count->lam (B x) X.
count->lam _ z.

type eta-expand ho.tm -> nat -> ho.tm -> o.
eta-expand T z T.
eta-expand T (s N) (ho.lam R2) :- pi x\ unif-mk-app T x (R1 x), eta-expand (R1 x) N (R2 x). 

macro @one :- s z.

type contract-rigid list ho.tm -> ho.tm -> ho.tm -> o.
contract-rigid L (ho.lam F) T :- 
  pi x\ contract-rigid [x|L] (F x) T. % also checks H Prefix does not see x
contract-rigid L (ho.app [H|Args]) T :- 
  std.rev L LRev, std.appendR Prefix LRev Args,
  if (Prefix = []) (T = H) (T = ho.app [H|Prefix]).


% invariante: a sx non c'è mai una eta espansione, a destra c'è una lam, altrimenti il link eta è buttato via
type progress-eta-link ho.tm -> ho.tm -> ho.subst -> ho.subst -> o.
progress-eta-link (ho.app _ as T) (ho.lam x\ _ as T1) H H1 :- !, print "progrss 1", ho.unif {eta-expand T @one} T1 H H1.
progress-eta-link (ho.con _ as T) (ho.lam x\ _ as T1) H H1 :- !, print "progrss 2", ho.unif {eta-expand T @one} T1 H H1.
progress-eta-link (ho.lam _ as T) T1 H H1 :- !, print "progrss 3", ho.unif T T1 H H1.

% progress-eta-link (ho.con _ as T) (ho.uva _ _ as T1) H H1 :- !, print "progrss 2.1", std.assert!(ho.unif T T1 H H1) "WHY?".
% progress-eta-link (ho.lam B) (ho.lam C) H H1 :- !, print "progress 3", pi x\ (pi S\ ho.unif x x S S) => ho.copy x x => progress-eta-link (B x) (C x) H H1. % fatal "progress eta lam".


% todo: guardare lo scope della uva di dx e allinearlo con quello di sx
progress-eta-link (ho.uva _ _ as X) T H H1 :- contract-rigid [] T T1, !, print "progress 4", ho.unif X T1 H H1. % TODO remove this link from Links
progress-eta-link _ _ H H :- print "no progress". % NO PROGRESS

type my-deref ho.subst -> ho.tm -> ho.tm -> o.
my-deref T (ho.uva N S_) T1_ :- 
  set? N T A_, fatal "TODO".
my-deref _ (ho.con C) (ho.con C).
my-deref S (ho.lam B) (ho.lam B1) :- pi x\ my-deref S x x => my-deref S (B x) (B1 x).
my-deref S (ho.app L) (ho.app L1) :- std.map L (my-deref S) L1.

type solve-link-ctx linkctx1 -> option linkctx1 -> ho.subst -> ho.subst -> o.
solve-link-ctx (ho.abs X) R H H1 :- 
  print "solve-link-ctx under abs",
  pi x\ (pi S\ ho.unif x x S S) => ho.copy x x => (pi S\ ho.deref S x x) => solve-link-ctx (X x) (R' x) H H1,
  if ((R' x) = some (R'' x)) (R = some (ho.abs R'')) (R = none)
  .
solve-link-ctx (ho.val (link-eta N Scope A) as L) (some L) S S1 :-
  std.do![
    ho.deref S (ho.uva N Scope) Deref1,
    ho.deref S A Deref2
  ],
  print "solve-link-ctx eta" Deref1 "=?=" Deref2, !,
  progress-eta-link Deref1 Deref2 S S1, print "finish progress". % TODO: remove link if L is no more an eta
% solve-link-ctx (ho.val (link-fo-align Beta Head PF NPF) as L) (some L) S S1 :- 
%   ho.deref S (ho.uva Head {std.append PF NPF}) BetaHead,  rigid-head BetaHead, !,
%   ho.deref S (ho.uva Beta {std.append PF NPF}) BetaAss, ho.unif BetaHead BetaAss S S1.

solve-link-ctx L _ _ _ :- fatal "solve-link-ctx" L.
% % classic beta: the head of the application is rigid
% solve-link [link-fo-align V Hd_ T|L1] L2 S S2 :-
%   % if Hd is set then beta (note assmt-deref does the beta-redex)
%   ho.assmt-deref S T Ass2,  rigid-head Ass2, !,
%   print "Solve link beta",
%   if (set? V S Ass1) (print "ass1 is" Ass2, my-unif-assignment Ass1 Ass2 S S1) (assign V S Ass2 S1),
%   solve-link L1 L2 S1 S2.

% solve-link [link-fo-align V Hd_ T|L1] L2 S S2 :-
%   % TODO: if Hd is not set, the we do Fo-approx
%   ho.assmt-deref S T Ass2, (not (rigid-head Ass2)), !,
%   print "In second link fo align" Ass1 "et" Ass2,
%   % set? is always true, since before we have done a unif
%   if (set? V S Ass1) (
%     fo-align Ass2 Ass1 [] S S1
%   ) (print "It is not assigned?", assign V S Ass2 S1),
%   solve-link L1 L2 S1 S2.

% type solve-links list link -> list link -> ho.subst -> ho.subst -> o.
% solve-links [] [] S S.
% solve-links [A|As] Bs S S2 :-
%   solve-link A S S1,
%   solve-links As Bs S1 S2.
% solve-links [A|As] [A|Bs] S S1 :- solve-links As Bs S S1.

typeabbrev links (list link).

type link-occur-check links -> links -> ho.subst -> ho.subst -> o.
link-occur-check [] _ H H.
link-occur-check [link _ _ _|L] Links H H1 :- link-occur-check L Links H H1.
link-occur-check [link-abs A|L] Links H H2 :-
  link-abs-occur-check A Links H H1, link-occur-check L Links H1 H2.

type link-abs-occur-check linkctx1 -> links -> ho.subst -> ho.subst -> o.
link-abs-occur-check (ho.abs L) Links H H1 :- pi x\ (pi s\ ho.deref s x x :- !) => ho.copy x x => (pi h\ ho.unif x x h h) => link-abs-occur-check (L x) Links H H1.
link-abs-occur-check (ho.val (link-fo-align _ _ _ _)) _ H H.
link-abs-occur-check (ho.val (link-eta N0 S0 T)) Links H H1 :-
  ho.deref H (ho.uva N0 S0) (ho.uva N S), !,
  print "test OC" N0 "->" N "on" T "and" H,
  ho.deref H T T1, !,
%  ((lam-occur-check N Links T1 H, print "OC, no problem with" N, H1 = H) ; (print "OC error, force progress", force-progress (link-eta N S T1) H H1)).
  (lam-occur-check N Links T1 H T2, print "OC, progress", ho.unif {eta-expand (ho.uva N []) {len S}} T2 H H1) ; true.
link-abs-occur-check (ho.val (link-eta N _ _)) _ H H :- print "OC skip" N.

type lam-occur-check nat -> links -> ho.tm -> ho.subst -> ho.tm -> o.
lam-occur-check _ _ (ho.con X) _ (ho.con X).
% lam-occur-check N Links (ho.app L) H H1 :- fold ... L.
lam-occur-check N Links (ho.lam F) H (ho.lam F1) :- pi x\ lam-occur-check N Links (F x) H (F1 x).
lam-occur-check N _Links (ho.uva N S) _H (ho.uva N S) :- !.
lam-occur-check N Links (ho.uva M S) H T :-
  exists (l\deref-link-occur-check l Links M S N H T) Links.

type deref-link-occur-check link -> links -> nat -> list ho.tm -> nat -> ho.subst -> ho.tm -> o.
deref-link-occur-check (link-abs A) Links M S N H T :-
  deref-link-abs-occur-check A Links M S N H T.

type deref-link-abs-occur-check linkctx1 -> links -> nat -> list ho.tm -> nat -> ho.subst -> ho.tm -> o.
deref-link-abs-occur-check (ho.abs A) Links M [V|S] N H T :- deref-link-abs-occur-check (A V) Links M S N H T.
deref-link-abs-occur-check (ho.val (link-eta M S T)) Links M [] N H T2 :- !,
  ho.deref H T T1,
  lam-occur-check N Links T1 H T2.

% We test forall linked var of the ML, that they have the same assignment
type solve-link-fixpoint list link -> list link -> ho.subst -> ho.subst -> o.
solve-link-fixpoint L L2 H H2 :-
  print "\nfixpoint iteration" L,
  solve-link L L1 H H0, !,
  %H1 = H0,
  link-occur-check L1 L1 H0 H1, !,
  if (L = L1, H = H1) (print "end fixpoint", L2 = L, H2 = H) (solve-link-fixpoint L1 L2 H1 H2).

type make-eta-link nat -> nat -> nat -> nat -> list ho.tm -> linkctx1 -> o.
make-eta-link (s  X) z     M' M Vars L :- std.rev Vars Scope, eta-expand (ho.uva M Scope) (s X) T, make-eta-link.aux (s X) M' T Vars L.
make-eta-link (s  X) (s Y) M' M Vars (ho.abs x\ L x) :- pi x\ make-eta-link X Y M M' [x|Vars] (L x).
make-eta-link.aux z     M' T Vars (ho.val (link-eta M' Scope T)) :- std.rev Vars Scope.
make-eta-link.aux (s X) M' T Vars (ho.abs L) :- pi x\ make-eta-link.aux X M' T [x|Vars] (L x).

type solve-link list link -> list link -> ho.subst -> ho.subst -> o.
solve-link [] [] X X :- print "end solv links".

solve-link [link N M LenM|L] LR HO HO1 :- take-link L (link N M' LenM') L1, LenM' >n LenM, !, std.do! [
   print "new eta link 1",
   make-eta-link LenM' LenM M' M [] New,
   solve-link L1 L2 HO HO1, LR = [link N M' LenM', link-abs New | L2],
].
solve-link [link N M LenM|L] LR HO HO1 :- take-link L (link N M' LenM') L1, LenM >n LenM', !, std.do! [
   print "new eta link 2",
   make-eta-link LenM LenM' M M' [] New,
   solve-link L1 L2 HO HO1, LR = [link N M LenM, link-abs New | L2],
].

solve-link [link N M LenM|L] LR HO HO1 :- take-link L (link N M' LenM') L1, not (unset? M HO, unset? M' HO), !, std.do! [
  print "Solve simple link" M "/" LenM "==" M' "/" LenM',
  print "In subst" HO,
  same-assign M M' LenM LenM' W HO HO2,

  solve-link [link N W LenM|L1] LR HO2 HO1,
].

solve-link [link N M LenM|L] [link N M LenM|LR] HO HO1 :- solve-link L LR HO HO1.

% TODO: we should reconsider if it can still be an eta or not.
% if it is, we contract
% if it can't be, we propagate the assignment
% if it may be, we do nothing
% solve-link [link-eta N A|L1] [link-eta N A|L2] S S2 :- set? N S T, !,
%   progress-eta-link {ho.assmt-deref S T} {ho.assmt-deref S A} S S1,
%   print "Solve link eta set check same" N "->" A "=?=" T,
%   % std.assert!(print "Solve link eta set check same" N "->" {ho.assmt-deref S A} "=?=" {ho.assmt-deref S A1}) "xxx",
%   %std.spy(same-assign-aux z z A T S S1),
%   print "After link eta same HO_SUBST is" S1,
%   solve-link L1 L2 S1 S2.
solve-link [link-abs L|L1] L3 S S2 :-
  (solve-link-ctx L R S S1), !,
  if (R = some L')
     (solve-link L1 L2 S1 S2, L3 = [link-abs L'|L2])
     (solve-link L1 L3 S1 S2) .

% TODO:
type same-assign-aux nat -> nat -> ho.assignment -> ho.assignment -> ho.subst -> ho.subst -> o.
same-assign-aux L L T R HO HO2 :- !, my-unif-assignment T R HO HO2.
same-assign-aux _ _ T R HO HO2 :- 
  hope-for-eta HO T Te,
  hope-for-eta HO R Re,
  my-unif-assignment Te Re HO HO2.
 
type same-assign nat -> nat -> nat -> nat -> nat -> ho.subst -> ho.subst -> o.
same-assign M N LenM LenN W HO HO2 :- set? M HO AM, set? N HO AN, !, W = M,
  same-assign-aux LenM LenN AM AN HO HO2.
same-assign M N LenM LenN W HO HO2 :- set? M HO AM, unset? N HO,  W = M, eta LenN N [] AN, print "Eta for" N "is" AN,
  same-assign-aux LenM LenN AM AN HO HO2.
same-assign M N LenM LenN W HO HO2 :- unset? M HO, set? N HO AN,  W = N, eta LenM M [] AM, print "Eta for" M "is" AM,
  same-assign-aux LenM LenN AM AN HO HO2.
% same-assign M N LenM LenN W HO HO2 :- unset? M HO, unset? N HO,   W = M, eta LenN N [] AN, eta LenM M [] AM, print "Eta for" M "is" AM, print "Eta for" N "is" AN,
%   same-assign-aux LenM LenN AM AN HO HO2.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
%%% nel test 15 abbiamo
%%%   Len=1  x\ app[f,Y x]
%%%   Len=0  X
%%%
%%% il codice sotto (my-unif-assignment) fa X = a\ app[f,Y a]
%%% e cambia arietà a X che non va bene
%%%
%%% T = x\ app[f,Y x] deve essere di arità zero
%%% allora o il T coq è (lam x\ app[f,Y x]) oppure f
%%%
%%% sempre nel test 15, dopo con'è g = X
%%% ora falliamo perche g != (lam x\ app[f,Y x])
%%% penso che dire Y x = x non sia "il più generale"
%%%
%%% ora mi sa che fallisce perchè g != lam
%%% che è "sbagliato" (forse) perchè potrebbe anche avere
%%% successo assegnado Y (in quel momento, ma non lo possiamo
%%% fare prima, nelle varie link...)
%%%
%%% in pratica mi pare che o perdiamo generalità (e assegnamo Y presto)
%%% o ritardiamo, restiamo corretti, ma sequenza di successi/fallimenti
%%% non è fedele.
%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Invariant, the assmt in entry are never on the form `ho.val (ho.abs _)`
type my-unif-assignment-aux ho.assignment -> ho.assignment -> ho.subst -> ho.subst -> o.

my-unif-assignment-aux (ho.val T1) (ho.val T2) H H1 :- 
  print "@@@ Start unif between T1 and T2" T1 T2 "in" H, 
  (ho.unif T1 T2 H H1), 
  print "After unif" H H1.
my-unif-assignment-aux (ho.abs F1) (ho.abs F2) H H1 :- 
  pi x\ (pi S\ ho.unif x x S S) => ho.copy x x => my-unif-assignment-aux (F1 x) (F2 x) H H1.

my-unif-assignment-aux (ho.val T) (ho.abs F2) H H1 :-
  print "Enter aa",
  pi x\ sigma R\ unif-mk-app T x R, 
  (pi S\ ho.unif x x S S) => ho.copy x x => my-unif-assignment-aux (ho.val R) (F2 x) H H1,
  print "exit bb".

my-unif-assignment-aux (ho.abs F2) (ho.val T) H H1 :-
  pi x\ sigma R\ unif-mk-app T x R, 
  (pi S\ ho.unif x x S S) => ho.copy x x => my-unif-assignment-aux (F2 x) (ho.val R) H H1.

type lam->abs ho.assignment -> ho.assignment -> o.
lam->abs (ho.val (ho.lam T)) (ho.abs R) :- !, pi x\ lam->abs (ho.val (T x)) (R x).
lam->abs (ho.val A) (ho.val A).
lam->abs (ho.abs T) (ho.abs R) :- pi x\ lam->abs (T x) (R x).

type abs->lam ho.assignment -> ho.tm -> o.
abs->lam (ho.abs T) (ho.lam R)  :- !, pi x\ abs->lam (T x) (R x).
abs->lam (ho.val A) A.

type unif-mk-app ho.tm -> ho.tm -> ho.tm -> o.
unif-mk-app (ho.uva N L) T (ho.uva N R) :- appendR L [T] R.
unif-mk-app (ho.con C) T (ho.app [ho.con C, T]).
unif-mk-app (ho.app L) T (ho.app R) :- appendR L [T] R.

type my-unif-assignment ho.assignment -> ho.assignment -> ho.subst -> ho.subst -> o.
my-unif-assignment T R S1 S2 :-
  ho.assmt-deref S1 T TDeref,
  ho.assmt-deref S1 R RDeref,
  lam->abs TDeref TAbs,
  lam->abs RDeref RAbs,
  print "Start of unification aux between" TAbs "and" RAbs,
  print "In substitution" S1,
  (my-unif-assignment-aux TAbs RAbs S1 S2).

type hope-for-eta  ho.subst -> ho.assignment -> ho.assignment -> o.
hope-for-eta H A1 A2 :-
  ho.assmt-deref H A1 A1Deref,
  hope-for-eta1 A1Deref A2.

% tries to eta contract at each "depth", not just at the top
type hope-for-eta1 ho.assignment -> ho.assignment -> o.
hope-for-eta1 (ho.abs _ as F) G :- hope-contract [] F G.
hope-for-eta1 (ho.abs F) (ho.abs G) :- pi x\ hope-for-eta1 (F x) (G x).
hope-for-eta1 (ho.val T) (ho.val T).

% given x\y\z\... it tries to contract against xyz, then xy, then x
type hope-contract list ho.tm -> ho.assignment -> ho.assignment -> o.
hope-contract L (ho.abs F) T :- pi x\ hope-contract [x|L] (F x) T.
hope-contract L (ho.abs F) T :- pi x\ hope-contract.aux [x|L] (F x) T.

% checks if the term is xxx\ yyy\ app[...|xxx] -> yyy\ app[...]
type hope-contract.aux list ho.tm -> ho.assignment -> ho.assignment -> o.
hope-contract.aux L (ho.abs F) (ho.abs G) :- pi x\ hope-contract.aux L (F x) (G x).
hope-contract.aux L (ho.val V) (ho.val T) :- std.do! [
  V = ho.app[Hd|Args],
  std.rev L LRev,
  std.appendR Prefix LRev Args,
  if (Prefix = []) (T = Hd) (T = ho.app [Hd|Prefix]),
].

% [eta Arity VarName Acc Ass]
type eta nat -> nat -> list ho.tm -> ho.assignment -> o.
eta z     N Acc (ho.val (ho.uva N Acc')) :- std.rev Acc Acc'.
eta (s M) N Acc (ho.abs F) :- pi x\ eta M N [x | Acc] (F x).

type take-link list link -> link -> list link -> o.
take-link [L|XS] L XS.
take-link [L|XS] L' [L|YS] :- not(L = L'), take-link XS L' YS.

type assign-replace nat -> fo.subst -> fo.fm -> fo.subst -> o.
assign-replace z [none|S] X [some X |S].
assign-replace (s N) [A|S] X [A |S1] :- assign-replace N S X S1.

type decompl.aux list link -> list link -> ho.subst -> fo.subst -> fo.subst -> o.
decompl.aux [link N M _Arity|L] LK HO FO FO1 :- print "starting classic eta, coq" N "elpi" M, print HO, set? M HO T, !, 
  ho.assmt-deref HO T T'', print "In HERE", print "The terms assigned is" T "in memory HO" HO "dereferenced is" T'', std.do! [
  decomp-assign LK HO T T0 FO FO',
  fo.eta-contract T0 T',
  assign-replace N FO' T' FO2,
  decompl.aux L LK HO FO2 FO1,
].

type get-head fo.fm -> nat -> list fo.fm -> fo.fm -> o.
get-head (fo.fapp L) z Args T :-
  appendR [Hd|Tl] Args L,
  fo.mk-app Hd Tl T.
get-head (fo.flam B) (s N) Args T :-
  pi x\ get-head (B x) N Args (R x),
  fo.eta-contract (fo.flam R) T.

% This is classic beta
% decompl.aux [link-fo-align V _ T|L] LK HO FO FO1 :- set? M HO T, set? N FO R, !, std.do! [
%   % decomp-assign LK HO T T0 FO FO'',
%   % fold2 (decomp LK HO) Args Args1 FO'' FO',
%   % fo.mk-app R Args1 T0,
%   % decompl.aux L LK HO FO' FO1,
% ].
% % FO-approx
% decompl.aux [link-fo-align V _ T|L] LK HO FO FO1 :- set? M HO T, unset? N FO, !, std.do! [
%   % decomp-assign LK HO T T0 FO FO'',
%   % fold2 (decomp LK HO) Args Args1 FO'' FO',
%   % get-head T0 Arity Args1 TTT,
%   % assign-replace N FO' TTT FO2,
%   % decompl.aux L LK HO FO2 FO1,
% ].

% This is classic eta
% decompl.aux [link-eta M TM |L] LK HO FO FO1 :- set? M HO T, /*unset? N FO,*/ !,
%   print "In link eta1 with link" M TM , std.do![
%   my-unif-assignment TM T HO HO1,
%   % decomp-assign LK HO1 T T0 FO FO2,
%   % fo.eta-contract T0 T1,
%   % assign-replace N FO2 T1 FO3,
%   decompl.aux L LK HO1 FO FO1
% ].

% % This is classic eta
% decompl.aux [link-eta M _T |L] LK HO FO FO1 :- unset? M HO, /*unset? N FO,*/ !, 
%   print "Classic eta unset",
%   decompl.aux L LK HO FO FO1.

decompl.aux [_|L] LK HO FO FO1 :- decompl.aux L LK HO FO FO1.
decompl.aux [] _ _ X X.

type decompl list link -> ho.subst -> fo.subst -> fo.subst -> o.
decompl L HO FO FO1 :- std.do! [
  decompl.aux L L HO FO NewFO,
  merge-fo NewFO NewFO FO FO1,
].

type merge-fo fo.subst -> fo.subst -> fo.subst -> fo.subst -> o.
merge-fo _ [] [] [].
merge-fo _ X [] X.
% TODO: returning [some Y|R] is incorrect, we should return [some Z|R] where
%       Z is the unification of X and Y in the OL
% TODO: instead of deref-equal, we need unif 
% NOTE: Invariant: if X and Y are assigned, then they are equal (TODO: to be verified)
merge-fo S [some X|XS] [some Y|YS] [some Y|R] :- (fo.deref S X X', fo.deref S Y Y', std.do![X' ==o Y']), merge-fo S XS YS R. 
merge-fo S [none|XS] [some X|YS] [some X|R] :- merge-fo S XS YS R.
merge-fo S [some X|XS] [none|YS] [some X|R] :- merge-fo S XS YS R.
merge-fo S [none|XS] [none|YS] [none|R] :- merge-fo S XS YS R.

% we use links just to know if the variables are new
type decomp-assign list link -> ho.subst -> ho.assignment -> fo.fm -> fo.subst -> fo.subst -> o.
% decomp-assign LK HO (ho.abs F) F1 S S1 :-
%   pi x y\ (pi S\ decomp LK HO x y S S) => decomp-assign LK HO (F x) F1 S S1.

decomp-assign LK HO (ho.abs F) (fo.flam F1) S S1 :-
  pi x y\ (pi S\ decomp LK HO x y S S) => decomp-assign LK HO (F x) (F1 y) S S1.

decomp-assign LK HO (ho.val T) T1 S S1 :- print "Before decomp LK HO", (decomp LK HO T T1 S S1).

type decomp list link -> ho.subst -> ho.tm -> fo.fm -> fo.subst -> fo.subst -> o.
decomp _ _ (ho.con X)   (fo.fcon X) S S :- print "OK for constant".
decomp LK HO (ho.app L) SolOL S S1 :- print "In decomp LK HO 2", std.do![
  fold2 (decomp LK HO) L [HD|TL] S S1, 
  fo.mk-app HD TL SolOL].
decomp LK HO (ho.lam F) (fo.flam F1) S S1 :-
  pi x y\ (pi S\ decomp LK HO x y S S) => decomp LK HO (F x) (F1 y) S S1.
decomp LK HO (ho.uva N Args) SolOL S S1 :- set? N HO T, !, print "In set case of uva" T, std.do![
  ho.move-ass T Args T1a,
  abs->lam T1a T1,
  % ho.move T Args T1,
  decomp LK HO T1 SolOL S S1].
decomp LK HO (ho.uva N Args) SolOL S S1 :- print "Entering uva decomp",
  fold2 (decomp LK HO) Args Args1 S S2,
  if (take-link LK (link X N _) _) (S1 = S2)
     (fo.new S2 X S1',
      if (set? N HO T)
         (decomp-assign LK HO T T' S1' S1'', assign X S1'' T' S1)
         (S1 = S1')),
  fo.mk-app (fo.fuva X) Args1 SolOL.

type test-hope-eta-1 o.
type test-hope-eta-2 o.
type test-hope-eta-3 o.
type test-hope-eta-4 o.
type test-hope-eta-5 o.
type test-hope-eta-6 o.
test-hope-eta-1 :- hope-for-eta [] (ho.abs x\ ho.abs y\ ho.val (ho.app[ho.con"f",ho.app[ho.con"g",x],y]))
                                   (ho.abs x\           ho.val (ho.app[ho.con"f",ho.app[ho.con"g",x]  ])).
test-hope-eta-2 :- hope-for-eta [] (ho.abs x\ ho.abs y\ ho.val (ho.app[ho.con"f",ho.app[ho.con"g",y],x]))
                                   (          ho.abs y\ ho.val (ho.app[ho.con"f",ho.app[ho.con"g",y]  ])).
test-hope-eta-3 :- hope-for-eta [] (ho.abs x\ ho.abs y\ ho.val (ho.uva z [y]))
                                   (ho.abs x\           ho.val (ho.uva z [])).
test-hope-eta-4 :- hope-for-eta [] (ho.abs x\ ho.abs y\ ho.val (ho.uva z [x]))
                                   (          ho.abs y\ ho.val (ho.uva z [])).
test-hope-eta-5 :- hope-for-eta [] (ho.abs x\ ho.abs y\ ho.val (ho.uva z [x, y]))
                                   (ho.val (ho.uva z [])).
test-hope-eta-6 :- hope-for-eta [] (ho.abs x\ ho.abs y\ ho.val (ho.uva z [y, x]))
                                   (ho.abs x\ ho.abs y\ ho.val (ho.uva z [y, x])).
}}



% Done: 
%  correct prune in the case of diff length args
%  hope-for-eta in the case of an uva (I think not)
% 