internal-test try6.comp.test-hope-eta-1.
internal-test try6.comp.test-hope-eta-2.
% internal-test try6.comp.test-hope-eta-3.
% internal-test try6.comp.test-hope-eta-4.
% internal-test try6.comp.test-hope-eta-5.
% internal-test try6.comp.test-hope-eta-6.
internal-test try6.ho.test-unif-1.
internal-test try6.ho.test-unif-2.
internal-test try6.ho.test-unif-3.
internal-test try6.ho.test-unif-4.
internal-test try6.ho.test-unif-5.
internal-test try6.ho.test-unif-6.

namespace try6 {

%%%%%%%%%%%%%%%%%%% the OL %%%%%%%%%%%%%%%%%%%%%
namespace fo {

% Common terms
kind fm type.
type fapp list fm -> fm.
type flam (fm -> fm) -> fm.
type fcon string -> fm.
type fuva  nat -> fm.

typeabbrev subst list (option fm).

type deref subst -> fm -> fm -> o.
deref _ X _ :- var X, halt "flex deref".
deref S (fuva N) T1 :- set? N S T, deref S T T1.
deref S (fapp [fuva N|L]) R :- set? N S T, !, beta T L R', deref S R' R.
deref S (fapp L1) (fapp L2) :- forall2 (deref S) L1 L2.
deref S (flam F1) (flam F2) :- pi x\ deref S x x => deref S (F1 x) (F2 x).
deref _ (fcon X) (fcon X).
deref _ (fuva N) (fuva N).
deref _ N N :- name N.
% deref A B V :- var V, halt "This is should be an error" B A.

% [equal T1 T2] check if two terms are equal for the OL
type (==o) fm -> fm -> o.

X ==o Y :- (var X ; var Y), halt "flex equal". % chekc to prevent implem errors
fapp L1 ==o fapp L2 :- forall2 (==o) L1 L2.
flam F1 ==o flam F2 :- pi x\ x ==o x => F1 x ==o F2 x.
fcon X ==o fcon X.
fuva N ==o fuva N.
flam F ==o T :- pi x\ beta T [x] (T' x), x ==o x => F x ==o T' x.
T ==o flam F :- pi x\ beta T [x] (T' x), x ==o x => T' x ==o F x.
fapp [flam X | TL] ==o T :- beta (flam X) TL T', T' ==o T.
T ==o fapp [flam X | TL] :- beta (flam X) TL T', T ==o T'.

% [extend-subst T S S'] forall fuva N in T, extends S with none at pos N
% this is used only in test to build the subst-map before running it
type extend-subst fm -> subst -> subst -> o.
extend-subst (fuva N) S S' :- extend-nat N S S'.
extend-subst (flam F) S S' :- pi x\ (pi S\extend-subst x S S) => extend-subst (F x) S S'.
extend-subst (fcon _) S S.
extend-subst (fapp L) S S1 :- fold extend-subst L S S1.

% aux function for extend-subst
type extend-nat nat -> subst -> subst -> o.
extend-nat z X Y :- std.append X [none] Y.
extend-nat (s N) [] [none | M] :- extend-nat N [] M.
extend-nat (s N) [X | L] [X | M] :- extend-nat N L M.

type beta fm -> list fm -> fm -> o.
beta A [] A.
beta (flam Bo) [H | L] R :- beta (Bo H) L R.
beta (fapp A) L (fapp X) :- std.append A L X.
beta (fuva N) L (fapp [fuva N | L]).
beta (fcon H) L (fapp [fcon H | L]).

% [new S N S'] returns a new free variable N in S' = S @ [none]
type new subst -> nat -> subst -> o.
new [] z [none].
new [X|XS] (s N) [X|YS] :- new XS N YS.

type mk-app fm -> list fm -> fm -> o.
mk-app T L S :- beta T L S.

type eta-contract fm -> fm -> o.
eta-contract (fcon X) (fcon X).
eta-contract (fapp L) (fapp L1) :- forall2 eta-contract L L1.
eta-contract (flam F) T :- contract [] (flam F) T.
eta-contract (flam F) (flam F1) :- pi x\ eta-contract x x => eta-contract (F x) (F1 x).
eta-contract (fuva X) (fuva X).
eta-contract X X :- name X.

type contract list fm -> fm -> fm -> o.
contract L (flam F) T :- 
  pi x\ contract [x|L] (F x) T. % also checks H Prefix does not see x
contract L (fapp [H|Args]) T :- 
  std.rev L LRev, std.appendR Prefix LRev Args,
  if (Prefix = []) (T = H) (T = fapp [H|Prefix]).

}

%%%%%%%%%%%%%%%%%%% the ML %%%%%%%%%%%%%%%%%%%%%

namespace ho {

typeabbrev subst list (option assignment).

kind assignment type.
type abs (tm -> assignment) -> assignment.
type val tm -> assignment.

kind tm  type.
type app list tm -> tm.
type lam (tm -> tm) -> tm.
type con string -> tm.
type uva  nat -> list tm -> tm.

% [unif T1 T2 SOld SNew] check if T1 and T2 unify looking into SOld. SNew is the final substution
type unif tm -> tm -> subst -> subst ->  o.
% Base cases
unif (app L1) (app L2) S S1 :- fold2 unif L1 L2 S S1.
unif (lam F1) (lam F2) S S1 :- 
  pi x\ (pi S\ unif x x S S) => copy x x => unif (F1 x) (F2 x) S S1.
unif (con X) (con X) S S.
% Assigned variables
unif (uva N Args) T S S1 :- 
  set? N S F,!, move F Args T1, unif T1 T S S1.
unif T (uva N Args) S S1 :- 
  set? N S F,!, print "In set branch", move F Args T1, print "after move" F Args T1, unif T T1 S S1.
% Not assigned vars
unif (uva N A) (uva N A) S S :- !, pattern-fragment A.
unif (uva V A) (uva U A) S1 S2 :- !, pattern-fragment A,
  prune-same-args V A [] Ass, assign U S1 Ass S2.
unif (uva N Args1) (uva N Args2) S S2 :- % same var 
  unset? N S,
  std.assert!(len Args1 Len, len Args2 Len) "Not typechecking", !, % the length of args must be the same
  pattern-fragment Args1, pattern-fragment Args2, 
  std.do![new S W S1, prune-same-variable W Args1 Args2 Ass, 
  assign N S1 Ass S2],
  print "Assigning in uva N Args1" N S1 Ass S2. 
unif (uva N Args1) (uva M Args2) S S3 :- % Args with diff length
  unset? N S, unset? M S, !,
  print "Unifying" (uva N Args1) "and" (uva M Args2),
  pattern-fragment Args1, pattern-fragment Args2, 
  new S W S1, (prune-smart W Args1 Args2 Ass1 Ass2), 
  std.do![
  assign N S1 Ass1 S2,
  (N = M; assign M S2 Ass2 S3)]
  % print "Assigning in uva with diff len" N M S1 "with solution" Ass1 "and" Ass2 "in subst" S3
  . 
unif (uva N Args) T S S1 :- 
  not (T = uva _ _), not_occ N S T, pattern-fragment Args, 
  bind T Args T1, print "Binding T to Args" T Args T1, assign N S T1 S1, print "Assing1 T1" T1.
% TODO: we could unify (f c0) with X, this does not work since c0 is a name
unif T (uva N Args) S S1 :- 
  print "Unif complex:" T (uva N Args),
  std.spy-do![not (T = uva _ _), not_occ N S T, pattern-fragment Args, 
  bind T Args T1,print "Binding T to Args" T Args T1,  assign N S T1 S1, print "Assing2 T2" T1].

% Note: eta & beta for unification is not allowed in ML over terms of the OL

% prune in the case of same argumets for the two vars (e.g. uv X L and uv Y L)
type prune-same-args nat -> list tm -> list tm -> assignment -> o.
prune-same-args N [] Acc (val (uva N Args)) :- std.rev Acc Args.
prune-same-args N [_ | B] L (abs T) :- pi x\ prune-same-args N B [x | L] (T x).

% prune in the case of vars with args of same length (e.g. uv X L1, uv Y L2, len L1 = len L2)
type prune-same-variable nat -> list tm -> list tm -> assignment -> o.
prune-same-variable N A1 A2 T :- prune-same-variable-aux N A1 A2 [] T.

type prune-same-variable-aux nat -> list tm -> list tm -> list tm -> assignment -> o.
prune-same-variable-aux N [] [] ACC (val (uva N Args)) :- std.rev ACC Args.
prune-same-variable-aux N [X|XS] [X|YS] ACC (abs F) :- pi x\ prune-same-variable-aux N XS YS [x|ACC] (F x).
prune-same-variable-aux N [_|XS] [_|YS] ACC (abs F) :- pi x\ prune-same-variable-aux N XS YS ACC (F x).

type prune-diff-length-aux nat -> list tm -> list tm -> assignment -> o.
prune-diff-length-aux N [] Acc (val (uva N Acc)).
prune-diff-length-aux N [_|L] Acc (abs T) :- pi x\ prune-diff-length-aux N L Acc (T x).

% res = argomenti dell'altro se li vedo anche io (nell'ordine dell'altro)
type prune-diff-length nat -> list tm -> list tm -> list tm -> assignment -> assignment -> o.
prune-diff-length N [] Args2 Acc (val (uva N Args)) Ass2 :-  !,
  std.rev Acc Args, prune-diff-length-aux N Args2 Args Ass2.
prune-diff-length N Args1 [] Acc Ass1 (val (uva N Args)) :- !,
  std.rev Acc Args, prune-diff-length-aux N Args1 Args Ass1.
prune-diff-length N [X|XS] [X|YS] ACC (abs F) (abs G) :- pi x\ prune-diff-length N XS YS [x|ACC] (F x) (G x).
prune-diff-length N [_|XS] [_|YS] ACC (abs F) (abs G):- pi x\ prune-diff-length N XS YS ACC (F x) (G x).
prune-diff-length A B C D _ _:- halt A B C D.

type keep list A -> A -> bool -> o.
keep L A tt :- mem L A, !.
keep _ _ ff.

type prune-build-ass1 nat -> list tm -> list bool -> assignment -> o.
prune-build-ass1 N Acc [] (ho.val (uva N Args)) :- std.rev Acc Args.
prune-build-ass1 N Acc [tt|L] (ho.abs T) :- pi x\ prune-build-ass1 N [x|Acc] L (T x).
prune-build-ass1 N Acc [ff|L] (ho.abs T) :- pi x\ prune-build-ass1 N Acc L (T x).

type list-init nat -> nat -> (nat -> A -> o) -> list A -> o.
list-init Len Len _ [].
list-init Len Pos F [A | TL] :- F Pos A, list-init Len (s Pos) F TL.

type index list A -> A -> nat -> o.
index [A|_] A z :- !.
index [_|TL] A (s P) :- index TL A P.

type nth nat -> list A -> A -> o.
nth z [A|_] A :- !.
nth (s N) [_|L] A :- !, nth N L A.

type build-order list nat -> list tm -> list tm -> o.
build-order L T R :-
  len L Len, list-init Len z (p\r\ sigma Index Elt\ index L p Index, nth Index T r) R.

type prune-build-ass2 nat -> list tm -> list bool -> list nat -> assignment -> o.
prune-build-ass2 N Acc [] Pos (ho.val (uva N Args)) :- std.rev Acc Acc', build-order Pos Acc' Args.
prune-build-ass2 N Acc [tt|L] Pos (ho.abs T) :- pi x\ prune-build-ass2 N [x|Acc] L Pos (T x).
prune-build-ass2 N Acc [ff|L] Pos (ho.abs T) :- pi x\ prune-build-ass2 N Acc L Pos (T x).

type prune-smart nat -> list tm -> list tm -> assignment -> assignment -> o.
prune-smart N Args1 Args2 Ass1 Ass2 :-
  std.do![std.map Args1 (keep Args2) Bits1, prune-build-ass1 N [] Bits1 Ass1,
  std.map Args2 (keep Args1) Bits2, 
  std.filter Args1 (mem Args2) ToKeep1,
  std.filter Args2 (mem Args1) ToKeep2,
  std.map ToKeep2 (index ToKeep1) Pos,
  prune-build-ass2 N [] Bits2 Pos Ass2].

% What is this for? We also lack of the case: move (abs Bo) [] _ => ??
type move assignment -> list tm -> tm -> o.
move (abs Bo)        [H|L] R :- move (Bo H) L R.
move (val A)         []    A.
move (val (app A))   L     (app X) :- std.append A L X.
move (val (uva N A)) L     (uva N X) :- std.append A L X.
move (val (con H))   L     (app [con H | L]).

type move-ass assignment -> list tm -> assignment -> o.
move-ass (abs Bo)        [H|L] R :- move-ass (Bo H) L R.
move-ass (abs Bo)        []    (abs Bo).
move-ass (val A)         []    (val A).
move-ass (val (app A))   L     (val (app X)) :- std.append A L X.
move-ass (val (uva N A)) L     (val (uva N X)) :- std.append A L X.
move-ass (val (con H))   L     (val (app [con H | L])).

type beta tm -> list tm -> tm -> o.
beta A [] A.
beta (lam Bo) [H | L] R :- beta (Bo H) L R.
beta (app A) L (app X) :- std.append A L X.
beta (uva N A) L (uva N A') :- std.append A L A'.
beta (con H) L (app [con H | L]).

type not_occ_aux nat -> subst -> tm -> o.
not_occ_aux N S (uva M _) :- std.do![unset? M S, diff N M].
not_occ_aux N S (uva M Args) :- std.do![set? M S F, move F Args T, not_occ_aux N S T].
not_occ_aux N S (app L) :- forall1 (not_occ_aux N S) L.
not_occ_aux N S (lam F) :- pi x\ /*not_occ_aux N S x =>*/ not_occ_aux N S (F x).
not_occ_aux _ _ (con _).
not_occ_aux _ _ X :- name X.
 
type not_occ  nat -> subst -> tm -> o.
% not_occ N S T :- print "not occ" N S T, fail.
not_occ N _ (uva N _).
not_occ N S (uva M Args) :- set? M S F, move F Args T, not_occ N S T.
not_occ N S (uva M Args) :- unset? M S, std.forall Args (not_occ_aux N S).
not_occ _ _ (con _).
not_occ N S (app L) :- not_occ_aux N S (app L).
not_occ N S (lam L) :- pi x\ not_occ N S (L x).
not_occ _ _ X :- name X.

type copy tm -> tm -> o.
copy (app L)   (app L') :- forall2 copy L L'.
copy (lam T)   (lam T') :- pi x\ copy x x => copy (T x) (T' x).
copy (uva N L) (uva N L') :- forall2 copy L L'.
copy (con C)   (con C).
copy N N :- not(scope-check), name N.

type scope-check o.


type bind tm -> list tm -> assignment -> o.
% Replace lambdas with abstraction of the ML and abstracting the list of tm in L
% Note L is a list in the pattern fragment
bind (lam T) L (abs T') :- !, pi x\ copy x x => bind (T x) L (T' x).
bind T [] (val T') :- scope-check => copy T T'.
bind T [X | TL] (abs T') :- pi x\ copy X x => bind T TL (T' x).

type new subst -> nat -> subst -> o.
new [] z [none].
new [X|XS] (s N) [X|YS] :- new XS N YS.

type unif-assignment assignment -> assignment -> subst -> subst -> o.
unif-assignment (val T1) (val T2) H H1 :- unif T1 T2 H H1.
unif-assignment (abs F1) (abs F2) H H1 :- pi x\ (pi S\ unif x x S S) => ho.copy x x => unif-assignment (F1 x) (F2 x) H H1.

type deref subst -> tm -> tm -> o.
deref H (uva N L)  X         :- set? N H T, move T L X', deref H X' X.
deref H (app L)   (app L1)   :- forall2 (deref H) L L1.
deref _ (con X)   (con X).
deref H (uva X L) (uva X L1) :- forall2 (deref H) L L1.
deref H (lam F)   (lam G)    :- pi x\ deref H x x => deref H (F x) (G x).
deref _ N         N          :- name N.
% deref A B V :- var V, halt "This is should be an error" B A.

type assmt-deref subst -> assignment -> assignment -> o.
assmt-deref S (abs T) (abs R) :-
  pi x\ assmt-deref S (T x) (R x).
assmt-deref S (val T) (val R) :-
  deref S T R.


type eta-contract tm -> tm -> o.
eta-contract (con X)   (con X).
eta-contract (app L)   (app L1)   :- forall2 eta-contract L L1.
eta-contract (lam F)   T          :- contract [] (lam F) T.
eta-contract (lam F)   (lam F1)   :- pi x\ eta-contract x x => eta-contract (F x) (F1 x).
eta-contract (uva X L) (uva X L1) :- forall2 eta-contract L L1.
eta-contract X X :- name X.

type contract list tm -> tm -> tm -> o.
contract L (lam F) T :- 
  pi x\ contract [x|L] (F x) T. % also checks H Prefix does not see x
contract L (app [H|Args]) T :- 
  std.rev L LRev, std.appendR Prefix LRev Args,
  if (Prefix = []) (T = H) (T = app [H|Prefix]).
contract L (uva H Args) (uva H Prefix) :- 
  std.rev L LRev, std.appendR Prefix LRev Args.


type test-unif-1 o.
type test-unif-2 o.
type test-unif-3 o.
type test-unif-4 o.
type test-unif-5 o.
type test-unif-6 o.
test-unif-1 :- pi x\
  unif (uva z [x]) (uva (s z) []) [none, none] L,
  Z = (abs x\ val (uva X [])),
  SZ = val (uva X []),
  L = [some Z, some SZ|_].

test-unif-2 :- pi x y\
  unif (uva z [x, y]) (uva (s z) [y]) [none, none] L,
  Z = (abs x\ abs y\ val (uva X [y])),
  SZ = (abs x\ val (uva X [x])),
  L = [some Z, some SZ|_].

test-unif-3 :- pi x y w\
  unif (uva z [x, y]) (uva (s z) [x, w, y]) [none, none] L,
  Z = (abs x\ abs y\ val (uva X [x, y])),
  SZ = (abs x\ abs y\ abs z\ val (uva X [x, z])),
  L = [some Z, some SZ|_].

test-unif-4 :- pi x y\ 
  unif (uva z [x, y]) (uva (s z) [y, x]) [none, none] L,
  Z = (abs x\ abs y\ val (uva X [x, y])),
  SZ = (abs x\ abs y\ val (uva X [y, x])),
  L = [some Z, some SZ|_].

test-unif-5 :- pi x y zz w\
  unif (uva z [x, w, y]) (uva (s z) [y, zz, w]) [none, none] L,
  Z = (abs c0\ abs c1\ abs c2\ val (uva X [c1, c2])),
  SZ = (abs c0\ abs c1\ abs c2\ val (uva X [c2, c0])),
  L = [some Z, some SZ|_].

test-unif-6 :- pi x y zz w\
  unif (uva (s z) [y, zz, w]) (uva z [x, w, y]) [none, none] L,
  Z = (abs c0\ abs c1\ abs c2\ val (uva X [c2, c1])),
  SZ = (abs c0\ abs c1\ abs c2\ val (uva X [c0, c2])),
  L = [some Z, some SZ|_].
}

namespace comp {

shorten fo.{ (==o) }.

kind link type.
type link nat -> nat -> nat -> link.
type link-fo-align list ho.tm -> nat -> nat -> nat -> link.
type link-eta nat -> ho.assignment -> link.

% [maybe-eta-aux N T] takes a name N and a term T.
% return if T could be an eta expansion if T = app L and the last
% arg T of L can be reduced to N : T is either N or a Uvar seeing N
type maybe-eta-aux fo.fm -> fo.fm -> o.
maybe-eta-aux N N.
maybe-eta-aux N (fo.fapp[fo.fuva _|L]) :- !, mem L N.
maybe-eta-aux N (fo.flam B) :- !, pi x\ maybe-eta-aux N (B x).
maybe-eta-aux N (fo.fapp L) :-
  last L T, maybe-eta-aux N T.

type comp fo.fm -> ho.tm -> list link -> list link -> ho.subst -> ho.subst -> o.
comp (fo.fcon X)              (ho.con X) L L S S.
% TODO: this is wrong, since we should pass something in the scope of W
comp (fo.flam F) (ho.uva E0 Scope) L L2 S S2 :- print "EEEEEEEE with" F,
  (pi x\ std.spy(maybe-eta-aux x (F x))), !,
  std.spy-do![
    ho.new S E0 S1,
    comp-lam F F1 L L1 S1 S2,
    % hack
    (
      (F1 = (x\ho.uva _ [V1,x]), Scope = [V1]) ;
      (F1 = (x\ho.uva _ [V1,V2,x]), Scope = [V1,V2]) ;
      (F1 = (x\ho.uva _ [x, V1]), Scope = [V1]) ; % TODO this is needed for test 10
      % (F1 = (x\ho.app[ho.con _,uva ...V1,V2,x]), Scope = [V1,V2]) ;
      Scope = []),
  ], L2 = [link-eta E0 (ho.val (ho.lam F1)) | L1],
  print "------------------ END ETA -------------------",
  print "with new link: " link-eta E0 (ho.val (ho.lam F1)),
  print "----------------------------------------------".


type close-links (ho.tm -> list link) -> list link -> o.
close-links (_\[]) [].
close-links (v\[link N M A|XS v]) [link N M A|YS] :- close-links XS YS.
close-links (v\[link-eta N A|XS v]) [link-eta N A|YS] :- !, close-links XS YS.
close-links (v\[link-eta N (A v)|XS v]) [link-eta N (ho.abs A)|YS] :- close-links XS YS.
close-links (v\[link-fo-align E C L A|XS v]) [link-fo-align E C L A|YS] :- close-links XS YS. % FIXME

type comp-lam (fo.fm -> fo.fm) -> (ho.tm -> ho.tm) -> list link -> list link -> ho.subst -> ho.subst -> o.
comp-lam F F1 L L2 S S1 :-
  pi x y\ (pi A S\ comp x y A A S S) => comp (F x) (F1 y) L (L1 y) S S1, close-links L1 L2.

comp (fo.flam F) (ho.lam F1) L L2 S S1 :- comp-lam F F1 L L2 S S1.
comp (fo.fuva N)              (ho.uva M []) L [link N M z|L] S S1 :- ho.new S M S1.
comp (fo.fapp [fo.fuva N|Ag]) (ho.uva M PF1) L L3 S S3 :- !,
  split-pf Ag PF NPF,
  fold4 comp PF PF1 L L S S1,
  fold4 comp NPF NPF1 L L1 S1 S2,
  ho.new S2 M S3,
  len PF Len,
  % TODO: NYI NPF1 can contain non-closed terms (i.e. local vars...)
  if (NPF = []) (LinkType = link) (LinkType = link-fo-align NPF1),
  L3 = [LinkType N M Len | L1].
comp (fo.fapp A)              (ho.app A1) L L1 S S1 :- fold4 comp A A1 L L1 S S1.

type eta-contract-ass ho.assignment -> ho.assignment -> o.
eta-contract-ass (ho.abs F) (ho.abs G) :- pi x\ eta-contract-ass (F x) (G x).
eta-contract-ass (ho.val T) (ho.val T1) :- ho.eta-contract T T1.

% We test forall linked var of the ML, that they have the same assignment
type solve-link list link -> list link -> ho.subst -> ho.subst -> o.
solve-link [] [] X X.
solve-link [link N M LenM|L] LR HO HO1 :- take-link L (link N M' LenM') L1, !, std.do! [
  print "Solve simple link" M M',
  print "In subst" HO,
  same-assign M M' LenM LenM' W HO HO2,
  solve-link [link N W LenM|L1] LR HO2 HO1,
].
% TODO: we should reconsider if it can still be an eta or not.
% if it is, we contract
% if it can't be, we propagate the assignment
% if it may be, we do nothing
solve-link [link-eta N A|L1] L2 S S2 :- unset? N S,
  hope-for-eta S A A'', not (A = A''), !,
  print "Solve link eta unset contract" N "->" A'',
  assign N S A'' S1, 
  solve-link L1 L2 S1 S2.
solve-link [link-eta N A|L1] L2 S S2 :- set? N S A1, !,
  print "Solve link eta set check same" N "->" A "=?=" A1,
  % std.assert!(print "Solve link eta set check same" N "->" {ho.assmt-deref S A} "=?=" {ho.assmt-deref S A1}) "xxx",
  std.spy(same-assign-aux z z A A1 S S1),
  print "After link eta same HO_SUBST is" S1,
  solve-link L1 L2 S1 S2.
solve-link [L|LS] [L|LS'] HO HO1 :- solve-link LS LS' HO HO1.

% type solve-links list link -> list link -> ho.subst -> ho.subst -> o.
% solve-links [] [] S S.
% solve-links [A|As] Bs S S2 :-
%   solve-link A S S1,
%   solve-links As Bs S1 S2.
% solve-links [A|As] [A|Bs] S S1 :- solve-links As Bs S S1.

type same-assign-aux nat -> nat -> ho.assignment -> ho.assignment -> ho.subst -> ho.subst -> o.
same-assign-aux L L T R HO HO2 :- !, my-unif-assignment T R HO HO2.
same-assign-aux _ _ T R HO HO2 :- 
  hope-for-eta HO T Te,
  hope-for-eta HO R Re,
  my-unif-assignment Te Re HO HO2.
 
type same-assign nat -> nat -> nat -> nat -> nat -> ho.subst -> ho.subst -> o.
same-assign M N LenM LenN W HO HO2 :- set? M HO AM, set? N HO AN, W = M,
  same-assign-aux LenM LenN AM AN HO HO2.
same-assign M N LenM LenN W HO HO2 :- set? M HO AM, unset? N HO,  W = M, eta LenN N [] AN, print "Eta for" N "is" AN,
  same-assign-aux LenM LenN AM AN HO HO2.
same-assign M N LenM LenN W HO HO2 :- unset? M HO, set? N HO AN,  W = N, eta LenM M [] AM, print "Eta for" M "is" AM,
  same-assign-aux LenM LenN AM AN HO HO2.
same-assign M N LenM LenN W HO HO2 :- unset? M HO, unset? N HO,   W = M, eta LenN N [] AN, eta LenM M [] AM, print "Eta for" M "is" AM, print "Eta for" N "is" AN,
  same-assign-aux LenM LenN AM AN HO HO2.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%
%%% nel test 15 abbiamo
%%%   Len=1  x\ app[f,Y x]
%%%   Len=0  X
%%%
%%% il codice sotto (my-unif-assignment) fa X = a\ app[f,Y a]
%%% e cambia arietà a X che non va bene
%%%
%%% T = x\ app[f,Y x] deve essere di arità zero
%%% allora o il T coq è (lam x\ app[f,Y x]) oppure f
%%%
%%% sempre nel test 15, dopo con'è g = X
%%% ora falliamo perche g != (lam x\ app[f,Y x])
%%% penso che dire Y x = x non sia "il più generale"
%%%
%%% ora mi sa che fallisce perchè g != lam
%%% che è "sbagliato" (forse) perchè potrebbe anche avere
%%% successo assegnado Y (in quel momento, ma non lo possiamo
%%% fare prima, nelle varie link...)
%%%
%%% in pratica mi pare che o perdiamo generalità (e assegnamo Y presto)
%%% o ritardiamo, restiamo corretti, ma sequenza di successi/fallimenti
%%% non è fedele.
%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Invariant, the assmt in entry are never on the form `ho.val (ho.abs _)`
type my-unif-assignment-aux ho.assignment -> ho.assignment -> ho.subst -> ho.subst -> o.

my-unif-assignment-aux (ho.val T1) (ho.val T2) H H1 :- 
  print "@@@ Start unif between T1 and T2" T1 T2 "in" H, 
  (ho.unif T1 T2 H H1), 
  print "After unif" H H1.
my-unif-assignment-aux (ho.abs F1) (ho.abs F2) H H1 :- 
  pi x\ (pi S\ ho.unif x x S S) => ho.copy x x => my-unif-assignment-aux (F1 x) (F2 x) H H1.

my-unif-assignment-aux (ho.val T) (ho.abs F2) H H1 :-
  print "Enter aa",
  pi x\ sigma R\ unif-mk-app T x R, 
  (pi S\ ho.unif x x S S) => ho.copy x x => my-unif-assignment-aux (ho.val R) (F2 x) H H1,
  print "exit bb".

my-unif-assignment-aux (ho.abs F2) (ho.val T) H H1 :-
  pi x\ sigma R\ unif-mk-app T x R, 
  (pi S\ ho.unif x x S S) => ho.copy x x => my-unif-assignment-aux (F2 x) (ho.val R) H H1.

type lam->abs ho.assignment -> ho.assignment -> o.
lam->abs (ho.val (ho.lam T)) (ho.abs R) :- !, pi x\ lam->abs (ho.val (T x)) (R x).
lam->abs (ho.val A) (ho.val A).
lam->abs (ho.abs T) (ho.abs R) :- pi x\ lam->abs (T x) (R x).

type abs->lam ho.assignment -> ho.tm -> o.
abs->lam (ho.abs T) (ho.lam R)  :- !, pi x\ abs->lam (T x) (R x).
abs->lam (ho.val A) A.

type unif-mk-app ho.tm -> ho.tm -> ho.tm -> o.
unif-mk-app (ho.uva N L) T (ho.uva N R) :- appendR L [T] R.
unif-mk-app (ho.con C) T (ho.app [ho.con C, T]).
unif-mk-app (ho.app L) T (ho.app R) :- appendR L [T] R.

type my-unif-assignment ho.assignment -> ho.assignment -> ho.subst -> ho.subst -> o.
my-unif-assignment T R S1 S2 :-
  ho.assmt-deref S1 T TDeref,
  ho.assmt-deref S1 R RDeref,
  lam->abs TDeref TAbs,
  lam->abs RDeref RAbs,
  print "Start of unification aux between" TAbs "and" RAbs,
  print "In substitution" S1,
  std.spy(my-unif-assignment-aux TAbs RAbs S1 S2).

type hope-for-eta  ho.subst -> ho.assignment -> ho.assignment -> o.
hope-for-eta H A1 A2 :-
  ho.assmt-deref H A1 A1Deref,
  hope-for-eta1 A1Deref A2.

% tries to eta contract at each "depth", not just at the top
type hope-for-eta1 ho.assignment -> ho.assignment -> o.
hope-for-eta1 (ho.abs _ as F) G :- hope-contract [] F G.
hope-for-eta1 (ho.abs F) (ho.abs G) :- pi x\ hope-for-eta1 (F x) (G x).
hope-for-eta1 (ho.val T) (ho.val T).

% given x\y\z\... it tries to contract against xyz, then xy, then x
type hope-contract list ho.tm -> ho.assignment -> ho.assignment -> o.
hope-contract L (ho.abs F) T :- pi x\ hope-contract [x|L] (F x) T.
hope-contract L (ho.abs F) T :- pi x\ hope-contract.aux [x|L] (F x) T.

% checks if the term is xxx\ yyy\ app[...|xxx] -> yyy\ app[...]
type hope-contract.aux list ho.tm -> ho.assignment -> ho.assignment -> o.
hope-contract.aux L (ho.abs F) (ho.abs G) :- pi x\ hope-contract.aux L (F x) (G x).
hope-contract.aux L (ho.val V) (ho.val T) :- std.do! [
  V = ho.app[Hd|Args],
  std.rev L LRev,
  std.appendR Prefix LRev Args,
  if (Prefix = []) (T = Hd) (T = ho.app [Hd|Prefix]),
].

% [eta Arity VarName Acc Ass]
type eta nat -> nat -> list ho.tm -> ho.assignment -> o.
eta z     N Acc (ho.val (ho.uva N Acc')) :- std.rev Acc Acc'.
eta (s M) N Acc (ho.abs F) :- pi x\ eta M N [x | Acc] (F x).

type take-link list link -> link -> list link -> o.
take-link [L|XS] L XS.
take-link [L|XS] L' [L|YS] :- not(L = L'), take-link XS L' YS.

type assign-replace nat -> fo.subst -> fo.fm -> fo.subst -> o.
assign-replace z [none|S] X [some X |S].
assign-replace (s N) [A|S] X [A |S1] :- assign-replace N S X S1.

type decompl.aux list link -> list link -> ho.subst -> fo.subst -> fo.subst -> o.
decompl.aux [link N M _Arity|L] LK HO FO FO1 :- print "starting classic eta, coq" N "elpi" M, print HO, set? M HO T, !, 
  ho.assmt-deref HO T T'', print "In HERE", print "The terms assigned is" T "in memory HO" HO "dereferenced is" T'', std.do! [
  decomp-assign LK HO T T0 FO FO',
  fo.eta-contract T0 T',
  assign-replace N FO' T' FO2,
  decompl.aux L LK HO FO2 FO1,
].

type get-head fo.fm -> nat -> list fo.fm -> fo.fm -> o.
get-head (fo.fapp L) z Args T :-
  appendR [Hd|Tl] Args L,
  fo.mk-app Hd Tl T.
get-head (fo.flam B) (s N) Args T :-
  pi x\ get-head (B x) N Args (R x),
  fo.eta-contract (fo.flam R) T.

% This is classic beta
decompl.aux [link-fo-align Args N M Arity_|L] LK HO FO FO1 :- set? M HO T, set? N FO R, !, std.do! [
  decomp-assign LK HO T T0 FO FO'',
  fold2 (decomp LK HO) Args Args1 FO'' FO',
  fo.mk-app R Args1 T0,
  decompl.aux L LK HO FO' FO1,
].
% FO-approx
decompl.aux [link-fo-align Args N M Arity|L] LK HO FO FO1 :- set? M HO T, unset? N FO, !, std.do! [
  decomp-assign LK HO T T0 FO FO'',
  fold2 (decomp LK HO) Args Args1 FO'' FO',
  get-head T0 Arity Args1 TTT,
  assign-replace N FO' TTT FO2,
  decompl.aux L LK HO FO2 FO1,
].

% This is classic eta
decompl.aux [link-eta M TM |L] LK HO FO FO1 :- set? M HO T, /*unset? N FO,*/ !,
  print "In link eta1 with link" M TM , std.do![
  my-unif-assignment TM T HO HO1,
  % decomp-assign LK HO1 T T0 FO FO2,
  % fo.eta-contract T0 T1,
  % assign-replace N FO2 T1 FO3,
  decompl.aux L LK HO1 FO FO1
].

% This is classic eta
decompl.aux [link-eta M _T |L] LK HO FO FO1 :- unset? M HO, /*unset? N FO,*/ !, 
  print "Classic eta unset",
  decompl.aux L LK HO FO FO1.

decompl.aux [_|L] LK HO FO FO1 :- decompl.aux L LK HO FO FO1.
decompl.aux [] _ _ X X.

type decompl list link -> ho.subst -> fo.subst -> fo.subst -> o.
decompl L HO FO FO1 :- std.do! [
  decompl.aux L L HO FO NewFO,
  merge-fo NewFO NewFO FO FO1,
].

type merge-fo fo.subst -> fo.subst -> fo.subst -> fo.subst -> o.
merge-fo _ [] [] [].
merge-fo _ X [] X.
% TODO: returning [some Y|R] is incorrect, we should return [some Z|R] where
%       Z is the unification of X and Y in the OL
% TODO: instead of deref-equal, we need unif 
% NOTE: Invariant: if X and Y are assigned, then they are equal (TODO: to be verified)
merge-fo S [some X|XS] [some Y|YS] [some Y|R] :- (fo.deref S X X', fo.deref S Y Y', std.do![X' ==o Y']), merge-fo S XS YS R. 
merge-fo S [none|XS] [some X|YS] [some X|R] :- merge-fo S XS YS R.
merge-fo S [some X|XS] [none|YS] [some X|R] :- merge-fo S XS YS R.
merge-fo S [none|XS] [none|YS] [none|R] :- merge-fo S XS YS R.

% we use links just to know if the variables are new
type decomp-assign list link -> ho.subst -> ho.assignment -> fo.fm -> fo.subst -> fo.subst -> o.
% decomp-assign LK HO (ho.abs F) F1 S S1 :-
%   pi x y\ (pi S\ decomp LK HO x y S S) => decomp-assign LK HO (F x) F1 S S1.

decomp-assign LK HO (ho.abs F) (fo.flam F1) S S1 :-
  pi x y\ (pi S\ decomp LK HO x y S S) => decomp-assign LK HO (F x) (F1 y) S S1.

decomp-assign LK HO (ho.val T) T1 S S1 :- print "Before decomp LK HO", (decomp LK HO T T1 S S1).

type decomp list link -> ho.subst -> ho.tm -> fo.fm -> fo.subst -> fo.subst -> o.
decomp _ _ (ho.con X)   (fo.fcon X) S S :- print "OK for constant".
decomp LK HO (ho.app L) SolOL S S1 :- print "In decomp LK HO 2", std.do![
  fold2 (decomp LK HO) L [HD|TL] S S1, 
  fo.mk-app HD TL SolOL].
decomp LK HO (ho.lam F) (fo.flam F1) S S1 :-
  pi x y\ (pi S\ decomp LK HO x y S S) => decomp LK HO (F x) (F1 y) S S1.
decomp LK HO (ho.uva N Args) SolOL S S1 :- set? N HO T, !, print "In set case of uva" T, std.do![
  ho.move-ass T Args T1a,
  abs->lam T1a T1,
  % ho.move T Args T1,
  decomp LK HO T1 SolOL S S1].
decomp LK HO (ho.uva N Args) SolOL S S1 :- print "Entering uva decomp",
  fold2 (decomp LK HO) Args Args1 S S2,
  if (take-link LK (link X N _) _) (S1 = S2)
     (fo.new S2 X S1',
      if (set? N HO T)
         (decomp-assign LK HO T T' S1' S1'', assign X S1'' T' S1)
         (S1 = S1')),
  fo.mk-app (fo.fuva X) Args1 SolOL.

type test-hope-eta-1 o.
type test-hope-eta-2 o.
type test-hope-eta-3 o.
type test-hope-eta-4 o.
type test-hope-eta-5 o.
type test-hope-eta-6 o.
test-hope-eta-1 :- hope-for-eta [] (ho.abs x\ ho.abs y\ ho.val (ho.app[ho.con"f",ho.app[ho.con"g",x],y]))
                                   (ho.abs x\           ho.val (ho.app[ho.con"f",ho.app[ho.con"g",x]  ])).
test-hope-eta-2 :- hope-for-eta [] (ho.abs x\ ho.abs y\ ho.val (ho.app[ho.con"f",ho.app[ho.con"g",y],x]))
                                   (          ho.abs y\ ho.val (ho.app[ho.con"f",ho.app[ho.con"g",y]  ])).
test-hope-eta-3 :- hope-for-eta [] (ho.abs x\ ho.abs y\ ho.val (ho.uva z [y]))
                                   (ho.abs x\           ho.val (ho.uva z [])).
test-hope-eta-4 :- hope-for-eta [] (ho.abs x\ ho.abs y\ ho.val (ho.uva z [x]))
                                   (          ho.abs y\ ho.val (ho.uva z [])).
test-hope-eta-5 :- hope-for-eta [] (ho.abs x\ ho.abs y\ ho.val (ho.uva z [x, y]))
                                   (ho.val (ho.uva z [])).
test-hope-eta-6 :- hope-for-eta [] (ho.abs x\ ho.abs y\ ho.val (ho.uva z [y, x]))
                                   (ho.abs x\ ho.abs y\ ho.val (ho.uva z [y, x])).
}}



% Done: 
%  correct prune in the case of diff length args
%  hope-for-eta in the case of an uva (I think not)
% 