internal-test ho.test-unif-1.
internal-test ho.test-unif-2.
internal-test ho.test-unif-3.
internal-test ho.test-unif-4.
internal-test ho.test-unif-5.
internal-test ho.test-unif-6.
internal-test ho.test-unif-7.
internal-test fo.test-parse-1.
internal-test comp.test-maybe-eta-1.
internal-test comp.test-maybe-eta-2.

namespace mem {
  kind address type.
  type addr nat -> address.

  typeabbrev (mem A) (list (option A)).

  type get nat -> mem A -> A -> o.
  get z (some Y :: _) Y.
  get (s N) (_ :: L) X :- get N L X.

  type alloc-aux nat -> mem A -> mem A -> o.
  alloc-aux z [] [none] :- !.
  alloc-aux z L L. % No need for exted: the mem is enough
  alloc-aux (s N) [] [none | M] :- alloc-aux N [] M.
  alloc-aux (s N) [X | L] [X | M] :- alloc-aux N L M.

  type alloc address -> mem A -> mem A -> o.
  alloc (addr A as Ad) Mem1 Mem2 :- unset? Ad Mem1, alloc-aux A Mem1 Mem2.

  type new-aux mem A -> nat -> mem A -> o.
  new-aux [] z [none].
  new-aux [A | As] (s N) [A | Bs] :- new-aux As N Bs.

  type new mem A -> address -> mem A -> o.
  new Mem1 (addr Ad) Mem2 :- new-aux Mem1 Ad Mem2.

  type set? address -> mem A -> A -> o.
  set? (addr A) Mem Val :- get A Mem Val.

  type unset? address -> mem A -> o.
  unset? Addr Mem :- not (set? Addr Mem _).

  type assign-aux nat -> mem A -> A -> mem A -> o.
  assign-aux z (none :: L) Y (some Y :: L).
  assign-aux (s N) (X :: L) Y (X :: L1) :- assign-aux N L Y L1.

  type assign address -> mem A -> A -> mem A -> o.
  assign (addr A) Mem1 Val Mem2 :- assign-aux A Mem1 Val Mem2.

  type ppaddr address -> string -> o.
  ppaddr (addr A) S :- ppnat A S.

  type pp mem A -> string -> (A -> string -> o) -> list string -> o.
  pp L Pref PP S :- ppmem.aux z Pref PP L S.

  type ppmem.aux nat -> string -> (A -> string -> o) -> mem A -> list string -> o.
  ppmem.aux _ _ _ [] [].
  ppmem.aux N Pref PP [some X|XS] [L|LS] :- PP X Cnt, L is Pref ^ {ppnat N} ^ " " ^ Cnt, ppmem.aux (s N) Pref PP XS LS.
  ppmem.aux N Pref PP [none|XS] [L|LS] :- L is Pref ^ {ppnat N} ^ " := _", ppmem.aux (s N) Pref PP XS LS.
}

typeabbrev (mem A) (mem.mem A).
typeabbrev address mem.address.
typeabbrev addr mem.addr.

%%%%%%%%%%%%%%%%%%% the OL %%%%%%%%%%%%%%%%%%%%%
namespace fo {

% Common terms
kind fm type.
type fapp list fm -> fm.
type flam (fm -> fm) -> fm.
type fcon string -> fm.
type fuva  address -> fm.

type pp fm -> string -> o.
pp X "_" :- var X.
pp (fapp L) S :- !, std.string.concat " " {std.map L pp} X, S is "(@ " ^ X ^ ")".
pp (fcon S) S :- !.
pp (flam F) S :- !, pi x\ std.any->string x N, pp (F x) S1, S is "λ" ^ N ^ "." ^ S1.
pp (fuva N) S :- !, ppuva N S.
pp X S :- name X, !, std.any->string X S.
pp _ "ERROR".

type ppuva address -> string -> o.
ppuva N S :- mem.ppaddr N X, S is "C" ^ X.

type parse string -> fm -> o.
parse S T :- rex.split "" S L, utf8-norm L L1, if (parse-aux L1 T) true (halt "Error parse" S).

type parse-aux list string -> fm -> o.
parse-aux L1 T :- ll L1 [] T, !.
parse-aux L1 T :- llapp L1 [] [] A, T = fapp A, !.
parse-aux L1 _ :- std.string.concat "" L1 S, halt "parse error:" S. 

type parse-eq string -> fm -> fm -> o.
parse-eq S A B  :- rex.split "" S L, utf8-norm L L1, if (parse-eq-aux L1 A B) true (halt "Error parse-eq" S).

type parse-eq-aux list string -> fm -> fm -> o.
parse-eq-aux L1 A B :-
  llapp L1 L2 [] AA, if (AA = [A]) true (A = fapp AA), !,
  ee L2 L3,
  llapp L3 [] [] BB, if (BB = [B]) true (B = fapp BB).

type ee list string -> list string -> o.
ee ["="|L] L.
ee [" "|L] L1 :- ee L L1.

type ll list string -> list string -> fm -> o.
ll [C|L] L (fcon C) :- rex.match "[a-z]" C.
ll ["_"|L] L (fcon "_").
ll ["C",N|L] L (fuva (mem.addr R)) :- rex.match "[0-9]" N, N' is string_to_int N, int->nat N' R. 
ll ["X"|L] L (fuva (mem.addr z)).
ll ["Y"|L] L (fuva (mem.addr (s z))).
ll ["Z"|L] L (fuva (mem.addr (s (s z)))).
ll ["W"|L] L (fuva (mem.addr (s (s (s z))))).
ll [ C |_] _ _ :- rex.match "[A-Z]" C, halt "Parser:" C "is not parsed as a knwon variable".
ll ["(","@"|L] L1 T :- !, llapp L L1 [] A, if (A = [T]) true (T = fapp A).
ll ["("|L] L1 T :- llapp L L1 [] A, if (A = [T]) true (T = fapp A).
ll ["λ",V,"."|L] L1 (flam X) :- pi x\ (pi L\ ll [V|L] L x :- !) => ll L L1 (X x).
ll [" "|L] L1 X :- ll L L1 X.

type llapp list string -> list string -> list fm -> list fm -> o.
llapp [")"|L] L A RA :- !, std.rev A RA.
llapp L L2 A B :- ll L L1 X, !, llapp L1 L2 [X|A] B.
llapp L L A RA :- std.rev A RA.

type utf8-norm list string -> list string -> o.
utf8-norm [X,Y|L] ["λ"|L1] :- "λ" is X ^ Y, !, utf8-norm L L1.
utf8-norm [X|L] [X|L1] :- utf8-norm L L1.
utf8-norm [] [].

type test-parse-1 o.
test-parse-1 :-
  parse "C0" (fuva (mem.addr z)),
  parse "f" (fcon "f"),
  parse "(f)" (fcon "f"),
  parse "(f g)" (fapp [fcon "f", fcon "g"]),
  parse "λx.x" (flam x\x).

typeabbrev subst mem fm.

type ppsubst subst -> list string -> o.
ppsubst L S :- mem.pp L "C" (x\s\sigma y\pp x y, s is ":= " ^ y)  S.

type deref subst -> fm -> fm -> o.
deref S X _ :- (var S; var X), fatal "flex deref".
deref S (fuva N) T1 :- mem.set? N S T, deref S T T1.
deref S (fapp [fuva N|L]) R :- mem.set? N S T, !, beta T L R', deref S R' R.
deref S (fapp L1) (fapp L2) :- forall2 (deref S) L1 L2.
deref S (flam F1) (flam F2) :- pi x\ deref S x x => deref S (F1 x) (F2 x).
deref _ (fcon X) (fcon X).
deref _ (fuva N) (fuva N).
deref _ N N :- name N.
% deref A B V :- var V, fatal "This is should be an error" B A.

% [equal T1 T2] check if two terms are equal for the OL
type (==o) fm -> fm -> o.

X ==o Y :- (var X ; var Y), fatal "flex equal". % chekc to prevent implem errors
fapp L1 ==o fapp L2 :- forall2 (==o) L1 L2.
flam F1 ==o flam F2 :- pi x\ x ==o x => F1 x ==o F2 x.
fcon X ==o fcon X.
fuva N ==o fuva N.
flam F ==o T :- pi x\ beta T [x] (T' x), x ==o x => F x ==o T' x.
T ==o flam F :- pi x\ beta T [x] (T' x), x ==o x => T' x ==o F x.
fapp [flam X | TL] ==o T :- beta (flam X) TL T', T' ==o T.
T ==o fapp [flam X | TL] :- beta (flam X) TL T', T ==o T'.

% [extend-subst T S S'] forall fuva N in T, extends S with none at pos N
% this is used only in test to build the subst-map before running it
type extend-subst fm -> subst -> subst -> o.
extend-subst (fuva N) S S' :- mem.alloc N S S'.
extend-subst (flam F) S S' :- pi x\ (pi S\extend-subst x S S) => extend-subst (F x) S S'.
extend-subst (fcon _) S S.
extend-subst (fapp L) S S1 :- fold extend-subst L S S1.

type beta fm -> list fm -> fm -> o.
beta A [] A.
beta (flam Bo) [H | L] R :- beta (Bo H) L R.
beta (fapp A) L (fapp X) :- std.append A L X.
beta (fuva N) L (fapp [fuva N | L]).
beta (fcon H) L (fapp [fcon H | L]).
beta N L (fapp [N | L]) :- name N.

type mk-app fm -> list fm -> fm -> o.
mk-app T L S :- beta T L S.

type eta-contract fm -> fm -> o.
eta-contract X _ :- var X, halt "Eta-contract first args is flexible".
eta-contract (fcon X) (fcon X).
eta-contract (fapp L) (fapp L1) :- forall2 eta-contract L L1.
eta-contract (flam F) T :- contract [] (flam F) T.
eta-contract (flam F) (flam F1) :- pi x\ eta-contract x x => eta-contract (F x) (F1 x).
eta-contract (fuva X) (fuva X).
eta-contract X X :- name X.

type contract list fm -> fm -> fm -> o.
contract L (flam F) T :- 
  pi x\ contract [x|L] (F x) T. % also checks H Prefix does not see x
contract L (fapp [H|Args]) T :- 
  std.rev L LRev, std.appendR Prefix LRev Args,
  if (Prefix = []) (T = H) (T = fapp [H|Prefix]).

}

%%%%%%%%%%%%%%%%%%% the ML %%%%%%%%%%%%%%%%%%%%%

namespace ho {

typeabbrev subst list (option assignment).

kind inctx type -> type.
type abs (tm -> inctx A) -> inctx A.
type val A -> inctx A.

typeabbrev assignment (inctx tm).

kind tm  type.
type app list tm -> tm.
type lam (tm -> tm) -> tm.
type con string -> tm.
type uva  address -> list tm -> tm.

type pp tm -> string -> o.
pp (app [lam F|L]) S :- !,
  pp (lam F) H,
  std.string.concat " " {std.map L pp} X, S is "((" ^ H ^ ") " ^ X ^ ")".
pp (app L) S :- !, std.string.concat " " {std.map L pp} X, S is "(" ^ X ^ ")".
pp (con S) S :- !.
pp (lam F) S :- !, pi x\ std.any->string x N, pp (F x) S1, S is N ^ "\\ " ^ S1.
pp (uva N []) S :- !, S is {ppuva N}.
pp (uva N L) S :- !, std.string.concat " " {std.map L pp} X, !, S is "`" ^ {ppuva N} ^ " " ^ X ^ "'".
pp X S :- name X, !, std.any->string X S.
pp _ "ERROR".

type ppuva address -> string -> o.
ppuva N S :- S is "X" ^ {mem.ppaddr N}.

type ppsubst subst -> list string -> o.
ppsubst L S :- mem.pp L "X" ppass S.

type ppass assignment -> string -> o.
ppass (abs F) S :- pi x\ std.any->string x N, ppass (F x) S1, S is N ^ " " ^ S1.
ppass (val T) S :- S is ":= " ^ {pp T}.

% [unif T1 T2 SOld SNew] check if T1 and T2 unify looking into SOld. SNew is the final substution
type unif tm -> tm -> subst -> subst ->  o.
unif A B C _ :- (var A; var B; var C), halt "Passed var to unif".
%unif A B _ _ :- print "## unif" {pp A} "=?=" {pp B}, fail.
% Base cases
unif (app L1) (app L2) S S1 :- fold2 unif L1 L2 S S1.
unif (lam F1) (lam F2) S S1 :- 
  pi x\ (pi S\ unif x x S S) => copy x x => unif (F1 x) (F2 x) S S1.
unif (con X) (con X) S S.
% Assigned variables
unif (uva N Args) T S S1 :- 
  mem.set? N S F,!, move F Args T1, unif T1 T S S1.
unif T (uva N Args) S S1 :- 
  mem.set? N S F,!, move F Args T1, unif T T1 S S1.
% Not assigned vars
unif (uva M A1) (uva N A2) S1 S2 :- !, 
  pattern-fragment A1, pattern-fragment A2, 
  prune! M A1 N A2 S1 S2.
unif (uva N Args) T S S1 :- not_occ N S T, pattern-fragment Args, 
  bind T Args T1, mem.assign N S T1 S1.
unif T (uva N Args) S S1 :- not_occ N S T, pattern-fragment Args, 
  bind T Args T1, mem.assign N S T1 S1.

% Note: eta & beta for unification is not allowed in ML over terms of the OL

% Note: We suppose the scopes to always be in PF
type prune! address -> list ho.tm -> address -> list ho.tm -> subst -> subst -> o.
prune! N A  N A  S S :- !.
prune! M A  N A  S1 S2 :- !, bind (uva M A) A Ass, mem.assign N S1 Ass S2.
prune! N A1 N A2 S1 S3 :- !,
  std.assert!(len A1 {len A2}) "Not typechecking", !,
  mem.new S1 W S2, prune-same-variable W A1 A2 [] Ass,
  mem.assign N S2 Ass S3.
prune! N A1 M A2 S1 S4 :- !,
  mem.new S1 W S2, prune-smart W A1 A2 Ass1 Ass2, 
  mem.assign N S2 Ass1 S3,
  mem.assign M S3 Ass2 S4. 

type prune-same-variable address -> list tm -> list tm -> list tm -> assignment -> o.
prune-same-variable N [] [] ACC (val (uva N Args)) :- std.rev ACC Args.
prune-same-variable N [X|XS] [X|YS] ACC (abs F) :- pi x\ prune-same-variable N XS YS [x|ACC] (F x).
prune-same-variable N [_|XS] [_|YS] ACC (abs F) :- pi x\ prune-same-variable N XS YS ACC (F x).

type prune-build-ass1 address -> list tm -> list bool -> assignment -> o.
prune-build-ass1 N Acc [] (val (uva N Args)) :- std.rev Acc Args.
prune-build-ass1 N Acc [tt|L] (abs T) :- pi x\ prune-build-ass1 N [x|Acc] L (T x).
prune-build-ass1 N Acc [ff|L] (abs T) :- pi x\ prune-build-ass1 N Acc L (T x).

type build-order list nat -> list tm -> list tm -> o.
build-order L T R :-
  len L Len, list-init Len z (p\r\ sigma Index Elt\ index L p Index, nth Index T r) R.

type prune-build-ass2 address -> list tm -> list bool -> list nat -> assignment -> o.
prune-build-ass2 N Acc [] Pos (val (uva N Args)) :- std.rev Acc Acc', build-order Pos Acc' Args.
prune-build-ass2 N Acc [tt|L] Pos (abs T) :- pi x\ prune-build-ass2 N [x|Acc] L Pos (T x).
prune-build-ass2 N Acc [ff|L] Pos (abs T) :- pi x\ prune-build-ass2 N Acc L Pos (T x).

type keep list A -> A -> bool -> o.
keep L A tt :- mem L A, !.
keep _ _ ff.

type prune-smart address -> list tm -> list tm -> assignment -> assignment -> o.
prune-smart N Args1 Args2 Ass1 Ass2 :-
  std.do![std.map Args1 (keep Args2) Bits1, prune-build-ass1 N [] Bits1 Ass1,
  std.map Args2 (keep Args1) Bits2, 
  std.filter Args1 (mem Args2) ToKeep1,
  std.filter Args2 (mem Args1) ToKeep2,
  std.map ToKeep2 (index ToKeep1) Pos,
  prune-build-ass2 N [] Bits2 Pos Ass2].

type move assignment -> list tm -> tm -> o.
move (abs Bo)        [H|L] R :- move (Bo H) L R.
move (val A)         []    A :- !.
move (val (uva N A)) L     (uva N X) :- std.append A L X.
move (abs A)         []    _ :- !, fatal "Invalid move call: too few args for abs" A.
move A               L    _ :- !, fatal "Invalid move call:" A L.

type beta tm -> list tm -> tm -> o.
beta A [] A.
beta (lam Bo) [H | L] R :- beta (Bo H) L R.
beta (app A) L (app X) :- std.append A L X.
beta (uva N A) L (uva N A') :- std.append A L A'.
beta (con H) L (app [con H | L]).

type not_occ_aux address -> subst -> tm -> o.
not_occ_aux N H T :- (var N; var H; var T), halt "Invalid call to not_occ_aux". 
not_occ_aux N S (uva M _) :- std.do![mem.unset? M S, not (N = M)].
not_occ_aux N S (uva M Args) :- std.do![mem.set? M S F, move F Args T, not_occ_aux N S T].
not_occ_aux N S (app L) :- forall1 (not_occ_aux N S) L.
not_occ_aux N S (lam F) :- pi x\ /*not_occ_aux N S x =>*/ not_occ_aux N S (F x).
not_occ_aux _ _ (con _).
not_occ_aux _ _ X :- name X.
 
type not_occ  address -> subst -> tm -> o.
% not_occ N S T :- print "not occ" N S T, fail.
not_occ N H T :- (var N; var H; var T), halt "Invalid call to not_occ". 
not_occ N _ (uva N _).
not_occ N S (uva M Args) :- mem.set? M S F, move F Args T, not_occ N S T.
not_occ N S (uva M Args) :- mem.unset? M S, std.forall Args (not_occ_aux N S).
not_occ _ _ (con _).
not_occ N S (app L) :- not_occ_aux N S (app L).
not_occ N S (lam L) :- pi x\ not_occ N S (L x).
not_occ _ _ X :- name X.

type copy tm -> tm -> o.
copy (app L)   (app L') :- forall2 copy L L'.
copy (lam T)   (lam T') :- pi x\ copy x x => copy (T x) (T' x).
copy (uva N L) (uva N L') :- forall2 copy L L'.
copy (con C)   (con C).
copy N N :- not(scope-check), name N.

type scope-check o.

type bind tm -> list tm -> assignment -> o.
bind T [] (val T') :- scope-check => copy T T'.
bind T [X | TL] (abs T') :- pi x\ copy X x => bind T TL (T' x).

type deref subst -> tm -> tm -> o.
deref S X _ :- (var S; var X), halt "flex deref".
deref H (uva N L)  X         :- mem.set? N H T, move T L X', !, deref H X' X.
deref H (app L)   (app L1)   :- forall2 (deref H) L L1.
deref _ (con X)   (con X).
deref H (uva X L) (uva X L1) :- mem.unset? X H, forall2 (deref H) L L1.
deref H (lam F)   (lam G)    :- pi x\ deref H (F x) (G x).
deref _ N         N          :- name N.
% deref A B V :- var V, fatal "This is should be an error" B A.

type deref-assmt subst -> assignment -> assignment -> o.
deref-assmt S (abs T) (abs R) :-
  pi x\ deref-assmt S (T x) (R x).
deref-assmt S (val T) (val R) :-
  deref S T R.

type eta-contract tm -> tm -> o.
eta-contract X _ :- var X, halt "Eta contract first arg is flexible".
eta-contract (con X)   (con X).
eta-contract (app L)   (app L1)   :- forall2 eta-contract L L1.
eta-contract (lam F)   T          :- contract [] (lam F) T.
eta-contract (lam F)   (lam F1)   :- pi x\ eta-contract x x => eta-contract (F x) (F1 x).
eta-contract (uva X L) (uva X L1) :- forall2 eta-contract L L1.
eta-contract X X :- name X.

type contract list tm -> tm -> tm -> o.
contract L (lam F) T :- 
  pi x\ contract [x|L] (F x) T. % also checks H Prefix does not see x
contract L (app [H|Args]) T :- 
  std.rev L LRev, std.appendR Prefix LRev Args,
  if (Prefix = []) (T = H) (T = app [H|Prefix]).
contract L (uva H Args) (uva H Prefix) :- 
  std.rev L LRev, std.appendR Prefix LRev Args.

macro @mem-uva N S :- uva (mem.addr N) S.

type test-unif-1 o.
type test-unif-2 o.
type test-unif-3 o.
type test-unif-4 o.
type test-unif-5 o.
type test-unif-6 o.
type test-unif-7 o.

test-unif-1 :- pi x\
  unif (@mem-uva z [x]) (@mem-uva (s z) []) [none, none] L,
  Z = (abs x\ val (uva X [])),
  SZ = val (uva X []),
  L = [some Z, some SZ|_].

test-unif-2 :- pi x y\
  unif (@mem-uva z [x, y]) (@mem-uva (s z) [y]) [none, none] L,
  Z = (abs x\ abs y\ val (uva X [y])),
  SZ = (abs x\ val (uva X [x])),
  L = [some Z, some SZ|_].

test-unif-3 :- pi x y w\
  unif (@mem-uva z [x, y]) (@mem-uva (s z) [x, w, y]) [none, none] L,
  Z = (abs x\ abs y\ val (uva X [x, y])),
  SZ = (abs x\ abs y\ abs z\ val (uva X [x, z])),
  L = [some Z, some SZ|_].

test-unif-4 :- pi x y\ 
  unif (@mem-uva z [x, y]) (@mem-uva (s z) [y, x]) [none, none] L,
  Z = (abs x\ abs y\ val (uva X [x, y])),
  SZ = (abs x\ abs y\ val (uva X [y, x])),
  L = [some Z, some SZ|_].

test-unif-5 :- pi x y zz w\
  unif (@mem-uva z [x, w, y]) (@mem-uva (s z) [y, zz, w]) [none, none] L,
  Z = (abs c0\ abs c1\ abs c2\ val (uva X [c1, c2])),
  SZ = (abs c0\ abs c1\ abs c2\ val (uva X [c2, c0])),
  L = [some Z, some SZ|_].

test-unif-6 :- pi x y zz w\
  unif (@mem-uva (s z) [y, zz, w]) (@mem-uva z [x, w, y]) [none, none] L,
  Z = (abs c0\ abs c1\ abs c2\ val (uva X [c2, c1])),
  SZ = (abs c0\ abs c1\ abs c2\ val (uva X [c0, c2])),
  L = [some Z, some SZ|_].

test-unif-7 :- pi x y w zz\
  unif (@mem-uva z [x, y, w]) (@mem-uva z [zz, y, x]) [none] L,
  L = [some (abs x\ abs y\ abs z\ val (uva _ [y])) | _].
}

namespace comp {

kind arity type.
type arity nat -> arity.

kind fvariable type.
type fv address -> fvariable.

kind hvariable type.
type hv address -> arity -> hvariable.

kind mapping type.
type mapping fvariable -> hvariable -> mapping.
typeabbrev mappings (list mapping).

shorten fo.{ (==o) }.

typeabbrev scope (list ho.tm).

kind linkctx type.
type link-eta ho.tm -> ho.tm -> linkctx.
type link-beta ho.tm -> ho.tm -> linkctx.

macro @val-link-eta T1 T2 :- ho.val (link-eta T1 T2).
macro @val-link-beta T1 T2 :- ho.val (link-beta T1 T2).

typeabbrev link (ho.inctx linkctx).

typeabbrev links (list link).

type ppmapping mapping -> string -> o.
ppmapping (mapping (fv N) (hv M (arity Len))) S :-
  S is {fo.ppuva N} ^ " -> " ^ {ho.ppuva M} ^ " (" ^ {ppnat Len} ^ ")".

type ppmappings mappings -> list string -> o.
ppmappings Map Str :- forall2 ppmapping Map Str.

type pplink link -> string -> o.
pplink (ho.abs F) S :- pi x\ std.any->string x N, pplink (F x) S1, S is N ^ " " ^ S1.
pplink (@val-link-eta A B) S :- S is "|- " ^ {ho.pp A} ^ " =η= " ^ {ho.pp B}.
pplink (@val-link-beta A B) S :- S is "|- " ^ {ho.pp A} ^ " =β= " ^ {ho.pp B}.

type pplinks links -> list string -> o.
pplinks L R :- forall2 pplink L R.

% a term use a binder B if there exists a sub-term which `surely` reduce to B
% for example: `f (g x) a` use the binder x
%       while: `f (A x) a` may not use x, since A can reduce to a constant
type use-binder fo.fm -> fo.fm -> o.
use-binder N N.
use-binder N (fo.fapp L) :- exists (use-binder N) L.
use-binder N (fo.flam B) :- pi x\ use-binder N (B x).

% [maybe-eta N T L] takes a name N a term T and a list of binder.
% return if T could be an eta expansion, possible cases:
%  - T = uva seing N (N is also the last of L)
%  - T = app L such that the last args of L are maybe-eta wrt L
type maybe-eta fo.fm -> fo.fm -> list fo.fm -> o.
maybe-eta N (fo.fapp[fo.fuva _|Args]) _ :- !, exists (x\ maybe-eta-of N x []) Args, !. % Head is flex -> if N is in Args, we can have eta
maybe-eta N (fo.flam B) L :- !, pi x\ maybe-eta N (B x) [x | L].
maybe-eta _ (fo.fapp [fo.fcon _|Args]) L :-                                            % Head is rigid -> to be an eta we consider also L
  split-last-n {len L} Args First_ Last,
  % forall1 (x\ forall1 (y\ not (use-binder x y)) First) L,
   maybe-equal Last {std.rev L}.

type maybe-eta-of fo.fm -> fo.fm -> list fo.fm -> o.
maybe-eta-of N N _ :- !.
% TODO: not sure of this (why mem and not maybe-eta-of)
maybe-eta-of N (fo.fapp[fo.fuva _|Args]) L :- !, forall1 (mem Args) [N|L]. % Head is flex -> if N is in Args, we can have eta
maybe-eta-of N (fo.flam B) L :- !, pi x\ maybe-eta-of N (B x) [x | L].
maybe-eta-of N (fo.fapp [N|Args]) L :-                      % Head is rigid -> to be an eta we consider also L
  last-n {len L} Args R,
  maybe-equal R {std.rev L}.

% takes two list of terms, for any pair of terms, it verifies if the second can reduce to the first
type maybe-equal list fo.fm -> list fo.fm -> o.
maybe-equal [] [].
maybe-equal [T|L1] [N|L2] :- maybe-eta-of N T [], maybe-equal L1 L2.

% if there exists a subst s such that contract-rigid st t', then
% maybe-eta t must scucceed
type contract-rigid list ho.tm -> ho.tm -> ho.tm -> o.
contract-rigid L (ho.lam F) T :- 
  pi x\ contract-rigid [x|L] (F x) T. % also checks H Prefix does not see x
contract-rigid L (ho.app [H|Args]) T :- 
  std.rev L LRev, std.appendR Prefix LRev Args,
  if (Prefix = []) (T = H) (T = ho.app [H|Prefix]).

type locale ho.tm -> o.
type get-scope-aux ho.tm -> list ho.tm -> o.
get-scope-aux (ho.con _) [].
get-scope-aux (ho.uva _ L) L1 :- fold (x\y\r\ sigma R\ get-scope-aux x R, std.append y R r) L [] L1.
get-scope-aux (ho.lam B) L1 :- pi x\ locale x => get-scope-aux (B x) L1.
get-scope-aux (ho.app L) L1 :- fold (x\y\r\ sigma R\ get-scope-aux x R, std.append y R r) L [] L1.
get-scope-aux X [X] :- name X, not (locale X).
get-scope-aux X [] :- name X, (locale X).

type get-scope ho.tm -> list ho.tm -> o.
get-scope T Scope :- names N,
  get-scope-aux T ScopeDuplicata,
  std.filter N (mem ScopeDuplicata) Scope.

type close-links (ho.tm -> links) -> links -> o.
close-links (_\[]) [].
close-links (v\[L|XS v]) [L|YS] :- !, close-links XS YS.
close-links (v\[(L v)|XS v]) [ho.abs L|YS] :- !, close-links XS YS.

type comp-lam (fo.fm -> fo.fm) -> (ho.tm -> ho.tm) -> mappings -> mappings -> links -> links -> ho.subst -> ho.subst -> o.
comp-lam F F1 Mappings1 Mappings2 L L2 S S1 :-
  pi x y\ (pi M L S\ comp x y M M L L S S) => comp (F x) (F1 y) Mappings1 Mappings2 L (L1 y) S S1, close-links L1 L2.

type comp fo.fm -> ho.tm -> mappings -> mappings -> links -> links -> ho.subst -> ho.subst -> o.
comp (fo.fcon X)              (ho.con X) Mappings Mappings L L S S.
comp (fo.flam F) (ho.uva E0 Scope) Mappings1 Mappings2  L L2 S S2 :-
  (pi x\ maybe-eta x (F x) [x]), !,
  std.do![
    mem.new S E0 S1,
    comp-lam F F1 Mappings1 Mappings2 L L1 S1 S2,
    (pi x\ locale x => get-scope (F1 x) Scope), 
    NewLink = ho.val(link-eta (ho.uva E0 Scope) (ho.lam F1)),
  ], L2 = [NewLink| L1].

comp (fo.flam F) (ho.lam F1) Mappings1 Mappings2 L L2 S S1 :- comp-lam F F1 Mappings1 Mappings2 L L2 S S1.
comp (fo.fuva N)              (ho.uva M []) Mappings Mappings1 L L S S1 :- alloc Mappings Mappings1 (fv N) (hv M (arity z)) S S1.
comp (fo.fapp [fo.fuva N|Ag]) (ho.uva M' Scope) Mappings1 Mappings3 L L2 S S4 :- !,
  split-pf Ag PF NPF,
  fold6 comp PF PF1 Mappings1 Mappings1 L L S S1,                                 % Note : PF is a list of names -> Mappings1 and L not change
  fold6 comp NPF NPF1 Mappings1 Mappings2 L L1 S1 S2,
  len PF Arity, 
  alloc Mappings2 Mappings3 (fv N) (hv M (arity Arity)) S2 S3, % mem.new S2 M S3,
  if (NPF = []) 
    (Scope = PF1, M' = M, S3 = S4, L1 = L2)
    (get-scope (ho.app {std.append PF1 NPF1}) Scope,
      mem.new S3 M' S4,
      L2 = [@val-link-beta (ho.uva M' Scope) (ho.app[ho.uva M PF1 | NPF1]) | L1],
      true).
comp (fo.fapp A)              (ho.app A1) Mappings1 Mappings2 L L1 S S1 :- fold6 comp A A1 Mappings1 Mappings2 L L1 S S1.

% Ad1 is the variable with smaller arity, Ad2 is eta expanded N times
type make-eta-link-aux nat -> address -> address -> list ho.tm -> links -> ho.subst -> ho.subst -> o.
make-eta-link-aux z Ad1 Ad2 Scope1 [@val-link-eta (ho.uva Ad1 Scope) T1] H1 H1  :-
  std.rev Scope1 Scope, eta-expand (ho.uva Ad2 Scope) @one T1.
make-eta-link-aux (s N) Ad1 Ad2 Scope1 [@val-link-eta (ho.uva Ad1 Scope) T2 | L2] H1 H3 :-
  std.rev Scope1 Scope, mem.new H1 Ad H2, eta-expand (ho.uva Ad Scope) @one T2,
  (pi x\ make-eta-link-aux N Ad Ad2 [x|Scope1] (L1 x) H2 H3),
  close-links L1 L2.

% [make-eta-link ArityAd1, ArityAd2, Ad1, Ad2 Vars, Link]
% as long as the arities are > 0, we eat one arity by putting a variable in the ctx
% in the base case we return the link-eta eta-extending N times the variable with higher arity.
type make-eta-link nat -> nat -> address -> address -> list ho.tm -> links -> ho.subst -> ho.subst -> o.
make-eta-link (s N) z Ad1 Ad2 Vars L H H1 :- make-eta-link-aux N Ad2 Ad1 Vars L H H1.
make-eta-link z (s N) Ad1 Ad2 Vars L H H1 :- make-eta-link-aux N Ad1 Ad2 Vars L H H1.
make-eta-link (s N) (s M) Ad1 Ad2 Vars Links H H1 :-
  (pi x\ make-eta-link N M Ad1 Ad2 [x|Vars] (L x) H H1),
  close-links L Links.

% if there exists two mappings on the form:
%   ==> C0 -> X4 (2) ~!~ C0 -> X1 (1)
% we remove one of the two mappings and add an eta relation between 
% the two variables, so that they are fully applied.
% in the example above, the new link will be 
%   ==> c0 |- `X1 c0' =η= c1\ `X4 c0 c1'
% where: 
%  - they share a common variable from the context (i.e. c0),
%  - X4 is the eta-expanded once to be fully applied
type deduplicate-mappings mappings -> mappings -> ho.subst -> ho.subst -> links -> links -> o.
deduplicate-mappings [] [] H H L L.
deduplicate-mappings [(mapping (fv O) (hv M (arity LenM)) as X1) | Map1] Map2 H1 H3 L1 L3 :-
  take-list Map1 (mapping (fv O) (hv M' (arity LenM'))) _, !,
  std.assert! (not (LenM = LenM')) "Deduplicate mappings, there is a bug",
  print "arity-fix links:" {ppmapping X1} "~!~" {ppmapping (mapping (fv O) (hv M' (arity LenM')))}, 
  make-eta-link LenM LenM' M M' [] New H1 H2,
  print "new eta link" {pplinks New},
  std.append New L1 L2,
  deduplicate-mappings Map1 Map2 H2 H3 L2 L3.
deduplicate-mappings [A|As] [A|Bs] H1 H2 L1 L2 :- deduplicate-mappings As Bs H1 H2 L1 L2, !.
deduplicate-mappings [A|_] _ H _ _ _ :- halt "deduplicating mapping error" {ppmapping A} {ho.ppsubst H}.

type alloc mappings -> mappings -> fvariable -> hvariable -> ho.subst -> ho.subst -> o.
alloc Map Map N M H H :- std.mem Map (mapping N M), !.
alloc Map [mapping (fv N) (hv M Arity)|Map] (fv N) (hv M Arity) H H1 :- mem.new H M H1.

type unif-mk-app ho.tm -> ho.tm -> ho.tm -> o.
unif-mk-app (ho.uva N L) T (ho.uva N R) :- appendR L [T] R.
unif-mk-app (ho.con C) T (ho.app [ho.con C, T]).
unif-mk-app (ho.app L) T (ho.app R) :- appendR L [T] R.

type eta-expand ho.tm -> nat -> ho.tm -> o.
eta-expand T z T.
eta-expand T (s N) (ho.lam R2) :- pi x\ unif-mk-app T x (R1 x), eta-expand (R1 x) N (R2 x). 

macro @one :- s z.

type is-not-eta list ho.tm -> ho.tm -> o.
is-not-eta L (ho.lam B) :- pi x\ is-not-eta _ x => is-not-eta [x|L] (B x).
is-not-eta _ (ho.con _).
is-not-eta L (ho.uva _ Scope) :- forall1 (not-in Scope) L.

type count-lambda ho.tm -> nat -> o.
count-lambda (ho.lam T) (s N) :- !, pi x\ count-lambda (T x) N.
count-lambda _ z.

% invariante: a sx non c'è mai una eta espansione, a destra c'è una lam, altrimenti il link eta è buttato via
type progress-eta-link ho.tm -> ho.tm -> ho.subst -> ho.subst -> links -> o.
progress-eta-link (ho.app _ as T) (ho.lam x\ _ as T1) H H1 [] :- !, print "progress η app left", ho.unif {eta-expand T @one} T1 H H1.
progress-eta-link (ho.con _ as T) (ho.lam x\ _ as T1) H H1 [] :- !, print "progress η con left", ho.unif {eta-expand T @one} T1 H H1.
progress-eta-link (ho.lam _ as T) T1 H H1 [] :- !, print "progress η lam left", ho.unif T T1 H H1.
progress-eta-link (ho.uva _ _ as X) T H H1 [] :- contract-rigid [] T T1, !, print "progress η app right", ho.unif X T1 H H1.
% an example of the following OC error is `f X = λx.(X x)`
progress-eta-link (ho.uva Ad _ as T1) T2 H H [@val-link-eta T1 T2] :- !, if (ho.not_occ Ad H T2) (print "no progress η") (print "progress η fail of occur-check", fail).
progress-eta-link T _ _ _ _ :- halt "Error in progress-eta link: unreachable branch" T.

type is-in-pf ho.tm -> o.
is-in-pf uvar :- halt "passed var to is-in-pf".
is-in-pf (ho.app [ho.uva _ _ | _]) :- !, fail.
is-in-pf (ho.lam B) :- !, pi x\ is-in-pf (B x).
is-in-pf (ho.con _).
is-in-pf (ho.app L) :- forall1 is-in-pf L.
is-in-pf N :- name N.
is-in-pf (ho.uva _ L) :- pattern-fragment L.

type arity ho.tm -> nat -> o.
arity (ho.con _) z.
arity (ho.app L) A :- len L A.

type occur-check-err ho.tm -> ho.tm -> ho.subst -> o.
occur-check-err A _ _ :- var A, halt "Invalid call to occur-check-err".
occur-check-err (ho.con _) _ _ :- !.
occur-check-err (ho.app _) _ _ :- !.
occur-check-err (ho.lam _) _ _ :- !.
occur-check-err (ho.uva Ad _) T S :-
  not (ho.not_occ Ad S T),
  print "progress β fail of occur-check between".

type beta-reduce ho.tm -> ho.tm -> o.
beta-reduce (ho.app [ho.lam B | L]) T2 :- !, ho.beta (ho.lam B) L T1, beta-reduce T1 T2.
beta-reduce A A.

type progress-beta-link-aux ho.tm -> ho.tm -> ho.subst -> ho.subst -> links -> o.
progress-beta-link-aux T1 T2 S1 S2 [] :-  is-in-pf T2, !,
  print "progress β not uva with" {ho.pp T1} "and" {ho.pp T2},
  ho.unif T1 T2 S1 S2.
progress-beta-link-aux T1 T2 S S [@val-link-beta T1 T2] :- !, print "No β progress2".

% a sx non c'è mai un app[uva _ _ | _] per costruzione
% a dx abbiamo sempre app[uva _ N | L] dove N è nel PF e L no
type progress-beta-link ho.tm -> ho.tm -> ho.subst -> ho.subst -> links -> o.
progress-beta-link T (ho.app[ho.uva V Scope | L] as T2) S S2 [@val-link-beta T T2] :- 
  arity T Arity, len L ArgsNb, ArgsNb >n Arity, !,
  minus ArgsNb Arity Diff, mem.new S V1 S1,
  eta-expand (ho.uva V1 Scope) Diff T1,
  ho.unif (ho.uva V Scope) T1 S1 S2,
  print "progress β big arity" {ho.pp T} "unified with" {ho.pp T1} "->" {ho.ppsubst S2}.

% this is for beta links of the form `link-beta T (app[uva N [], app[B, x] | ...])
% and B is instantiated to (x\x)
% In this case, the terms on the right becomes (app[uva N [], x | L])
% We want to put the name x in the scope of N to make HO unif, therefore, we
% build a new var N' of arity 1, eta-linked to N and the beta links is updated
% New links will be: [link-beta T (app[uva N' [x] | L]), link-eta N (λx.ho.uva N' [x])]
progress-beta-link (ho.uva _ _ as T) (ho.app[ho.uva Ad1 Scope1 | L1] as T1) S1 S3 NewLinks :-
  std.append Scope1 L1 Scope1L,
  split-pf Scope1L Scope2 L2,
  print Scope2 L2,
  not (Scope1 = Scope2), !,
  mem.new S1 Ad2 S2,
  len Scope1 Scope1Len,
  len Scope2 Scope2Len,
  make-eta-link Scope1Len Scope2Len Ad1 Ad2 [] LinkEta S2 S3,
  if (L2 = []) (T2 = ho.uva Ad2 Scope2) (T2 = ho.app [ho.uva Ad2 Scope2 | L2]),
  NewLinks = [@val-link-beta T T2 | LinkEta],
  print "progress β: refine" {pplink (@val-link-beta T T1)} "to" {pplinks NewLinks}.

progress-beta-link (ho.uva _ _ as T) (ho.app[ho.uva _ _ | _] as T2) S1 _ _ :- occur-check-err T T2 S1, !, fail.
progress-beta-link T1 (ho.app[ho.uva _ _ | _] as T2) H H [@val-link-beta T1 T2] :- !, print "No β progress1".

% Note: Hd is rigid by construction
progress-beta-link T1 T2 S1 S2 B :-
  beta-reduce T2 T3, print "Progress β deep with" {ho.pp T3}, progress-beta-link-aux T1 T3 S1 S2 B.

type solve-link-abs link -> links -> ho.subst -> ho.subst -> o.
solve-link-abs (ho.abs X) R H H1 :- 
  pi x\ (pi S\ ho.unif x x S S) => ho.copy x x => (pi S\ ho.deref S x x) => solve-link-abs (X x) (R' x) H H1,
  close-links R' R.

solve-link-abs (@val-link-eta A B) NewLinks S S1 :- !,
  print "In progress eta link for" {ho.pp A} {ho.pp B},
  progress-eta-link A B S S1 NewLinks.

solve-link-abs (@val-link-beta A B) NewLinks S S1 :- !,
  print "In progress beta link for" {ho.pp A} {ho.pp B},
  progress-beta-link A B S S1 NewLinks.

solve-link-abs (@val-link-beta _ T) _ _ _ :- !,
  halt "Error beta" T.

:index(_ 1)
type deref-links ho.subst -> links -> links -> o.
deref-links H L1 L2 :- forall2 (x\r\ std.assert! (deref-link H x r) "bug deref links") L1 L2.

type deref-link ho.subst -> link -> link -> o.
deref-link H (ho.abs F) (ho.abs G) :- pi x\ deref-link H (F x) (G x).
deref-link H (@val-link-eta A B) (@val-link-eta A1 B1) :- ho.deref H A A1, ho.deref H B B1.
deref-link H (@val-link-beta A B) (@val-link-beta A1 B1) :- ho.deref H A A1, ho.deref H B B1.

type get-head-link link -> address -> ho.tm -> o.
get-head-link (@val-link-eta (ho.uva Ad _) T) Ad T :- !.
get-head-link (@val-link-beta (ho.uva Ad _) T) Ad T :- !.
get-head-link (ho.abs B) Ad (ho.lam T) :- !, pi x\ get-head-link (B x) Ad (T x).
get-head-link Link _ _ :- halt "BUG: Invalid left side for" {pplink Link}.

type find-link-by-var address -> links -> links -> list ho.tm -> list links -> o.
find-link-by-var _ _ [] [] [].
find-link-by-var Ad Prefix [Hd | L1] [T | L2] [Hd1|LL] :-
  std.append Prefix L1 Hd1,
  std.assert! (get-head-link Hd Ad1 T) "get head should not fail", Ad = Ad1, !,
  find-link-by-var Ad1 [Hd|Prefix] L1 L2 LL.
find-link-by-var Ad Prefix [Hd | L1] L2 LL :- !,
  find-link-by-var Ad [Hd | Prefix] L1 L2 LL.

type not_occ_links_aux address -> links -> ho.tm -> o.
not_occ_links_aux Ad _ (ho.uva Ad _) :- !, fail.
not_occ_links_aux Ad L (ho.uva Ad1 _) :- !, 
  find-link-by-var Ad1 [] L Terms Links,
  forall2 (not_occ_links_aux Ad) Links Terms.
not_occ_links_aux _ _ (ho.con _) :- !.
not_occ_links_aux _ _ N :- name N, !.
not_occ_links_aux Ad L (ho.lam B) :- !, pi x\ not_occ_links_aux Ad L (B x).
not_occ_links_aux Ad L (ho.app B) :- !, forall1 (not_occ_links_aux Ad L) B.

type not_occ_links address -> ho.tm -> links -> o.
not_occ_links _ (ho.con _) _.
not_occ_links Ad (ho.lam B) L :- pi x\ not_occ_links Ad (B x) L.
not_occ_links Ad (ho.uva Ad _) _ :- !.
not_occ_links Ad1 (ho.uva Ad2 _) L :- 
  find-link-by-var Ad2 [] L Terms Links,
  forall2 (not_occ_links_aux Ad1) Links Terms.
not_occ_links Ad (ho.app L) Links :-
  not_occ_links_aux Ad Links (ho.app L).
not_occ_links _ N _ :- name N.

type occur-check-links ho.subst -> links -> o.
occur-check-links _ [].
occur-check-links S [Hd | Tl] :-
  std.assert! (get-head-link Hd Ad Term) "get-head-link should not fail",
  print "## Occur check for" {pplink Hd} "in" {pplinks Tl}, 
  not_occ_links Ad Term Tl,
  print "Ok occur check for" {ho.pp (ho.uva Ad [])},
  occur-check-links S Tl.

% Invariant: links received in entry have already been dereferenced
type solve-links links -> links -> ho.subst -> ho.subst -> o.
solve-links [] [] X X :- print "end solve links".

solve-links [A|L1] [A|L3] S S2 :- take-link A L1 B L2, !, std.do! [
  print "deduplicating links:" {pplink A} "===" {pplink B}, 
  same-link-eta A B S S1, 
  solve-links L2 L3 S1 S2,
].
solve-links [L0|L1] L3 S S2 :- deref-link S L0 L,
  print "considering link for progress:" {pplink L},
  solve-link-abs L R S S1, !,
  if (R = []) (print {pplink L} "is removed") true,
  solve-links L1 L2 S1 S2, std.append R L2 L3.

% type use-binder1 ho.tm -> ho.tm -> o.
% use-binder1 N N.
% use-binder1 N (ho.app L) :- exists (use-binder1 N) L.
% use-binder1 N (ho.lam B) :- pi x\ use-binder1 N (B x).

% type correct-subst-eta ho.tm -> ho.tm -> list ho.tm -> o.
% correct-subst-eta _ (ho.app [ho.uva _ _|_]) _ :- halt "app[uva _ _|_] in subst...".
% correct-subst-eta N (ho.uva _ Args) _ :- !, exists (x\ correct-subst-eta-of N x []) Args, !. % Head is flex -> if N is in Args, we can have eta
% correct-subst-eta N (ho.lam B) L :- !, pi x\ correct-subst-eta N (B x) [x | L].
% correct-subst-eta _ (ho.app [ho.con _|Args]) L :-                                            % Head is rigid -> to be an eta we consider also L
%   split-last-n {len L} Args First Last,
%   forall1 (x\ forall1 (y\ not (use-binder1 x y)) First) L,
%    correct-subst-eta-equal Last {std.rev L}.

% type correct-subst-eta-of ho.tm -> ho.tm -> list ho.tm -> o.
% correct-subst-eta-of _ (ho.app [ho.uva _ _|_]) _ :- halt "app[uva _ _|_] in subst...".
% correct-subst-eta-of N N _ :- !.
% % TODO: not sure of this (why mem and not correct-subst-eta-of)
% correct-subst-eta-of N (ho.uva _ Args) L :- !, forall1 (mem Args) [N|L]. % Head is flex -> if N is in Args, we can have eta
% correct-subst-eta-of N (ho.lam B) L :- !, pi x\ correct-subst-eta-of N (B x) [x | L].
% correct-subst-eta-of N (ho.app [N|Args]) L :-                      % Head is rigid -> to be an eta we consider also L
%   last-n {len L} Args R,
%   correct-subst-eta-equal R {std.rev L}.

% % takes two list of terms, for any pair of terms, it verifies if the second can reduce to the first
% type correct-subst-eta-equal list ho.tm -> list ho.tm -> o.
% correct-subst-eta-equal [] [].
% correct-subst-eta-equal [T|L1] [N|L2] :- correct-subst-eta-of N T [], correct-subst-eta-equal L1 L2.

% type correct-subst-aux ho.assignment -> o.
% correct-subst-aux (ho.val (ho.lam T)) :- !, pi x\
%   if (correct-subst-eta x (T x) [x]) (halt "Subst contains maybeeta") true.
% correct-subst-aux (ho.val _) :- true.
% correct-subst-aux (ho.abs B) :- pi x\ correct-subst-aux (B x).

% type correct-subst ho.subst -> o.
% correct-subst [].
% correct-subst [some Ass | Tl] :- !,
%   correct-subst-aux Ass,
%   correct-subst Tl.
% correct-subst [_| Tl] :- correct-subst Tl.

% We test forall linked var of the ML, that they have the same assignment
type solve-links-fixpoint links -> links -> ho.subst -> ho.subst -> o.
solve-links-fixpoint L0 L2 H H2 :- std.do! [
  deref-links H L0 L, !,
  print "\nfixpoint iteration on:" {pplinks L}, !,
  solve-links L L1 H H1, !,
  % print "Check correct subst of" {ho.ppsubst H1},
  % if ((correct-subst H1)) true (halt "Invalid subst"),
  if (occur-check-links H1 L1) true (print "fail by oc in solve-link-fixpoint", fail),
  if (L = L1, H = H1)
     (print "end fixpoint", deref-links H L L2 , H2 = H)
     (print "## Subst is" {ho.ppsubst H1}, print "## Links are" {pplinks {deref-links H1 L1}}, !, solve-links-fixpoint L1 L2 H1 H2)
].

type same-link-eta link -> link -> ho.subst -> ho.subst -> o.
same-link-eta (ho.abs F) B H H1 :- !, pi x\ same-link-eta (F x) B H H1.
same-link-eta A (ho.abs G) H H1 :- !, pi x\ same-link-eta A (G x) H H1.
same-link-eta (@val-link-eta (ho.uva N S1) A)
              (@val-link-eta (ho.uva N S2) B) H H1 :- std.do! [
  std.assert! (std.length S1 {std.length S2}) "no same scope",
  std.map2 S1 S2 (x\y\r\ r = ho.copy x y) Perm,
  Perm => ho.copy A A',
  ho.unif A' B H H1,
].

type abs->lam ho.assignment -> ho.tm -> o.
abs->lam (ho.abs T) (ho.lam R)  :- !, pi x\ abs->lam (T x) (R x).
abs->lam (ho.val A) A.

type take-link link -> links -> link -> links -> o.
take-link A [B|XS] B XS :- link-abs-same-lhs A B, !.
take-link A [L|XS] B [L|YS] :- take-link A XS B YS.

type link-abs-same-lhs link -> link -> o.
link-abs-same-lhs (ho.abs F) B :- pi x\ link-abs-same-lhs (F x) B.
link-abs-same-lhs A (ho.abs G) :- pi x\ link-abs-same-lhs A (G x).
link-abs-same-lhs (@val-link-eta (ho.uva N _) _) (@val-link-eta (ho.uva N _) _).

type commit-links-aux link -> ho.subst -> ho.subst -> o.
commit-links-aux (@val-link-eta T1 T2) H1 H2 :- 
  ho.deref H1 T1 T1', ho.deref H1 T2 T2',
  print "Start decompl-η of" {ho.pp T1'} "and" {ho.pp T2'} "in" {ho.ppsubst H1}, 
  ho.unif T1' T2' H1 H2.
commit-links-aux (@val-link-beta T1 T2) H1 H2 :- 
  ho.deref H1 T1 T1', ho.deref H1 T2 T2',
  print "Start decompl-β of" {ho.pp T1'} "and" {ho.pp T2'}, ho.unif T1' T2' H1 H2.
commit-links-aux (ho.abs B) H H1 :- pi x\ commit-links-aux (B x) H H1.

type commit-links links -> links -> ho.subst -> ho.subst -> o.
commit-links [] [] H H.
commit-links [Abs| Links] L H H2 :- commit-links-aux Abs H H1, !, commit-links Links L H1 H2.

% Invariant: links are only on the form (link VO VM Arity), each VO appears once and each VM appears once
type decompl-subst mappings -> mappings -> ho.subst -> fo.subst -> fo.subst -> o.
decompl-subst _ [A|_] _ _ _ :- print "Solving" {ppmapping A}, fail.
decompl-subst _ [] _ F F.
decompl-subst Map [mapping (fv VO) (hv VM _)|Tl] H F F2 :- mem.set? VM H T, !, % TODO: is the res of mem.set? always a val?
  print {ho.ppsubst H} {ho.ppass T},
  std.assert!(ho.deref-assmt H T TTT) "Should not fail",
  abs->lam TTT T', decomp Map T' T1, fo.eta-contract T1 T2, mem.assign VO F T2 F1,
  decompl-subst Map Tl H F1 F2. 
decompl-subst Map [mapping _ (hv VM _)|Tl] H F F2 :- mem.unset? VM H, decompl-subst Map Tl H F F2.
decompl-subst _ [L|_] H _ _ :- halt "Decompl mapping: failed on" {ppmapping L} {ho.ppsubst H}.

type decomp mappings -> ho.tm -> fo.fm -> o.
decomp _ (ho.con C)  (fo.fcon C).
decomp L (ho.lam B1) (fo.flam B2) :- pi x y\ decomp _ x y => decomp L (B1 x) (B2 y).
decomp L (ho.app L1) T :-
  forall2 (decomp L) L1 [Hd|Tl],
  fo.mk-app Hd Tl T.
decomp L (ho.uva VM TL) T :-
  forall2 (decomp L) TL T1,
  std.assert! (len {std.findall (mem L (mapping (fv VO) (hv VM _)))} (s z)) "Sanity check decompl1",
  fo.mk-app (fo.fuva VO) T1 T.
decomp L H _ :- halt "Fail in decomp" {ppmappings L} {ho.pp H}.

type add-new-links-aux ho.subst -> list ho.tm -> mappings -> mappings ->  fo.subst -> fo.subst -> o.
add-new-links-aux _ [] _ [] S S.
add-new-links-aux H [T|Ts] L L2 S S2 :- add-new-link H T L L1 S S1, add-new-links-aux H Ts L1 L2 S1 S2.

type add-new-link ho.subst -> ho.tm -> mappings -> mappings ->  fo.subst -> fo.subst -> o.
add-new-link _ (ho.uva N _) Links [] F1 F1 :- mem Links (mapping _ (hv N _)), !.
add-new-link H (ho.uva N L) Links [Link1 | Links1] F1 F3 :-              % Build new link
  mem.new F1 M F2,
  len L Arity, Link1 = mapping (fv M) (hv N (arity Arity)),
  add-new-link H (ho.app L) [Link1 | Links] Links1 F2 F3.
add-new-link H (ho.lam B) Links NewLinks F1 F2 :- pi x\ add-new-link H (B x) Links NewLinks F1 F2.
add-new-link H (ho.app L) Links NewLinks F1 F3 :- add-new-links-aux H L Links NewLinks F1 F3.
add-new-link _ (ho.con _) _ [] F F :- !.
add-new-link _ N _ [] F F :- name N.

type add-new-link-ass ho.subst -> ho.assignment -> mappings -> mappings ->  fo.subst -> fo.subst -> o.
add-new-link-ass H (ho.val Val) Links1 Links2 F1 F2 :- add-new-link H Val Links1 Links2 F1 F2.
add-new-link-ass H (ho.abs Abs) Links1 Links2 F1 F2 :- pi x\ add-new-link-ass H (Abs x) Links1 Links2 F1 F2.

type complete-mapping ho.subst -> ho.subst -> mappings -> mappings -> fo.subst -> fo.subst -> o.
complete-mapping _ [] L L F F.
complete-mapping H [none | Tl] L1 L2 F1 F2 :- complete-mapping H Tl L1 L2 F1 F2.
complete-mapping H [some T0 | Tl] L1 L3 F1 F3 :-
  ho.deref-assmt H T0 T,
  add-new-link-ass H T L1 L2 F1 F2, 
  std.append L1 L2 LAll,
  complete-mapping H Tl LAll L3 F2 F3.

type decompile mappings -> links -> ho.subst -> fo.subst -> fo.subst -> o.
decompile Map1 L HO FO FO2 :- std.do! [
  commit-links L L1_ HO HO1, !,                                                          % L1 conaints no link-eta (it may contain beta),
  print "# After decompl-eta, subst is" {ho.ppsubst HO1} "with links" {pplinks L1_},
  complete-mapping HO1 HO1 Map1 Map2 FO FO1,                                            % Foreach VM not mapped to OL, we build a link
  print "# After complete-mapping, mappings are" {ppmappings Map2} "with ho-subst" {ho.ppsubst HO1}, 
  decompl-subst Map2 Map2 HO1 FO1 FO2,
].

type test-maybe-eta-1 o.
type test-maybe-eta-2 o.
test-maybe-eta-1 :-
  pi f\ sigma B\
    fo.parse "λx.(X (Y x) f)" (fo.flam B),
  pi x\ maybe-eta x (B x) [x].

test-maybe-eta-2 :-
  fo.parse "λx. λy. (Z (Y  x) (X  x  y))" (fo.flam B),
  pi x\ maybe-eta x (B x) [x].
}