macro @X :- try4.fo.uv z.
macro @Y :- try4.fo.uv (s z).
macro @Z :- try4.fo.uv (s (s z)).
macro @f :- try4.fo.c "f".
macro @g :- try4.fo.c "g".
macro @h :- try4.fo.c "h".
macro @a :- try4.fo.c "a".
macro @b :- try4.fo.c "b".
macro @c :- try4.fo.c "c".
macro @app L :- try4.fo.app L.
macro @lam L :- try4.fo.lam L.

type eval-unif 
  list (triple diagnostic try4.fo.tm try4.fo.tm) -> 
  try4.ho.subst -> try4.ho.subst ->
  list try4.comp.link ->
  list try4.comp.link ->
  try4.fo.subst -> try4.fo.subst -> o.
eval-unif [] S S L L FO FO.

eval-unif [triple (error "comp1") L _ | _] HO_Subs1 _ L0 _ _ _ :- std.do![
  not (try4.comp.comp L _ L0 _ HO_Subs1 _)
].

eval-unif [triple (error "unif") L R | _] HO_Subs1 HO_Subs3 L0 L3 FOSol FOSol :- std.do![
  std.assert! (try4.comp.comp L LH L0 L1 HO_Subs1 HO_Subs2) "b1",
  std.assert! (try4.comp.comp R RH L1 L2 HO_Subs2 HO_Subs3) "b2",
  print "# comp Left:" LH,
  print "# comp Right:" RH,

  std.spy(try4.comp.solve-link L2 L3 HO_Subs3 HO_Subs4),
  print "## unif" LH "with" RH "in" HO_Subs4,
  not(std.spy(try4.ho.unif LH RH HO_Subs4 HO_Subs4_)),
].

eval-unif [triple ok L R | TL] HO_Subs1 HO_SubsNN L0 L4 FOSol FOSol4 :- std.do![
  std.assert! (try4.comp.comp L LH L0 L1 HO_Subs1 HO_Subs2) "b1",
  std.assert! (try4.comp.comp R RH L1 L2 HO_Subs2 HO_Subs3) "b2",
  print "# comp Left:" LH,
  print "# comp Right:" RH,

  print "## unif" LH "with" RH "in" HO_Subs3,
  std.spy(try4.ho.unif LH RH HO_Subs3 HO_Subs4),
  
  
  std.spy(try4.comp.solve-link L2 L3 HO_Subs4 HO_Subs5),

  try4.fo.alloc-subst L FOSol FOSol1,
  try4.fo.alloc-subst R FOSol1 FOSol2,
  std.spy(try4.comp.decompl L3 L3 HO_Subs5 FOSol2 FOSol3),

  print "FO Subst" L "==" R ":=" FOSol3,

  eval-unif TL HO_Subs5 HO_SubsNN L3 L4 FOSol3 FOSol4,
].

type xtest test try4.fo.tm -> o.
xtest (test N LR tt) :- std.do![
  eval-unif LR [] _SOL1 [] _Links [] FOSol,
  print "FO Subst" N "=" FOSol,
  std.forall LR (x\ sigma L R D\ triple D L R = x, (D = error _ ; try4.fo.equal FOSol L R)),
].
xtest (test _ LR ff) :- std.do! [
  not(eval-unif LR [] _S [] _L [] _FO)
].

macro @ok N X Y :- declare-test xtest (test N [triple ok X Y] tt).
macro @ko N X Y :- declare-test xtest (test N [triple ok X Y] ff).

macro @okl N X :- declare-test xtest (test N X tt).
macro @kol N X :- declare-test xtest (test N X ff).

@ok 1 (@app [@f, @X]) (@app [@f, @a]).
@ok 2 (@app [@X, @a]) (@app [@f, @a]).                                           % here two solutions for X: fun _ => a, fun x => x
@ok 3 (@lam x\ @app [@X, x, @a]) (@lam x\ @app [@f, x, @a]).

@ko 4 (@app [@f, @X]) @X.
@ko 5 (@app [@f, @X, @X]) (@app [@f, @a, @b]).
@ok 6 (@app [@f, @X, @Y, @X]) (@app [@f, (@app [@f, @Y]), @b, (@app [@f, @b])]).
@ok 7 (@lam x\ (@app [@f, @X])) (@lam x\ (@app [@f, @a])).

@ok 8 (@lam x\ @lam y\ @app [@X, x, y]) (@lam x\ @lam y\ @app [@X, x, y]).

@ok 9  (@lam x\ @lam y\ @app [@X, x, y]) (@lam x\ @lam y\ @app [@f, y]).
@ok 10 (@lam x\ @lam y\ @app [@X, x, y]) (@lam x\ @lam y\ @app [@X, y, x]).

@ok 11 (@lam x\ @app [@X, x]) (@lam x\ @app [@f, x, x, @a]).
@ok 12 (@lam x\ @app [@X, x, @a]) (@lam x\ @app [@f, x, x, @a]).                 % here two solutions for X: fun x _ => f x x a, fun x y => f x x y

@okl 13 [
  (triple ok (@lam x\ @app [@X, x]) (@lam x\ @app [@f, x])), 
  (triple ok @f @X)].

@okl 14 [
  (triple ok (@lam x\ @app [@X, x]) (@lam x\ @app [@f, x])), 
  (triple (error "unif") @g @X)]. % we fail early

@okl 15 [
  (triple ok (@lam x\ @app [@X, x]) (@lam x\ @app [@f, @app[@Y,x]])), 
  (triple (error "unif") @g @X)]. % we fail early for the wrong reason

@okl 16 [
  (triple ok (@lam x\ @app [@X, x]) (@lam x\ @app [@f, @app[@Y,x]])), 
  (triple ok @f @X)].

@okl 17 [
  (triple ok @X (@lam x\ x)),
  (triple ok (@app [@X, @a]) (@a))
]. % beta redex

@okl 18 [
  (triple ok (@lam x\ @app[@X, x, @a]) (@lam x\ @app[@f, x, @a]))
].                                                                               % here two solutions for X: fun x _ => f x a, fun x y => f x y

@okl 19 [
  (triple ok (@lam x\ @app[@X, x, @a]) (@lam x\ @app[@f, @a]))
].                                                                               % here two solutions for X: fun _ _ => f a, fun _ x => f x

@okl 20 [
  (triple (error "comp1") (@lam x\ @app[@X, x, x, @a]) (@lam x\ @app[@f, x, @a]))
]. % we are not in PF, X have two solutions: fun x _ => f x | fun _ x => f x
