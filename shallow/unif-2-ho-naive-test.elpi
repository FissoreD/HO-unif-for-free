macro @X :- ho.uv z.
macro @Y :- ho.uv (s z).
macro @Z :- ho.uv (s (s z)).
macro @f :- ho.c "f".
macro @g :- ho.c "g".
macro @h :- ho.c "h".
macro @a :- ho.c "a".
macro @b :- ho.c "b".
macro @c :- ho.c "c".
shorten ho.{ app , lam }.

type ho.test-shallow test-shallow ho.tm -> o.
ho.test-shallow (test-shallow L R tt) :- ho.unif L R S, std.assert! (ho.validSO S) "invalid SO", std.assert! (ho.equal L R S) "bug".
ho.test-shallow (test-shallow L R ff) :- not(ho.unif L R _).

macro @ok X Y :- declare-test-shallow ho.test-shallow (test-shallow X Y tt).
macro @ko X Y :- declare-test-shallow ho.test-shallow (test-shallow X Y ff).

@ok (app [@f, @X]) (app [@f, @a]).
@ok (app [@X, @a]) (app [@f, @a]).
@ko (app [@f, @X]) @X.
@ko (app [@f, @X, @X]) (app [@f, @a, @b]).
@ok (app [@f, @X, @Y, @X]) (app [@f, (app [@f, @Y]), @b, (app [@f, @b])]).
@ok (lam x\ (app [@f, @X])) (lam x\ (app [@f, @a])).

% we want this
@ko (lam x\ lam y\ app [@X, x, y]) (lam x\ lam y\ app [@f, y]).

