
namespace ho {

kind tm type.
type app list tm -> tm.
type lam (tm -> tm) -> tm.
type uv  nat -> tm.
type c string -> tm.

type unif tm -> tm -> list tm -> o.
unif (uv N) T S :- assigned? N S T1, unif T1 T S.
unif T (uv N) S :- assigned? N S T1, unif T T1 S.
unif (uv N) T S :- not(assigned? N S _), not (occ N T), assign N S T.
unif T (uv N) S :- not(assigned? N S _), not (occ N T), assign N S T.
unif (app L1) (app L2) S :- forall2 (x\y\unif x y S) L1 L2.
unif (lam F1) (lam F2) S :- pi x\ unif (F1 x) (F2 x) S.
unif (c X) (c X) _.

type forall2 (A -> A -> o) -> list A -> list A -> o.
forall2 _ [] [].
forall2 F [X|XS] [Y|YS] :- F X Y, forall2 F XS YS.

type occ nat -> tm -> o.
occ N (uv N).
occ N (app L) :- exists (occ N) L.
occ N (lam F) :- pi x\ occ N (F x).

type exists (A -> o) -> list A -> o.
exists F [X|XS] :- F X ; exists F XS.

type validSO list tm -> o.
validSO L :- var L.
validSO [X|XS] :- (ground_term X ; var X), validSO XS.

type equal tm -> tm -> list tm -> o.
equal (uv N) T1 S :- assigned? N S T, equal T T1 S.
equal T1 (uv N) S :- assigned? N S T, equal T1 T S.
equal (app L1) (app L2) S :- forall2 (x\y\equal x y S) L1 L2.
equal (lam F1) (lam F2) S :- pi x\ equal x x S => equal (F1 x) (F2 x) S.
equal (c X) (c X) _.
equal (uv N) (uv N) _.



}