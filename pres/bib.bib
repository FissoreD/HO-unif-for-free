@inproceedings{krebbers17,
  title     = {\href{https://iris-project.org/pdfs/2017-popl-proofmode-final.pdf}
               {Interactive proofs in higher-order concurrent separation logic}},
  author    = {Krebbers, Robbert and Timany, Amin and Birkedal, Lars},
  booktitle = {Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages},
  pages     = {205--217},
  year      = {2017}
}

@article{krebbers23,
  title     = {\href{https://iris-project.org/pdfs/2023-pldi-diaframe-disj.pdf}
               {Beyond Backtracking: Connections in Fine-Grained Concurrent Separation Logic}},
  author    = {Mulder, Ike and Czajka, {\L}ukasz and Krebbers, Robbert},
  journal   = {Proceedings of the ACM on Programming Languages},
  volume    = {7},
  number    = {PLDI},
  pages     = {1340--1364},
  year      = {2023},
  publisher = {ACM New York, NY, USA}
}

@article{krebbers23b,
  title     = {\href{https://iris-project.org/pdfs/2023-oopsla-diaframe2-final.pdf}
               {Proof automation for linearizability in separation logic}},
  author    = {Mulder, Ike and Krebbers, Robbert},
  journal   = {Proceedings of the ACM on Programming Languages},
  volume    = {7},
  number    = {OOPSLA1},
  pages     = {462--491},
  year      = {2023},
  publisher = {ACM New York, NY, USA}
}

@article{ohearn19,
  title     = {\href{https://dl.acm.org/doi/pdf/10.1145/3211968}
               {Separation logic}},
  author    = {O'Hearn, Peter},
  journal   = {Communications of the ACM},
  volume    = {62},
  number    = {2},
  pages     = {86--95},
  year      = {2019},
  publisher = {ACM New York, NY, USA}
}

@inproceedings{reynolds02,
  title        = {\href{https://www.cs.cmu.edu/~jcr/seplogic.pdf}
                  {Separation logic: A logic for shared mutable data structures}},
  author       = {Reynolds, John C},
  booktitle    = {Proceedings 17th Annual IEEE Symposium on Logic in Computer Science},
  pages        = {55--74},
  year         = {2002},
  organization = {IEEE}
}

@inproceedings{wadler89,
  author    = {Wadler, P. and Blott, S.},
  title     = {How to Make Ad-Hoc Polymorphism Less Ad Hoc},
  year      = {1989},
  isbn      = {0897912942},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/75277.75283},
  doi       = {10.1145/75277.75283},
  abstract  = {This paper presents type classes, a new approach to ad-hoc polymorphism. Type classes permit overloading of arithmetic operators such as multiplication, and generalise the “eqtype variables” of Standard ML. Type classes extend the Hindley/Milner polymorphic type system, and provide a new approach to issues that arise in object-oriented programming, bounded type quantification, and abstract data types. This paper provides an informal introduction to type classes, and defines them formally by means of type inference rules.},
  booktitle = {Proceedings of the 16th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  pages     = {60–76},
  numpages  = {17},
  location  = {Austin, Texas, USA},
  series    = {POPL '89}
}

@article{selsam20,
  author     = {Daniel Selsam and
                Sebastian Ullrich and
                Leonardo de Moura},
  title      = {Tabled Typeclass Resolution},
  journal    = {CoRR},
  volume     = {abs/2001.04301},
  year       = {2020},
  url        = {https://arxiv.org/abs/2001.04301},
  eprinttype = {arXiv},
  eprint     = {2001.04301},
  timestamp  = {Thu, 29 Sep 2022 08:36:57 +0200},
  biburl     = {https://dblp.org/rec/journals/corr/abs-2001-04301.bib},
  bibsource  = {dblp computer science bibliography, https://dblp.org}
}

@article{mellish85,
  title     = {Some global optimizations for a Prolog compiler},
  author    = {Mellish, Christopher S},
  journal   = {The Journal of Logic Programming},
  volume    = {2},
  number    = {1},
  pages     = {43--66},
  year      = {1985},
  publisher = {North-Holland}
}

@inproceedings{sozeau08,
  author    = {Sozeau, Matthieu
               and Oury, Nicolas},
  editor    = {Mohamed, Otmane Ait
               and Mu{\~{n}}oz, C{\'e}sar
               and Tahar, Sofi{\`e}ne},
  title     = {First-Class Type Classes},
  booktitle = {Theorem Proving in Higher Order Logics},
  year      = {2008},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {278--293},
  abstract  = {Type Classes have met a large success in Haskell and Isabelle, as a solution for sharing notations by overloading and for specifying with abstract structures by quantification on contexts. However, both systems are limited by second-class implementations of these constructs, and these limitations are only overcomed by ad-hoc extensions to the respective systems. We propose an embedding of type classes into a dependent type theory that is first-class and supports some of the most popular extensions right away. The implementation is correspondingly cheap, general and integrates well inside the system, as we have experimented in Coq. We show how it can be used to help structured programming and proving by way of examples.},
  isbn      = {978-3-540-71067-7}
}

@inproceedings{tassi13,
  author    = {Mahboubi, Assia
               and Tassi, Enrico},
  editor    = {Blazy, Sandrine
               and Paulin-Mohring, Christine
               and Pichardie, David},
  title     = {Canonical Structures for the Working Coq User},
  booktitle = {Interactive Theorem Proving},
  year      = {2013},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {19--34},
  abstract  = {This paper provides a gentle introduction to the art of programming type inference with the mechanism of Canonical Structures. Programmable type inference has been one of the key ingredients for the successful formalization of the Odd Order Theorem using the Coq proof assistant. The paper concludes comparing the language of Canonical Structures to the one of Type Classes and Unification Hints.},
  isbn      = {978-3-642-39634-2}
}

@inproceedings{asperti09,
  author    = {Asperti, Andrea
               and Ricciotti, Wilmer
               and Sacerdoti Coen, Claudio
               and Tassi, Enrico},
  editor    = {Berghofer, Stefan
               and Nipkow, Tobias
               and Urban, Christian
               and Wenzel, Makarius},
  title     = {Hints in Unification},
  booktitle = {Theorem Proving in Higher Order Logics},
  year      = {2009},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {84--98},
  abstract  = {Several mechanisms such as Canonical Structures [14], Type Classes [13,16], or Pullbacks [10] have been recently introduced with the aim to improve the power and flexibility of the type inference algorithm for interactive theorem provers. We claim that all these mechanisms are particular instances of a simpler and more general technique, just consisting in providing suitable hints to the unification procedure underlying type inference. This allows a simple, modular and not intrusive implementation of all the above mentioned techniques, opening at the same time innovative and unexpected perspectives on its possible applications.},
  isbn      = {978-3-642-03359-9}
}

@inproceedings{hall94,
  author    = {Hall, Cordelia
               and Hammond, Kevin
               and Jones, Simon Peyton
               and Wadler, Philip},
  editor    = {Sannella, Donald},
  title     = {Type classes in Haskell},
  booktitle = {Programming Languages and Systems --- ESOP '94},
  year      = {1994},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {241--256},
  abstract  = {This paper defines a set of type inference rules for resolving over-loading introduced by type classes. Programs including type classes are transformed into ones which may be typed by the Hindley-Milner inference rules. In contrast to other work on type classes, the rules presented here relate directly to user programs. An innovative aspect of this work is the use of second-order lambda calculus to record type information in the program.},
  isbn      = {978-3-540-48376-2}
}

@inproceedings{sozeau15,
  author    = {Beta Ziliani and
               Matthieu Sozeau},
  editor    = {Kathleen Fisher and
               John H. Reppy},
  title     = {A unification algorithm for Coq featuring universe polymorphism and
               overloading},
  booktitle = {Proceedings of the 20th {ACM} {SIGPLAN} International Conference on
               Functional Programming, {ICFP} 2015, Vancouver, BC, Canada, September
               1-3, 2015},
  pages     = {179--191},
  publisher = {{ACM}},
  year      = {2015},
  url       = {https://doi.org/10.1145/2784731.2784751},
  doi       = {10.1145/2784731.2784751},
  timestamp = {Wed, 23 Jun 2021 16:58:51 +0200},
  biburl    = {https://dblp.org/rec/conf/icfp/ZilianiS15.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{miller91,
  author    = {Miller, Dale},
  editor    = {Schroeder-Heister, Peter},
  title     = {A logic programming language with lambda-abstraction, function variables, and simple unification},
  booktitle = {Extensions of Logic Programming},
  year      = {1991},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {253--281},
  abstract  = {It has been argued elsewhere that a logic programming language with function variables and $\lambda$-abstractions within terms makes a very good meta-programming language, especially when an object language contains notions of bound variables and scope. The $\lambda$Prolog logic programming language and the closely related Elf and Isabelle systems provide meta-programs with both function variables and $\lambda$-abstractions by containing implementations of higher-order unification. In this paper, we present a logic programming language, called L$\lambda$, that also contains both function variables and $\lambda$-abstractions, but certain restriction are placed on occurrences of function variables. As a result, an implementation of L$\lambda$ does not need to implement full higher-order unification. Instead, an extension to first-order unification that respects bound variable names and scopes is all that is required. Such unification problems are shown to be decidable and to possess most general unifiers when unifiers exist. A unification algorithm and logic programming interpreter are described and proved correct. Several examples of using L$\lambda$ as a meta-programming language are presented.},
  isbn      = {978-3-540-46879-0}
}

@book{miller12,
  place     = {Cambridge},
  title     = {Programming with Higher-Order Logic},
  doi       = {10.1017/CBO9781139021326},
  publisher = {Cambridge University Press},
  author    = {Miller, Dale and Nadathur, Gopalan},
  year      = {2012}
}

@misc{gacek08-abella,
  title         = {The Abella Interactive Theorem Prover (System Description)},
  author        = {Andrew Gacek},
  year          = {2008},
  eprint        = {0803.2305},
  archiveprefix = {arXiv},
  primaryclass  = {cs.LO}
}

@inproceedings{miller88,
  author = {Nadathur, Gopalan and Miller, Dale},
  year   = {1988},
  month  = {06},
  pages  = {810-827},
  title  = {An Overview of Lambda-Prolog}
}

@misc{fruehwirth17,
  title         = {Constraint Handling Rules - What Else?},
  author        = {Thom Fruehwirth},
  year          = {2017},
  eprint        = {1701.02668},
  archiveprefix = {arXiv},
  primaryclass  = {cs.PL}
}

@article{curry34,
  author  = {Curry, Haskell B.},
  title   = {Functionality in Combinatory Logic},
  journal = {Proceedings of the National Academy of Sciences},
  volume  = {20},
  number  = {9},
  pages   = {584--590},
  year    = {1934}
}

@incollection{howard80,
  author    = {Howard, William A.},
  title     = {The Formulae-as-Types Notion of Construction},
  booktitle = {To H. B. Curry: Essays on Combinatory Logic, Lambda Calculus, and Formalism},
  pages     = {479--490},
  year      = {1980}
}

@article{mcCune92,
  title   = {Experiments with discrimination-tree indexing and path indexing for term retrieval},
  author  = {William McCune},
  journal = {Journal of Automated Reasoning},
  year    = {1992},
  volume  = {9},
  pages   = {147-167},
  url     = {https://api.semanticscholar.org/CorpusID:14153088}
}

@article{sahlin94,
  author  = {Sahlin, Dan},
  year    = {1994},
  month   = {11},
  pages   = {7-51},
  title   = {Mixtus: An automatic partial evaluator for full Prolog},
  volume  = {12},
  journal = {New Generation Computing},
  doi     = {10.1007/BF03038271}
}

@article{oliveira10,
  author     = {Oliveira, Bruno C.d.S. and Moors, Adriaan and Odersky, Martin},
  title      = {Type Classes as Objects and Implicits},
  year       = {2010},
  issue_date = {October 2010},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {45},
  number     = {10},
  issn       = {0362-1340},
  url        = {https://doi.org/10.1145/1932682.1869489},
  doi        = {10.1145/1932682.1869489},
  abstract   = {Type classes were originally developed in Haskell as a disciplined alternative to ad-hoc polymorphism. Type classes have been shown to provide a type-safe solution to important challenges in software engineering and programming languages such as, for example, retroactive extension of programs. They are also recognized as a good mechanism for concept-based generic programming and, more recently, have evolved into a mechanism for type-level computation.This paper presents a lightweight approach to type classes in object-oriented (OO) languages with generics using the CONCEPT pattern and implicits (a type-directed implicit parameter passing mechanism). This paper also shows how Scala's type system conspires with implicits to enable, and even surpass, many common extensions of the Haskell type class system, making Scala ideally suited for generic programming in the large.},
  journal    = {SIGPLAN Not.},
  month      = {oct},
  pages      = {341–360},
  numpages   = {20},
  keywords   = {c++ concepts, scala, type classes, abstract datatypes}
}

@article{warren89,
  author     = {Debray, Saumya K. and Warren, David S.},
  title      = {Functional computations in logic programs},
  year       = {1989},
  issue_date = {July 1989},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {11},
  number     = {3},
  issn       = {0164-0925},
  url        = {https://doi.org/10.1145/65979.65984},
  doi        = {10.1145/65979.65984},
  abstract   = {Although the ability to simulate nondeterminism and to compute multiple solutions for a single query is a powerful and attractive feature of logic programming languages, it is expensive in both time and space. Since programs in such languages are very often functional, that is, they do not produce more than one distinct solution for a single input, this overhead is especially undesirable. This paper describes how programs may be analyzed statically to determine which literals and predicates are functional, and how the program may then be optimized using this information. Our notion of “functionality” subsumes the notion of “determinacy” that has been considered by various researchers. Our algorithm is less reliant on language features such as the cut, and thus extends more easily to parallel execution strategies, than others that have been proposed.},
  journal    = {ACM Trans. Program. Lang. Syst.},
  month      = {7},
  pages      = {451–481},
  numpages   = {31}
}

@article{hill94,
  author = {Hill, Patricia and Gallagher, J},
  year   = {1994},
  month  = {09},
  pages  = {},
  title  = {Meta-Programming in Logic Programming},
  doi    = {10.1093/oso/9780198537922.003.0010}
}

@inproceedings{pfenning89-elf,
  author    = {Pfenning, F.},
  title     = {Elf: a language for logic definition and verified metaprogramming},
  year      = {1989},
  isbn      = {0818619546},
  publisher = {IEEE Press},
  booktitle = {Proceedings of the Fourth Annual Symposium on Logic in Computer Science},
  pages     = {313–322},
  numpages  = {10},
  location  = {Pacific Grove, California, USA}
}

@inproceedings{pfenning99-twelf,
  author    = {Pfenning, Frank
               and Sch{\"u}rmann, Carsten},
  title     = {System Description: Twelf --- A Meta-Logical Framework for Deductive Systems},
  booktitle = {Automated Deduction --- CADE-16},
  year      = {1999},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {202--206},
  abstract  = {Twelf is a meta-logical framework for the specification, implementation, and meta-theory of deductive systems from the theory of programming languages and logics. It relies on the LF type theory and the judgments-as-types methodology for specification [HHP93], a constraint logic programming interpreter for implementation [Pfe91], and the meta-logic M2 for reasoning about object languages encoded in LF [SP98]. It is a significant extension and complete reimplementation of the Elf system [Pfe94].},
  isbn      = {978-3-540-48660-2}
}


@inproceedings{wenzel08,
  author    = {Wenzel, Makarius
               and Paulson, Lawrence C.
               and Nipkow, Tobias},
  editor    = {Mohamed, Otmane Ait
               and Mu{\~{n}}oz, C{\'e}sar
               and Tahar, Sofi{\`e}ne},
  title     = {The Isabelle Framework},
  booktitle = {Theorem Proving in Higher Order Logics},
  year      = {2008},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {33--38},
  abstract  = {Isabelle, which is available from http://isabelle.in.tum.de, is a generic framework for interactive theorem proving. The Isabelle/Pure meta-logic allows the formalization of the syntax and inference rules of a broad range of object-logics following the general idea of natural deduction [32,33]. The logical core is implemented according to the well-known ``LCF approach'' of secure inferences as abstract datatype constructors in ML [16]; explicit proof terms are also available [8]. Isabelle/Isar provides sophisticated extra-logical infrastructure supporting structured proofs and specifications, including concepts for modular theory development. Isabelle/HOL is a large application within the generic framework, with plenty of logic-specific add-on tools and a large theory library. Other notable object-logics are Isabelle/ZF (Zermelo-Fraenkel set-theory, see [34,36] and Isabelle/HOLCF [26] (Scott's domain theory within HOL). Users can build further formal-methods tools on top, e.g. see [53].},
  isbn      = {978-3-540-71067-7}
}

@book{mipkow02,
  added-at  = {2023-12-13T03:40:04.000+0100},
  author    = {Nipkow, Tobias and Paulson, Lawrence C. and Wenzel, Markus},
  biburl    = {https://www.bibsonomy.org/bibtex/26ca90f09d85d8d70b58e441d052da780/admin},
  ee        = {https://doi.org/10.1007/3-540-45949-9},
  interhash = {8daeb422681d849d8af4fe40aeaaa7cd},
  intrahash = {6ca90f09d85d8d70b58e441d052da780},
  isbn      = {3-540-43376-7},
  keywords  = {},
  publisher = {Springer},
  series    = {Lecture Notes in Computer Science},
  timestamp = {2023-12-13T03:40:04.000+0100},
  title     = {Isabelle/HOL - A Proof Assistant for Higher-Order Logic},
  volume    = 2283,
  year      = 2002
}

@article{paulson93,
  author     = {Paulson, Lawrence C.},
  title      = {Set theory for verification. I: from foundations to functions},
  year       = {1993},
  issue_date = {Dec. 1993},
  publisher  = {Springer-Verlag},
  address    = {Berlin, Heidelberg},
  volume     = {11},
  number     = {3},
  issn       = {0168-7433},
  url        = {https://doi.org/10.1007/BF00881873},
  doi        = {10.1007/BF00881873},
  journal    = {J. Autom. Reason.},
  month      = {dec},
  pages      = {353–389},
  numpages   = {37},
  keywords   = {set theory, isabelle, higher-order syntax, generic theorem proving, Ramsey's Theorem}
}
@inproceedings{felty88,
  author    = {Amy Felty and Dale Miller},
  title     = {Specifying theorem provers in a higher-order logic
               programming language},
  editor    = {Ewing Lusk and Ross Overbeck},
  booktitle = {{Ninth International Conference on Automated
               Deduction}},
  address   = {Argonne, IL},
  publisher = {Springer},
  pages     = {61--80},
  month     = may,
  year      = {1988},
  series    = lncs,
  number    = {310},
  doi       = {10.1007/BFb0012823}
}

@inproceedings{felty93,
  title     = {Encoding the Calculus of Constructions in a
               Higher-Order Logic},
  author    = {Amy Felty},
  pages     = {233--244},
  booktitle = lics93,
  publisher = {IEEE},
  editor    = {M. Vardi},
  month     = jun,
  year      = {1993},
  doi       = {10.1109/LICS.1993.287584}
}

@inproceedings{chargueraud10,
  author    = {Chargu{\'e}raud, Arthur},
  editor    = {Kaufmann, Matt
               and Paulson, Lawrence C.},
  title     = {The Optimal Fixed Point Combinator},
  booktitle = {Interactive Theorem Proving},
  year      = {2010},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {195--210},
  abstract  = {In this paper, we develop a general theory of fixed point combinators, in higher-order logic equipped with Hilbert's epsilon operator. This combinator allows for a direct and effective formalization of corecursive values, recursive and corecursive functions, as well as functions mixing recursion and corecursion. It supports higher-order recursion, nested recursion, and offers a proper treatment of partial functions in the sense that domains need not be hardwired in the definition of functionals. Our work, which has been entirely implemented in Coq, unifies and generalizes existing results on contraction conditions and complete ordered families of equivalences, and relies on the theory of optimal fixed points for the treatment of partial functions. It provides a practical way to formalize circular definitions in higher-order logic.},
  isbn      = {978-3-642-14052-5}
}

@article{krebbers18,
  title   = {Iris from the ground up: A modular foundation for higher-order concurrent separation logic},
  author  = {Ralf Jung and Robbert Krebbers and Jacques-Henri Jourdan and Ale{\vs} Bizjak and Lars Birkedal and Derek Dreyer},
  journal = {Journal of Functional Programming},
  year    = {2018},
  volume  = {28},
  url     = {https://api.semanticscholar.org/CorpusID:2023423},
  doi     = {10.1017/S0956796818000151}
}

@article{miller92,
  author  = {Dale Miller},
  title   = {Unification under a mixed prefix},
  year    = {1992},
  journal = {Journal of Symbolic Computation},
  pages   = {321--358},
  volume  = {14},
  number  = {4},
  doi     = {10.1016/0747-7171(92)90011-R},
  pdf     = {http://www.lix.polytechnique.fr/Labo/Dale.Miller/papers/jsc92.pdf}
}

@inproceedings{dunchev15,
  author    = {Cvetan Dunchev and Ferruccio Guidi and Claudio
               Sacerdoti Coen and Enrico Tassi},
  title     = {{ELPI:} Fast, Embeddable, $\lambda${Prolog}
               Interpreter},
  booktitle = {Logic for Programming, Artificial Intelligence, and
               Reasoning - 20th International Conference, {LPAR-20}
               2015, Suva, Fiji, November 24-28, 2015, Proceedings},
  editor    = {Martin Davis and Ansgar Fehnker and Annabelle McIver
               and Andrei Voronkov},
  publisher = pub-sv,
  series    = lncs,
  volume    = {9450},
  pages     = {460--468},
  year      = {2015},
  url       = {http://dx.doi.org/10.1007/978-3-662-48899-7\_32},
  doi       = {10.1007/978-3-662-48899-7\_32}
}

@misc{coq-refman,
  title        = {The {Coq} Reference Manual -- Release 8.18.0},
  author       = {{The Coq Development Team}},
  year         = {2023},
  howpublished = {\url{https://coq.inria.fr/doc/V8.18.0/refman}}
}

@inproceedings{colin23,
  author    = {Rothgang, Colin
               and Rabe, Florian
               and Benzm{\"u}ller, Christoph},
  editor    = {Pientka, Brigitte
               and Tinelli, Cesare},
  title     = {Theorem Proving in Dependently-Typed Higher-Order Logic},
  booktitle = {Automated Deduction -- CADE 29},
  year      = {2023},
  publisher = {Springer Nature Switzerland},
  address   = {Cham},
  pages     = {438--455},
  abstract  = {Higher-order logic HOL offers a very simple syntax and semantics for representing and reasoning about typed data structures. But its type system lacks advanced features where types may depend on terms. Dependent type theory offers such a rich type system, but has rather substantial conceptual differences to HOL, as well as comparatively poor proof automation support.},
  isbn      = {978-3-031-38499-8}
}

@inproceedings{tassi18,
  title       = {{Elpi: an extension language for Coq (Metaprogramming Coq in the Elpi $\lambda$Prolog dialect)}},
  author      = {Tassi, Enrico},
  url         = {https://inria.hal.science/hal-01637063},
  booktitle   = {{The Fourth International Workshop on Coq for Programming Languages}},
  address     = {Los Angeles, CA, United States},
  year        = {2018},
  month       = Jan,
  keywords    = {Coq ; $\lambda$Prolog ; metaprogramming ; extension language},
  pdf         = {https://inria.hal.science/hal-01637063/file/coqpl2018.pdf},
  hal_id      = {hal-01637063},
  hal_version = {v1}
}

@inproceedings{tassi19,
  title       = {{Deriving proved equality tests in Coq-elpi: Stronger induction principles for containers in Coq}},
  author      = {Tassi, Enrico},
  url         = {https://inria.hal.science/hal-01897468},
  booktitle   = {{ITP 2019 - 10th International Conference on Interactive Theorem Proving}},
  address     = {Portland, OR, United States},
  year        = {2019},
  month       = Sep,
  doi         = {10.4230/LIPIcs.CVIT.2016.23},
  keywords    = {Induction ; Coq ; Equality test ; Parametricity translation ; Containers},
  pdf         = {https://inria.hal.science/hal-01897468v2/file/induction.pdf},
  hal_id      = {hal-01897468},
  hal_version = {v2}
}

@inproceedings{tassi23,
  title       = {{Practical and sound equality tests, automatically -- Deriving eqType instances for Jasmin's data types with Coq-Elpi}},
  author      = {Gr{\'e}goire, Benjamin and L{\'e}chenet, Jean-Christophe and Tassi, Enrico},
  url         = {https://inria.hal.science/hal-03800154},
  booktitle   = {{CPP '23: 12th ACM SIGPLAN International Conference on Certified Programs and Proofs}},
  address     = {Boston, MA, USA},
  publisher   = {{ACM}},
  series      = {CPP 2023: Proceedings of the 12th ACM SIGPLAN International Conference on Certified Programs and Proofs},
  pages       = {167-181},
  year        = {2023},
  month       = Jan,
  doi         = {10.1145/3573105.3575683},
  pdf         = {https://inria.hal.science/hal-03800154/file/feqb.pdf},
  hal_id      = {hal-03800154},
  hal_version = {v1}
}

@inproceedings{fissore23,
  title       = {{A new Type-Class solver for Coq in Elpi}},
  author      = {Fissore, Davide and Tassi, Enrico},
  url         = {https://inria.hal.science/hal-04467855},
  booktitle   = {{The Coq Workshop 2023}},
  address     = {Bialystok, Poland},
  year        = {2023},
  month       = Jul,
  keywords    = {type classes ; coq ; lambda-prolog},
  pdf         = {https://inria.hal.science/hal-04467855/file/coq2023_TC-elpi.pdf},
  hal_id      = {hal-04467855},
  hal_version = {v1}
}

@unpublished{fissore24,
  title       = {{Higher-Order unification for free!}},
  author      = {Fissore, Davide and Tassi, Enrico},
  url         = {https://inria.hal.science/hal-04547069},
  note        = {working paper or preprint},
  year        = {2024},
  month       = Apr,
  keywords    = {Logic Programming ; Meta-Programming ; Higher-Order Unification},
  pdf         = {https://inria.hal.science/hal-04547069v2/file/main.pdf},
  hal_id      = {hal-04547069},
  hal_version = {v2}
}

@inproceedings{tassi16,
  author    = {Dunchev, Cvetan and Coen, Claudio Sacerdoti and Tassi, Enrico},
  title     = {Implementing HOL in an Higher Order Logic Programming Language},
  year      = {2016},
  isbn      = {9781450347778},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/2966268.2966272},
  doi       = {10.1145/2966268.2966272},
  abstract  = {We present a proof-of-concept prototype of a (constructive variant of an) HOL interactive theorem prover written in a Higher Order Logic Programming (HOLP) language, namely an extension of λProlog. The prototype is meant to support the claim, that we reinforce, that HOLP is the class of languages that provides the right abstraction level and programming primitives to obtain concise implementations of theorem provers. We identify and advocate for a programming technique, that we call semi-shallow embedding, while at the same time identifying the reasons why pure λProlog is not sufficient to support that technique, and it needs to be extended.},
  booktitle = {Proceedings of the Eleventh Workshop on Logical Frameworks and Meta-Languages: Theory and Practice},
  articleno = {4},
  numpages  = {10},
  keywords  = {Higher Order Logic Programming, HOL, Constraints, λProlog},
  location  = {Porto, Portugal},
  series    = {LFMTP '16}
}

@article{tassi19-chr,
  title     = {Implementing type theory in higher order constraint logic programming},
  author    = {Guidi, Ferruccio and Coen, Claudio Sacerdoti and Tassi, Enrico},
  journal   = {Mathematical Structures in Computer Science},
  volume    = {29},
  number    = {8},
  pages     = {1125--1150},
  year      = {2019},
  publisher = {Cambridge University Press}
}

@inproceedings{nipkow93,
  author    = {Tobias Nipkow},
  title     = {Functional Unification of Higher-Order Patterns},
  booktitle = {Proc.\ 8th IEEE Symp.\ Logic in Computer Science},
  pages     = {64--74},
  year      = 1993
}

@inproceedings{pfenning88,
  author    = {Pfenning, Frank and Elliott, Conal},
  title     = {Higher-order abstract syntax},
  year      = {1988},
  isbn      = {0897912691},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/53990.54010},
  doi       = {10.1145/53990.54010},
  abstract  = {We describe motivation, design, use, and implementation of higher-order abstract syntax as a central representation for programs, formulas, rules, and other syntactic objects in program manipulation and other formal systems where matching and substitution or unification are central operations. Higher-order abstract syntax incorporates name binding information in a uniform and language generic way. Thus it acts as a powerful link integrating diverse tools in such formal environments. We have implemented higher-order abstract syntax, a supporting matching and unification algorithm, and some clients in Common Lisp in the framework of the Ergo project at Carnegie Mellon University.},
  booktitle = {Proceedings of the ACM SIGPLAN 1988 Conference on Programming Language Design and Implementation},
  pages     = {199--208},
  numpages  = {10},
  location  = {Atlanta, Georgia, USA},
  series    = {PLDI '88}
}

@inproceedings{pientka18,
  title  = {Extensions to Miller's Pattern Unification for Dependent Types and Records},
  author = {Andreas Abel and Brigitte Pientka},
  year   = {2018},
  url    = {https://api.semanticscholar.org/CorpusID:51885863}
}

@inproceedings{nadathur2001,
  author    = {Nadathur, Gopalan},
  editor    = {Kuchen, Herbert
               and Ueda, Kazunori},
  title     = {The Metalanguage $\lambda$prolog and Its Implementation},
  booktitle = {Functional and Logic Programming},
  year      = {2001},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {1--20},
  abstract  = {Stimulated by concerns of software certification especially as it relates to mobile code, formal structures such as specifications and proofs are beginning to play an explicit role in computing. In represent- ing and manipulating such structures, an approach is needed that pays attention to the binding operation that is present in them. The language $\lambda$Prolog provides programming support for a higher-order treatment of abstract syntax that is especially suited to this task. This support is realized by enhancing the traditional strength of logic programming in the metalanguage realm with an ability for dealing directly with binding structure. This paper identifies the features of Prolog that endow it with such a capability, illustrates their use and and describes methods for their implementation. Also discussed is a new realization of Prolog called Teyjus that incorporates the implementation ideas presented.},
  isbn      = {978-3-540-44716-0}
}

@inproceedings{wenzel97,
  author    = {Wenzel, Markus},
  editor    = {Gunter, Elsa L.
               and Felty, Amy},
  title     = {Type classes and overloading in higher-order logic},
  booktitle = {Theorem Proving in Higher Order Logics},
  year      = {1997},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {307--322},
  abstract  = {Type classes and overloading are shown to be independent concepts that can both be added to simple higher-order logics in the tradition of Church and Gordon, without demanding more logical expressiveness. In particular, model-theoretic issues are not affected. Our metalogical results may serve as a foundation of systems like Isabelle/Pure that offer the user Haskell-style order-sorted polymorphism as an extended syntactic feature. The latter can be used to describe simple abstract theories with a single carrier type and a fixed signature of operations.},
  isbn      = {978-3-540-69526-4}
}

@article{huet75,
  author    = {G{\'{e}}rard P. Huet},
  title     = {A Unification Algorithm for Typed lambda-Calculus},
  journal   = {Theor. Comput. Sci.},
  volume    = {1},
  number    = {1},
  pages     = {27--57},
  year      = {1975},
  url       = {https://doi.org/10.1016/0304-3975(75)90011-0},
  doi       = {10.1016/0304-3975(75)90011-0},
  timestamp = {Wed, 17 Feb 2021 22:01:29 +0100},
  biburl    = {https://dblp.org/rec/journals/tcs/Huet75.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{tassi19,
  title     = {Implementing type theory in higher order constraint logic programming},
  author    = {Guidi, Ferruccio and Coen, Claudio Sacerdoti and Tassi, Enrico},
  journal   = {Mathematical Structures in Computer Science},
  volume    = {29},
  number    = {8},
  pages     = {1125--1150},
  year      = {2019},
  publisher = {Cambridge University Press},
  doi       = {10.1017/S0960129518000427}
}
@book{chlipala13,
  author    = {Chlipala, Adam},
  title     = {Certified Programming with Dependent Types: A Pragmatic Introduction to the Coq Proof Assistant},
  year      = {2013},
  isbn      = {0262026651},
  publisher = {The MIT Press},
  abstract  = {The technology of mechanized program verification can play a supporting role in many kinds of research projects in computer science, and related tools for formal proof-checking are seeing increasing adoption in mathematics and engineering. This book provides an introduction to the Coq software for writing and checking mathematical proofs. It takes a practical engineering focus throughout, emphasizing techniques that will help users to build, understand, and maintain large Coq developments and minimize the cost of code change over time. Two topics, rarely discussed elsewhere, are covered in detail: effective dependently typed programming (making productive use of a feature at the heart of the Coq system) and construction of domain-specific proof tactics. Almost every subject covered is also relevant to interactive computer theorem proving in general, not just program verification, demonstrated through examples of verified programs applied in many different sorts of formalizations. The book develops a unique automated proof style and applies it throughout; even experienced Coq users may benefit from reading about basic Coq concepts from this novel perspective. The book also offers a library of tactics, or programs that find proofs, designed for use with examples in the book. Readers will acquire the necessary skills to reimplement these tactics in other settings by the end of the book. All of the code appearing in the book is freely available online.}
}

@inproceedings{pientka10-beluga,
  author    = {Brigitte Pientka and
               Jana Dunfield},
  editor    = {J{\"{u}}rgen Giesl and
               Reiner H{\"{a}}hnle},
  title     = {Beluga: {A} Framework for Programming and Reasoning with Deductive
               Systems (System Description)},
  booktitle = {Automated Reasoning, 5th International Joint Conference, {IJCAR} 2010,
               Edinburgh, UK, July 16-19, 2010. Proceedings},
  series    = {Lecture Notes in Computer Science},
  volume    = {6173},
  pages     = {15--21},
  publisher = {Springer},
  year      = {2010},
  url       = {https://doi.org/10.1007/978-3-642-14203-1\_2},
  doi       = {10.1007/978-3-642-14203-1\_2},
  timestamp = {Fri, 11 Dec 2020 08:12:14 +0100},
  biburl    = {https://dblp.org/rec/conf/cade/PientkaD10.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{pientka05,
  author    = {Pientka, Brigitte},
  editor    = {Nieuwenhuis, Robert},
  title     = {Tabling for Higher-Order Logic Programming},
  booktitle = {Automated Deduction -- CADE-20},
  year      = {2005},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {54--68},
  abstract  = {We describe the design and implementation of a higher-order tabled logic programming interpreter where some redundant and infinite computation is eliminated by memoizing sub-computation and re-using its result later. In particular, we focus on the table design and table access in the higher-order setting where many common operations are undecidable in general. To achieve a space and time efficient implementation, we rely on substitution factoring and higher-order substitution tree indexing. Experimental results from a wide range of examples (propositional theorem proving, refinement type checking, small-step evaluator) demonstrate that higher-order tabled logic programming yields a more robust and more powerful proof procedure.},
  isbn      = {978-3-540-31864-4}
}

@book{pientka03,
  title     = {Tabled higher-order logic programming},
  author    = {Pientka, Brigitte},
  year      = {2003},
  publisher = {Carnegie Mellon University}
}

% Articolo sull'elaborazione
@article{tassi12,
  author  = {Asperti, Andrea and Ricciotti, Wilmer and Sacerdoti Coen, Claudio and Tassi, Enrico},
  year    = {2012},
  month   = {02},
  pages   = {},
  title   = {A Bi-Directional Refinement Algorithm for the Calculus of (Co)Inductive
             Constructions},
  volume  = {8},
  journal = {Logical Methods in Computer Science},
  doi     = {10.2168/LMCS-8(1:18)2012}
}

@misc{demoura15,
  title         = {Elaboration in Dependent Type Theory},
  author        = {Leonardo de Moura and Jeremy Avigad and Soonho Kong and Cody Roux},
  year          = {2015},
  eprint        = {1505.04324},
  archiveprefix = {arXiv},
  primaryclass  = {cs.LO}
}

@article{venken88,
  author     = {Venken, Raf and Demoen, Bart},
  title      = {A partial evaluation system for Prolog: some practical considerations},
  year       = {1988},
  issue_date = {Sep 1988},
  publisher  = {Ohmsha},
  address    = {JPN},
  volume     = {6},
  number     = {2–3},
  issn       = {0288-3635},
  url        = {https://doi.org/10.1007/BF03037142},
  doi        = {10.1007/BF03037142},
  abstract   = {An introduction to the basic concepts of partial evaluation is followed by a short description of its use as a program transformation tool.A number of difficulties in building a partial evaluation tool, related to particular features of the language Prolog, are discussed.The impact of partial evaluation on the optimisations done by current Prolog systems is analysed and some recommendations for further improvements are made.},
  journal    = {New Gen. Comput.},
  month      = {sep},
  pages      = {279–290},
  numpages   = {12},
  keywords   = {Partial Evaluation, Compilation, Program Transformation, Abstract Machine}
}