@inproceedings{krebbers2017interactive,
  title     = {\href{https://iris-project.org/pdfs/2017-popl-proofmode-final.pdf}
                    {Interactive proofs in higher-order concurrent separation logic}},
  author    = {Krebbers, Robbert and Timany, Amin and Birkedal, Lars},
  booktitle = {Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages},
  pages     = {205--217},
  year      = {2017}
}

@article{krebbers2023beyond,
  title     = {\href{https://iris-project.org/pdfs/2023-pldi-diaframe-disj.pdf}
                    {Beyond Backtracking: Connections in Fine-Grained Concurrent Separation Logic}},
  author    = {Mulder, Ike and Czajka, {\L}ukasz and Krebbers, Robbert},
  journal   = {Proceedings of the ACM on Programming Languages},
  volume    = {7},
  number    = {PLDI},
  pages     = {1340--1364},
  year      = {2023},
  publisher = {ACM New York, NY, USA}
}

@article{krebbers2023proof,
  title     = {\href{https://iris-project.org/pdfs/2023-oopsla-diaframe2-final.pdf}
                    {Proof automation for linearizability in separation logic}},
  author    = {Mulder, Ike and Krebbers, Robbert},
  journal   = {Proceedings of the ACM on Programming Languages},
  volume    = {7},
  number    = {OOPSLA1},
  pages     = {462--491},
  year      = {2023},
  publisher = {ACM New York, NY, USA}
}

@article{o2019separation,
  title     = {\href{https://dl.acm.org/doi/pdf/10.1145/3211968}
                    {Separation logic}},
  author    = {O'Hearn, Peter},
  journal   = {Communications of the ACM},
  volume    = {62},
  number    = {2},
  pages     = {86--95},
  year      = {2019},
  publisher = {ACM New York, NY, USA}
}

@inproceedings{reynolds2002separation,
  title        = {\href{https://www.cs.cmu.edu/~jcr/seplogic.pdf}
                       {Separation logic: A logic for shared mutable data structures}},
  author       = {Reynolds, John C},
  booktitle    = {Proceedings 17th Annual IEEE Symposium on Logic in Computer Science},
  pages        = {55--74},
  year         = {2002},
  organization = {IEEE}
}

@inproceedings{wadler89,
  author    = {Wadler, P. and Blott, S.},
  title     = {How to Make Ad-Hoc Polymorphism Less Ad Hoc},
  year      = {1989},
  isbn      = {0897912942},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/75277.75283},
  doi       = {10.1145/75277.75283},
  abstract  = {This paper presents type classes, a new approach to ad-hoc polymorphism. Type classes permit overloading of arithmetic operators such as multiplication, and generalise the “eqtype variables” of Standard ML. Type classes extend the Hindley/Milner polymorphic type system, and provide a new approach to issues that arise in object-oriented programming, bounded type quantification, and abstract data types. This paper provides an informal introduction to type classes, and defines them formally by means of type inference rules.},
  booktitle = {Proceedings of the 16th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  pages     = {60–76},
  numpages  = {17},
  location  = {Austin, Texas, USA},
  series    = {POPL '89}
}

@article{selsam20,
  author     = {Daniel Selsam and
                Sebastian Ullrich and
                Leonardo de Moura},
  title      = {Tabled Typeclass Resolution},
  journal    = {CoRR},
  volume     = {abs/2001.04301},
  year       = {2020},
  url        = {https://arxiv.org/abs/2001.04301},
  eprinttype = {arXiv},
  eprint     = {2001.04301},
  timestamp  = {Thu, 29 Sep 2022 08:36:57 +0200},
  biburl     = {https://dblp.org/rec/journals/corr/abs-2001-04301.bib},
  bibsource  = {dblp computer science bibliography, https://dblp.org}
}

@article{mellish85,
  title     = {Some global optimizations for a Prolog compiler},
  author    = {Mellish, Christopher S},
  journal   = {The Journal of Logic Programming},
  volume    = {2},
  number    = {1},
  pages     = {43--66},
  year      = {1985},
  publisher = {North-Holland}
}

@inproceedings{sozeau08,
  author    = {Sozeau, Matthieu
               and Oury, Nicolas},
  editor    = {Mohamed, Otmane Ait
               and Mu{\~{n}}oz, C{\'e}sar
               and Tahar, Sofi{\`e}ne},
  title     = {First-Class Type Classes},
  booktitle = {Theorem Proving in Higher Order Logics},
  year      = {2008},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {278--293},
  abstract  = {Type Classes have met a large success in Haskell and Isabelle, as a solution for sharing notations by overloading and for specifying with abstract structures by quantification on contexts. However, both systems are limited by second-class implementations of these constructs, and these limitations are only overcomed by ad-hoc extensions to the respective systems. We propose an embedding of type classes into a dependent type theory that is first-class and supports some of the most popular extensions right away. The implementation is correspondingly cheap, general and integrates well inside the system, as we have experimented in Coq. We show how it can be used to help structured programming and proving by way of examples.},
  isbn      = {978-3-540-71067-7}
}

@inproceedings{tassi13,
  author    = {Mahboubi, Assia
               and Tassi, Enrico},
  editor    = {Blazy, Sandrine
               and Paulin-Mohring, Christine
               and Pichardie, David},
  title     = {Canonical Structures for the Working Coq User},
  booktitle = {Interactive Theorem Proving},
  year      = {2013},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {19--34},
  abstract  = {This paper provides a gentle introduction to the art of programming type inference with the mechanism of Canonical Structures. Programmable type inference has been one of the key ingredients for the successful formalization of the Odd Order Theorem using the Coq proof assistant. The paper concludes comparing the language of Canonical Structures to the one of Type Classes and Unification Hints.},
  isbn      = {978-3-642-39634-2}
}

@inproceedings{asperti09,
  author    = {Asperti, Andrea
               and Ricciotti, Wilmer
               and Sacerdoti Coen, Claudio
               and Tassi, Enrico},
  editor    = {Berghofer, Stefan
               and Nipkow, Tobias
               and Urban, Christian
               and Wenzel, Makarius},
  title     = {Hints in Unification},
  booktitle = {Theorem Proving in Higher Order Logics},
  year      = {2009},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {84--98},
  abstract  = {Several mechanisms such as Canonical Structures [14], Type Classes [13,16], or Pullbacks [10] have been recently introduced with the aim to improve the power and flexibility of the type inference algorithm for interactive theorem provers. We claim that all these mechanisms are particular instances of a simpler and more general technique, just consisting in providing suitable hints to the unification procedure underlying type inference. This allows a simple, modular and not intrusive implementation of all the above mentioned techniques, opening at the same time innovative and unexpected perspectives on its possible applications.},
  isbn      = {978-3-642-03359-9}
}

@inproceedings{hall94,
  author    = {Hall, Cordelia
               and Hammond, Kevin
               and Jones, Simon Peyton
               and Wadler, Philip},
  editor    = {Sannella, Donald},
  title     = {Type classes in Haskell},
  booktitle = {Programming Languages and Systems --- ESOP '94},
  year      = {1994},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {241--256},
  abstract  = {This paper defines a set of type inference rules for resolving over-loading introduced by type classes. Programs including type classes are transformed into ones which may be typed by the Hindley-Milner inference rules. In contrast to other work on type classes, the rules presented here relate directly to user programs. An innovative aspect of this work is the use of second-order lambda calculus to record type information in the program.},
  isbn      = {978-3-540-48376-2}
}

@inproceedings{DBLP:conf/icfp/ZilianiS15,
  author    = {Beta Ziliani and
               Matthieu Sozeau},
  editor    = {Kathleen Fisher and
               John H. Reppy},
  title     = {A unification algorithm for Coq featuring universe polymorphism and
               overloading},
  booktitle = {Proceedings of the 20th {ACM} {SIGPLAN} International Conference on
               Functional Programming, {ICFP} 2015, Vancouver, BC, Canada, September
               1-3, 2015},
  pages     = {179--191},
  publisher = {{ACM}},
  year      = {2015},
  url       = {https://doi.org/10.1145/2784731.2784751},
  doi       = {10.1145/2784731.2784751},
  timestamp = {Wed, 23 Jun 2021 16:58:51 +0200},
  biburl    = {https://dblp.org/rec/conf/icfp/ZilianiS15.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{miller1991,
  author    = {Miller, Dale},
  editor    = {Schroeder-Heister, Peter},
  title     = {A logic programming language with lambda-abstraction, function variables, and simple unification},
  booktitle = {Extensions of Logic Programming},
  year      = {1991},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {253--281},
  abstract  = {It has been argued elsewhere that a logic programming language with function variables and $\lambda$-abstractions within terms makes a very good meta-programming language, especially when an object language contains notions of bound variables and scope. The $\lambda$Prolog logic programming language and the closely related Elf and Isabelle systems provide meta-programs with both function variables and $\lambda$-abstractions by containing implementations of higher-order unification. In this paper, we present a logic programming language, called L$\lambda$, that also contains both function variables and $\lambda$-abstractions, but certain restriction are placed on occurrences of function variables. As a result, an implementation of L$\lambda$ does not need to implement full higher-order unification. Instead, an extension to first-order unification that respects bound variable names and scopes is all that is required. Such unification problems are shown to be decidable and to possess most general unifiers when unifiers exist. A unification algorithm and logic programming interpreter are described and proved correct. Several examples of using L$\lambda$ as a meta-programming language are presented.},
  isbn      = {978-3-540-46879-0}
}

@misc{demoura2015elaboration,
  title         = {Elaboration in Dependent Type Theory},
  author        = {Leonardo de Moura and Jeremy Avigad and Soonho Kong and Cody Roux},
  year          = {2015},
  eprint        = {1505.04324},
  archiveprefix = {arXiv},
  primaryclass  = {cs.LO}
}

@book{miller_nadathur_2012,
  place     = {Cambridge},
  title     = {Programming with Higher-Order Logic},
  doi       = {10.1017/CBO9781139021326},
  publisher = {Cambridge University Press},
  author    = {Miller, Dale and Nadathur, Gopalan},
  year      = {2012}
}

@inproceedings{lamProlog,
  author = {Nadathur, Gopalan and Miller, Dale},
  year   = {1988},
  month  = {06},
  pages  = {810-827},
  title  = {An Overview of Lambda-Prolog}
}

@misc{fruehwirth2017constraint,
  title         = {Constraint Handling Rules - What Else?},
  author        = {Thom Fruehwirth},
  year          = {2017},
  eprint        = {1701.02668},
  archiveprefix = {arXiv},
  primaryclass  = {cs.PL}
}

@article{Curry1934,
  author  = {Curry, Haskell B.},
  title   = {Functionality in Combinatory Logic},
  journal = {Proceedings of the National Academy of Sciences},
  volume  = {20},
  number  = {9},
  pages   = {584--590},
  year    = {1934}
}

@incollection{Howard1980,
  author    = {Howard, William A.},
  title     = {The Formulae-as-Types Notion of Construction},
  booktitle = {To H. B. Curry: Essays on Combinatory Logic, Lambda Calculus, and Formalism},
  pages     = {479--490},
  year      = {1980}
}

@article{McCune1992ExperimentsWD,
  title   = {Experiments with discrimination-tree indexing and path indexing for term retrieval},
  author  = {William McCune},
  journal = {Journal of Automated Reasoning},
  year    = {1992},
  volume  = {9},
  pages   = {147-167},
  url     = {https://api.semanticscholar.org/CorpusID:14153088}
}

@article{Sahlin1994tesi,
  author  = {Sahlin, Dan},
  year    = {1994},
  month   = {11},
  pages   = {7-51},
  title   = {Mixtus: An automatic partial evaluator for full Prolog},
  volume  = {12},
  journal = {New Generation Computing},
  doi     = {10.1007/BF03038271},
  % url     = {https://www.researchgate.net/publication/225726551_Mixtus_An_automatic_partial_evaluator_for_full_Prolog}
}

@article{10.1145/1932682.1869489,
author = {Oliveira, Bruno C.d.S. and Moors, Adriaan and Odersky, Martin},
title = {Type Classes as Objects and Implicits},
year = {2010},
issue_date = {October 2010},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {45},
number = {10},
issn = {0362-1340},
url = {https://doi.org/10.1145/1932682.1869489},
doi = {10.1145/1932682.1869489},
abstract = {Type classes were originally developed in Haskell as a disciplined alternative to ad-hoc polymorphism. Type classes have been shown to provide a type-safe solution to important challenges in software engineering and programming languages such as, for example, retroactive extension of programs. They are also recognized as a good mechanism for concept-based generic programming and, more recently, have evolved into a mechanism for type-level computation.This paper presents a lightweight approach to type classes in object-oriented (OO) languages with generics using the CONCEPT pattern and implicits (a type-directed implicit parameter passing mechanism). This paper also shows how Scala's type system conspires with implicits to enable, and even surpass, many common extensions of the Haskell type class system, making Scala ideally suited for generic programming in the large.},
journal = {SIGPLAN Not.},
month = {oct},
pages = {341–360},
numpages = {20},
keywords = {c++ concepts, scala, type classes, abstract datatypes}
}

@article{10.1145/65979.65984,
  author     = {Debray, Saumya K. and Warren, David S.},
  title      = {Functional computations in logic programs},
  year       = {1989},
  issue_date = {July 1989},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {11},
  number     = {3},
  issn       = {0164-0925},
  url        = {https://doi.org/10.1145/65979.65984},
  doi        = {10.1145/65979.65984},
  abstract   = {Although the ability to simulate nondeterminism and to compute multiple solutions for a single query is a powerful and attractive feature of logic programming languages, it is expensive in both time and space. Since programs in such languages are very often functional, that is, they do not produce more than one distinct solution for a single input, this overhead is especially undesirable. This paper describes how programs may be analyzed statically to determine which literals and predicates are functional, and how the program may then be optimized using this information. Our notion of “functionality” subsumes the notion of “determinacy” that has been considered by various researchers. Our algorithm is less reliant on language features such as the cut, and thus extends more easily to parallel execution strategies, than others that have been proposed.},
  journal    = {ACM Trans. Program. Lang. Syst.},
  month      = {jul},
  pages      = {451–481},
  numpages   = {31}
}

@article{hill1994,
  author = {Hill, Patricia and Gallagher, J},
  year   = {1994},
  month  = {09},
  pages  = {},
  title  = {Meta-Programming in Logic Programming},
  doi    = {10.1093/oso/9780198537922.003.0010}
}

@inproceedings{elf,
author = {Pfening, F.},
title = {Elf: a language for logic definition and verified metaprogramming},
year = {1989},
isbn = {0818619546},
publisher = {IEEE Press},
booktitle = {Proceedings of the Fourth Annual Symposium on Logic in Computer Science},
pages = {313–322},
numpages = {10},
location = {Pacific Grove, California, USA}
}

@InProceedings{twelf,
author="Pfenning, Frank
and Sch{\"u}rmann, Carsten",
title="System Description: Twelf --- A Meta-Logical Framework for Deductive Systems",
booktitle="Automated Deduction --- CADE-16",
year="1999",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="202--206",
abstract="Twelf is a meta-logical framework for the specification, implementation, and meta-theory of deductive systems from the theory of programming languages and logics. It relies on the LF type theory and the judgments-as-types methodology for specification [HHP93], a constraint logic programming interpreter for implementation [Pfe91], and the meta-logic M2 for reasoning about object languages encoded in LF [SP98]. It is a significant extension and complete reimplementation of the Elf system [Pfe94].",
isbn="978-3-540-48660-2"
}


@InProceedings{10.1007/978-3-540-71067-7_7,
author="Wenzel, Makarius
and Paulson, Lawrence C.
and Nipkow, Tobias",
editor="Mohamed, Otmane Ait
and Mu{\~{n}}oz, C{\'e}sar
and Tahar, Sofi{\`e}ne",
title="The Isabelle Framework",
booktitle="Theorem Proving in Higher Order Logics",
year="2008",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="33--38",
abstract="Isabelle, which is available from http://isabelle.in.tum.de, is a generic framework for interactive theorem proving. The Isabelle/Pure meta-logic allows the formalization of the syntax and inference rules of a broad range of object-logics following the general idea of natural deduction [32,33]. The logical core is implemented according to the well-known ``LCF approach'' of secure inferences as abstract datatype constructors in ML [16]; explicit proof terms are also available [8]. Isabelle/Isar provides sophisticated extra-logical infrastructure supporting structured proofs and specifications, including concepts for modular theory development. Isabelle/HOL is a large application within the generic framework, with plenty of logic-specific add-on tools and a large theory library. Other notable object-logics are Isabelle/ZF (Zermelo-Fraenkel set-theory, see [34,36] and Isabelle/HOLCF [26] (Scott's domain theory within HOL). Users can build further formal-methods tools on top, e.g. see [53].",
isbn="978-3-540-71067-7"
}

@book{books/sp/NipkowPW02,
  added-at = {2023-12-13T03:40:04.000+0100},
  author = {Nipkow, Tobias and Paulson, Lawrence C. and Wenzel, Markus},
  biburl = {https://www.bibsonomy.org/bibtex/26ca90f09d85d8d70b58e441d052da780/admin},
  ee = {https://doi.org/10.1007/3-540-45949-9},
  interhash = {8daeb422681d849d8af4fe40aeaaa7cd},
  intrahash = {6ca90f09d85d8d70b58e441d052da780},
  isbn = {3-540-43376-7},
  keywords = {},
  publisher = {Springer},
  series = {Lecture Notes in Computer Science},
  timestamp = {2023-12-13T03:40:04.000+0100},
  title = {Isabelle/HOL - A Proof Assistant for Higher-Order Logic},
  volume = 2283,
  year = 2002
}

@article{10.1007/BF00881873,
author = {Paulson, Lawrence C.},
title = {Set theory for verification. I: from foundations to functions},
year = {1993},
issue_date = {Dec. 1993},
publisher = {Springer-Verlag},
address = {Berlin, Heidelberg},
volume = {11},
number = {3},
issn = {0168-7433},
url = {https://doi.org/10.1007/BF00881873},
doi = {10.1007/BF00881873},
journal = {J. Autom. Reason.},
month = {dec},
pages = {353–389},
numpages = {37},
keywords = {set theory, isabelle, higher-order syntax, generic theorem proving, Ramsey's Theorem}
}
@InProceedings{felty88cade,
  author =       "Amy Felty and Dale Miller",
  title =        "Specifying theorem provers in a higher-order logic
                 programming language",
  editor =       "Ewing Lusk and Ross Overbeck",
  booktitle =    "{Ninth International Conference on Automated
                 Deduction}",
  address =      "Argonne, IL",
  publisher =    "Springer",
  pages =        "61--80",
  month =        may,
  year =         "1988",
  series =       lncs,
  number =       "310",
  doi =          "10.1007/BFb0012823",
}

@InProceedings{felty93lics,
  title =        "Encoding the Calculus of Constructions in a
                 Higher-Order Logic",
  author =       "Amy Felty",
  pages =        "233--244",
  booktitle =    lics93,
  publisher =    "IEEE",
  editor =       "M. Vardi",
  month =        jun,
  year =         "1993",
  doi =          "10.1109/LICS.1993.287584",
}

@InProceedings{10.1007/978-3-642-14052-5_15,
author="Chargu{\'e}raud, Arthur",
editor="Kaufmann, Matt
and Paulson, Lawrence C.",
title="The Optimal Fixed Point Combinator",
booktitle="Interactive Theorem Proving",
year="2010",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="195--210",
abstract="In this paper, we develop a general theory of fixed point combinators, in higher-order logic equipped with Hilbert's epsilon operator. This combinator allows for a direct and effective formalization of corecursive values, recursive and corecursive functions, as well as functions mixing recursion and corecursion. It supports higher-order recursion, nested recursion, and offers a proper treatment of partial functions in the sense that domains need not be hardwired in the definition of functionals. Our work, which has been entirely implemented in Coq, unifies and generalizes existing results on contraction conditions and complete ordered families of equivalences, and relies on the theory of optimal fixed points for the treatment of partial functions. It provides a practical way to formalize circular definitions in higher-order logic.",
isbn="978-3-642-14052-5"
}

@article{JUNG_KREBBERS_JOURDAN_BIZJAK_BIRKEDAL_DREYER_2018, title={Iris from the ground up: A modular foundation for higher-order concurrent separation logic}, volume={28}, DOI={10.1017/S0956796818000151}, journal={Journal of Functional Programming}, author={JUNG, RALF and KREBBERS, ROBBERT and JOURDAN, JACQUES-HENRI and BIZJAK, ALEŠ and BIRKEDAL, LARS and DREYER, DEREK}, year={2018}, pages={e20}}

@Article{miller92jsc,
  author =       "Dale Miller",
  title =        "Unification under a mixed prefix",
  year =         "1992",
  journal =      "Journal of Symbolic Computation",
  pages =        "321--358",
  volume =       "14",
  number =       "4",
  doi =          "10.1016/0747-7171(92)90011-R",
  pdf =          "http://www.lix.polytechnique.fr/Labo/Dale.Miller/papers/jsc92.pdf",
}

@InProceedings{dunchev15lpar,
  author =       "Cvetan Dunchev and Ferruccio Guidi and Claudio
                 Sacerdoti Coen and Enrico Tassi",
  title =        "{ELPI:} Fast, Embeddable, $\lambda${Prolog}
                 Interpreter",
  booktitle =    "Logic for Programming, Artificial Intelligence, and
                 Reasoning - 20th International Conference, {LPAR-20}
                 2015, Suva, Fiji, November 24-28, 2015, Proceedings",
  editor =       "Martin Davis and Ansgar Fehnker and Annabelle McIver
                 and Andrei Voronkov",
  publisher =    pub-sv,
  series =       lncs,
  volume =       "9450",
  pages =        "460--468",
  year =         "2015",
  URL =          "http://dx.doi.org/10.1007/978-3-662-48899-7\_32",
  doi =          "10.1007/978-3-662-48899-7\_32",
}
