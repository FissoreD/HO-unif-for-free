\documentclass{rapport}

\usepackage{myTools}

\usepackage{macros}

\author{Enrico Tassi, Davide Fissore}
\title{HO unification from object language to meta language} 
\date{Month XX, 202Y}

\xspaceaddexceptions{]\}}

\begin{document}

\maketitle

\def\elpi{\proglang{elpi}}
\def\coqelpi{\proglang{coq-elpi}}
\def\lambdaprolog{\proglang{$\lambda$-prolog}}
\def\coq{\proglang{coq}}
\newcommand*{\eqtau}{\ensuremath{\mathrel{\overset{\mathrm{\tau}}{=}}}}


\begin{abstract}

Unification is a fundamental process behind goal resolution in logic
programming. Two terms $t_1$ and $t_2$ unify up to $\eta\beta$-reduction if it
exist a substitution $\theta$ such that $\theta t_1 = \theta t_2$. A
substitution is a mapping from unification variables to terms and it is the most
general, if forall substitution $\theta'$, such that $\theta' t_1 = \theta'
t_2$, it exists a substitution $\theta''$ such that $\theta' = \theta \theta''$.
Unification has been widely studied in the 90s [here the refs]. In this paper we
want to give a framework to reason about unification in meta-programming.

\end{abstract}

\section{Introduction}

Meta programming \cite{hill1994} is a programming technique in which a program
can treat an other program as its data. This latter program is called object
language, while the former is called meta language. At the heart of meta
programming lays the necessity of representing terms of the object language in
the meta language so that a wide set of program manipulation ranging from
interpretation to compilation. Furthermore, since a logic program is a set of
clauses, the behavior of the object language can be modified by simply adding
new rules inside the database of the meta program.

The motivation pushing us to reason about unification of terms of the object
language represented as terms of the meta language is to implement a type class
solver for the \coq proof assistant into the \elpi logic programming language. A
type class \cite{wadler89, sozeau08} is a typing structure allowing to introduce
ad hoc polymorphism in functional languages and instances are implementations of
type classes. From the point of view of logic programming, type class represent
predicates parametrized by their argument and instances rules for those
predicates. For instance, if \texttt{XXX} is the type class representing the
AAA, then ZZZ and WWW are instances for XXX. In the code snippet below, we give
such implementation in \coq.


\begin{mintedTcolorbox}[escapeinside=&&]{coq}
  Inductive sig (A : Type) (P : A -> Prop) : Type := ...

  Class Decision (P : Prop) := decide : {P} + {not P}.
  Class RelDecision {A B: Type} (R : A -> B -> Prop).
  Class ProofIrrel (A : Type) : Prop := proof_irrel (x y : A) : x = y.

  Instance decide_rel: forall (A B : Type) (R : A -> B -> Prop),
    RelDecision R -> forall (x : A) (y : B), Decision (R x y). Admitted.
  Instance True_pi : ProofIrrel True. Admitted.
  Instance sig_eq_dec: forall (A : Type) (P : A -> Prop),
    (forall x, ProofIrrel (P x)) -> RelDecision (@eq A) ->
    RelDecision (@eq (sig A P)). Admitted.
\end{mintedTcolorbox}

This small set of instances after a first phase of\todo{explain compilation of pred and inst?}
compilation is translated into the following \elpi rules:

\begin{mintedTcolorbox}{elpi}
  type tc-Decision term -> term -> o.
  type tc-RelDecision term -> term -> term -> term -> o.
  type tc-ProofIrrel term -> term -> o.

  tc-ProofIrrel (`True`) (`True_pi`).
  tc-Decision (app [R, X, Y]) 
    (app [`decide_rel`, A, B, R, P, X, Y]) :-
    tc-RelDecision A B R P.
  tc-RelDecision (app [`sig`, A, P]) 
    (app [`sig`, A, P]) 
    (app [`eq`, app [`sig`, A, P]]) 
    (app [`sig_eq_dec`, A, P, P1, P2]) :-
    pi-decl c0 `x` A =>
      tc-ProofIrrel (app [P, c0]) (app [P1, c0]), 
    tc-RelDecision A A (app [`eq`, A]) P2.
\end{mintedTcolorbox}

Type-class resolution starts from a query, that is a class applied to some
argument. This \coq term is translated into a term of the meta language and the
search for a solution in the database is started. However, since unification is
performed on the head of the clause, it may happen that the term representation
in the meta language may hide some unification properties that are true in the
object language. In the example below, the goal \texttt{Decision (@eq T a b)}
for some \texttt{a} and \texttt{b} unifies with \texttt{Decision (R x y)} in the
object language but not in its meta representation. Similarly, the goal
\texttt{RelDecision (@eq (sig T ?P))} where \texttt{?P}, under the hypothesis
\texttt{RelDecision (@eq nat)}, will trying to apply the rule for
\texttt{sig\_eq\_dec}, we fall into an higher order unification problem, where
\texttt{P} is applied to the local name \texttt{x}. However, the corresponding
rule in the meta language exploit a first order variable \texttt{P}. Therefore,
after the refinement of the goal to \texttt{sig\_eq\_dec}, the resolution
immediately fail to solve the premise \texttt{tc-ProofIrrel (app [P, c0]) (app
[P1, c0])}.


% \section{Higher-order unification in \texorpdfstring{$L_\lambda$}{L\_lambda}}

% Higher-order unification is a unification problem known to be undecidable. The
% goal is to determine a most general unifier between two lambda terms, where at
% least one of contain a sub-term $F$ applied to a non empty list of arguments
% $a_1,\dots,a_n$ and $F$ is a variable. Some researches have been done in order to
% identify some easy patterns where it is possible to solve this kind of
% unification.

% In \cite{miller1991}, D. Miller provides a unification algorithm (the function
% $\eqtau$) for higher-order variable when they are in the so-called pattern
% fragment. 

\section{From the object to the meta language}

In \coq, terms unify up to $\eta\beta\delta\iota\zeta$-equivalence and
unification is also possible when dealing with higher order variables. Whereas
\elpi allows higher order unification up to $\eta\beta$-equivalence, and the
representation of \coq terms is more syntactical than one would expect, making 
two terms that unify in \coq not unifiable in \elpi.

Without any loss of generality, in \cref{table:coq2elpi} we present a subset of
the terms in the object language and for each term we give its representation in
the meta language. This encoding is enough to fall into unification problems.
For example, rules like 

\begin{center}
  \elpiIn{p (lam x\ (app F x)) :- ... F ...}
\end{center}

cannot unify with goals like 

\begin{center}
  \elpiIn{p (lam x\ app (app (const "f") x) x).}
\end{center}

Since \elpiIn{F} does not see \elpiIn{x} even though it is applied to \elpiIn{x}
in the object language.
  
\begin{table}
  \centering
  \begin{tabular}{c||c|c}
  Term        & Obj. lang.                    & Meta lang.                                   \\
  \hline\hline
  Constant    & a                             & `a'                                     \\
  Application & f a\_1 a\_2 ... a\_n          & app{[}`f', `a\_1', `a\_2', ..., `a\_n'{]}     \\
  Abstraction & fun (x : T) $\Rightarrow$ f x & fun `x' T (x\textbackslash app{[}`f', `x'{]}) \\
  Variable    & X                             & X                                             \\
  \end{tabular}
  \caption{Obj. lang. terms to meta lang. terms representation}
  \label{table:coq2elpi}
\end{table}

\subsection{First-order unification}

Just as an introduction, we briefly show some small example of unification
between terms with only first-order unification variables. This way, we would
like the reader to become familiar between the communication of the two
languages.

Let's take as an example the following unification problem in the obj. lang.: 

\begin{equation}
  f\ x\ 1 \eqtau f\ Y\ Z
  \label{eq:unif-fo-coq}
\end{equation}

\noindent where $f$, $x$ and $1$ are defined constant and $Y$ and $Z$ are both
unification variables. By convention we use upper case letter for quantified
variables. Moreover, for this first representation we do not really focus on the
type of the manipulated objects, since they do not condition the unification
algorithm.

It is quite evident that a valid substitution for \cref{eq:unif-fo-coq} is $\theta =
\{Y \mapsto `x', Z \mapsto `1'\}$. Now let's consider the same problem translated in
the meta language.

\begin{equation}
  app[`f', `x', `1'] \eqtau app[`f', Y, Z]
  \label{eq:unif-fo-elpi}
\end{equation}

The unification of these terms is again quite simple since it is sufficient to
do a simple matching sub-term by sub-term so that variables can be instantiated.
We can therefore note that the same substitution $\theta$ will be produced.

\subsection{Higher-order unification}

The unification problem treated before was enough easy to be correctly
understood by both language representation. We want now to go a bit further and
reason with a more complex problem where a variable is a function of
higher-order. 

We propose two different higher-order unification problem in the following
equations where, in the former we have rigid-flexible unification and in the
latter we have a flexible-flexible unification.

\begin{equation}
  f\ x\ 1 \eqtau F\ x
  \label{eq:unif-ho-coq1}
\end{equation}

\begin{equation}
  G\ x\ y \eqtau H\ y\ x
  \label{eq:unif-ho-coq2}
\end{equation}

The two substitutions for the previous examples are $\theta_1 = \{F \mapsto fun\
x \Rightarrow f\ x\ 1\}$ and $\theta_2 = \{H \mapsto fun\ y\ x \Rightarrow G\ x\
y\}$. We can note that to be in the pattern fragment, a functional variable
should be applied to distinct names.

If we translate the problem before in the meta language, the unification
problems showed above become

\begin{equation}
  app[`f',\ `x',\ `1'] \eqtau app[F,\ `x']
  \label{eq:unif-ho-elpi1}
\end{equation}

\begin{equation}
  app[G,\ `x',\ `y'] \eqtau app[H,\ `y',\ `x']
  \label{eq:unif-ho-elpi2}
\end{equation}

Now, the new unification problems are no more expressed in the logic of the
meta language and, therefore, in both cases, unification fails. The
procedure we can adopt in order to transform a higher-order unification problem
of the object language into the logic of the meta language is to transform
the entry of the problem in a problem which can be understood by the meta
language. The procedure is made of two steps:

\begin{enumerate}
  \item In the first place, we need to recognize the structure of the pattern
        fragment expressed in the term received in entry. This means that we
        need to find all the sub-terms of the form `app[X | L]', where `X' is
        a flexible variable and `L' is a list of distinct names.
  \item For any sub-term representing a higher-order unification in the object 
        language, we build a fresh variable `X\texttt{'}' such that the names 
        `L' are not in the scope of `X\texttt{'}', we call `X\texttt{'}' the 
        twin variable of `X'.
  \item We solve the new goal where each pattern fragment problem is replaced
        with a problem using twin variables and after each of these problems, we
        add a new premise linking these twin variables. The linking is done
        using the following criteria: for each abstraction in the resulting term
        `X\texttt{'}', unify recursively `X' to a lambda abstraction in the
        object language.
\end{enumerate}

The previous algorithm can be applied to \cref{eq:unif-ho-coq1,eq:unif-ho-coq2}
to provide the wanting solution. In particular, \cref{eq:unif-ho-coq1} is
transformed into the unification problem:

\begin{equation}
  f\ x\ 1 \eqtau F'\ x,\ ho-link\ F'\ F
  \label{eq:unif-ho-elpi1'}
\end{equation}

\begin{equation}
  G'\ x\ y \eqtau H'\ y\ x, ho-link\ G'\ G, ho-link\ H'\ H
  \label{eq:unif-ho-elpi2'}
\end{equation}

For instance, the former unification problem produce the substitution $\theta_1
= \{F' \mapsto (x\backslash\ f\ x\ 1)\}$. The ho-link function is then applied
to transform the substitution of $F'$ into the corresponding term of the object
langue: $F \mapsto fun \_\ \_\ (x\backslash\ f\ x\ 1)$ which correspond to the
term $fun\ x \Rightarrow f\ x\ 1$. The latter unification problem gives the
substitution $\theta_2 = \{H' \mapsto (y\ x \backslash G'\ x\ y)\}$ in the
meta language. The first ho-link simply unify $G$ to $G'$ since $G'$ is
flexible, whereas $H$ is mapped to $fun\ y\ x \Rightarrow G'\ x\ y$.

The role of the ho-link is not only to instantiate the higher-order variable F
of the object language when F is flexible and the twin variable in the meta
language is rigid. It may happen that F has already been partially instantiated.
The unification problem below gives such an example in the object language:

\begin{equation}
  G\ x\ y \eqtau H\ y\ x, H\ x\ y \eqtau x 
  \label{eq:unif-ho-coq4}
\end{equation}

\noindent producing the following substitution $\theta = \{G \mapsto (fun\ x\
y\Rightarrow x); F \mapsto (fun\ x\ y\Rightarrow y)\}$. This unification problem
is translated into:

\begin{equation}
  \begin{split}
    G'\ x\ y &\eqtau H'\ y\ x,\ ho-link\ G'\ G,\ ho-link\ H'\ H\\
    H''\ x\ y &\eqtau x,\ ho-link\ H''\ H
  \end{split}
  \label{eq:unif-ho-elpi4}
\end{equation}

\noindent The first line produces the same substitution as before: $\theta = \{H'
\mapsto (x\ y \backslash G'\ y\ x)\}$, where $G'$ is unified with $G$ and $H$ is
instantiated to <<$fun\ x\ y \Rightarrow G'\ y\ x$>>. While executing the second
line, we see $H''$ instantiated to the function $(x\ y\backslash x)$ in the
meta language. The last ho-link is charged to link $H''$ with $H$ but this
time $H$ has already been partially instantiated. In particular the call to this
ho-link is as follows: $ho-link\ (x\ y\backslash x)\
(prod\ \_\ \_\ (x\backslash\ prod\ \_\ \_\ (y\backslash\ app [G', x, y])))$.

Since the two arguments have rigid heads, we start to traverse both terms
recursively by eating each lambda-abstraction. At the end of this procedure, the
remaining sub-terms are \todo{in our code this example though the eta mess
error} now $x$ and $app[G', x, y]$, 

\section{HO unification in typed languages}

TODO: ho-link need the type of original term to produce a typed term in the
object language, example: f x 1 = F x => type of F = (A -> Prof) if type of f is 
(A -> nat -> Prop)

\section{Proof automation from \coq to \elpi}

TODO: representing a logic programming language into an other: compile rules
keeping higher order unification

\subsection{Dealing with FO \textit{non-syntactical} unification}

\subsection{Dealing with HO unification}

\printbibliography

\end{document}