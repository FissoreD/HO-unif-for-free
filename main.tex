\documentclass{rapport}

\usepackage{myTools}

\usepackage{macros}
 
\author{Enrico Tassi, Davide Fissore}
\title{HO unification from object language to meta language} 
\date{Month XX, 202Y}

\xspaceaddexceptions{]\}}

\begin{document}

\maketitle

\def\elpi{\proglang{elpi}}
\def\coqelpi{\proglang{coq-elpi}}
\def\lambdaprolog{\proglang{$\lambda$-prolog}}
\def\coq{\proglang{coq}}

\newcommand*{\acronym}[1]{\texttt{#1}\xspace}

\def\ol{\acronym{ol}}
\def\ml{\acronym{ml}}

\newcommand*{\eqtau}{\ensuremath{\mathrel{\overset{\mathrm{\tau}}{=}}}}

\begin{abstract}

Unification is a fundamental process behind goal resolution in logic
programming. Two terms $t_1$ and $t_2$ unify up to $\eta\beta$-reduction if it
exist a substitution $\theta$ such that $\theta t_1 = \theta t_2$. A
substitution is a mapping from unification variables to terms and it is the most
general, if forall substitution $\theta'$, such that $\theta' t_1 = \theta'
t_2$, it exists a substitution $\theta''$ such that $\theta' = \theta \theta''$.
Unification has been widely studied in the 90s [here the refs]. In this paper we
want to give a framework to reason about unification in meta-programming.

\end{abstract}

\section{Introduction}

Meta programming \cite{hill1994} is a programming technique in which a program
can treat an other program as its data. This latter program is called object
language (\ol for short), while the former is called meta language (\ml for
short). At the heart of meta programming lays the necessity of representing
terms of the \ol in the \ml so that a wide set of program
manipulations ranging from interpretation to compilation. Furthermore, since a
logic program is a set of clauses, the behavior of the \ol can be
modified \texttt{in corsa}\todo{translate in english} by simply adding new rules inside the database of the meta program.

Meta programming has various application such as ... where thanks to meta
programming it is possible to represent the logic of a language into a formal
and formally verify the wanted properties. On the other hand, it is possible to
embed a logic programming language into another so that some tasks can be
delegated to \ml.

The latter situation motivates our works, since we are implementing a type-class
solver for the \ol \coq in the \ml \elpi (a variant \lambdaprolog). A type class
\cite{wadler89, sozeau08} is a typing structure allowing to introduce ad hoc
polymorphism in functional languages. We call <<instance>> an implementation of
a type class. The resolution of a type-class problem can be viewed as a logic
program where type classes represent predicates parametrized by their arguments
and where instances are rules for those predicates. 


% \section{Higher-order unification in \texorpdfstring{$L_\lambda$}{L\_lambda}}

% Higher-order unification is a unification problem known to be undecidable. The
% goal is to determine a most general unifier between two lambda terms, where at
% least one of contain a sub-term $F$ applied to a non empty list of arguments
% $a_1,\dots,a_n$ and $F$ is a variable. Some researches have been done in order to
% identify some easy patterns where it is possible to solve this kind of
% unification.

% In \cite{miller1991}, D. Miller provides a unification algorithm (the function
% $\eqtau$) for higher-order variable when they are in the so-called pattern
% fragment. 

\section{From the object to the meta language}

Even though type-class resolution is the motivating example of this paper, we
provide a general framework allowing to solve reproduce the same unification
properties of the \ol into the \ml. In other word, if two terms unify in the
\ol, then they still unify in the \ml. 

In the following, we consider the \ol being able to quantify over higher-order
variables and accepts $\eta-\beta$-reductions. The same unification properties
are considered valid for the \ml.

There exist two different ways to encode the \ol in the \ml, we can either deep
embed the \ol such that any term of the \ol is represented with a corresponding
predicate. For example, if \texttt{f} is a function of type \coqIn{A -> B} in
the \ol, then the \ml has the predicate \texttt{p} defined as \elpiIn{type p A'
-> B' -> o}, where \elpiIn{A'} and \elpiIn{B'} are types corresponding
respectively to \coqIn{A} and \coqIn{B} in the \ol. In a theorem prover like
\coq, we can translate theorems like the following statement

\begin{equation}
  \texttt{\coqIn{forall F X, p (f X) (fun x => g x (F x)).}}
  \label{eq:coq1}
\end{equation}

where \texttt{p, f} and \texttt{g} are defined constants of the language, into

\begin{equation}
  \texttt{\elpiIn{p (f X) (x\ g x (F x)).}}
\end{equation}

\noindent However, even if this encoding is quite appealing since it allows to
mirror enough straightforwardly the terms of the \ol, we loose the possibility
the manipulate the terms of the \ol into the \ml. In other words, we have no
syntax allowing to know if the current term is a constant, an application, a
lambda abstraction and so on. This is mainly due to the absence of a syntax in
the encoding of the \ol terms. Moreover, another motivation for using syntax to
represent terms of the \ol is that  the typing system of the \ol could
potentially be more expressive than the typing system of the \ml\footnote{This
is the case for \coq wrt \elpi, since in we have no immediate way to encode
the dependent types of \coq into \elpi}.

To simplify the understanding of our encoding, in the following code snippet
we give the typing schema of the \ol terms represented into terms of the \ml. 

\begin{mintedTcolorbox}{elpi}
  kind tm type.
  type app list tm -> tm.
  type lam (tm -> tm) -> tm.
  type c string -> tm.
  type uv  nat -> tm.
\end{mintedTcolorbox}

In particular, the type \elpiIn{tm} is the type of the terms of the \ol. The
function applications of the \ol are represented as a list of \elpiIn{tm}
prefixed by the constructor \elpiIn{app}. The \elpiIn{lam} constructor,
represent lambda abstractions of the \ol binding a \elpiIn{tm} into an other
\elpiIn{tm}. Constants as strings inside the constructor \elpiIn{c}. Lastly,
unification variables are integers inside the constructor \elpiIn{uv}, where the
integer is the index of the current variable wrt a list of optional \elpiIn{tm},
standing for the substitution mapping of the \ol.

This second encoding of the \ol into our \ml translate \cref{eq:coq1} into
the term:

\begin{equation}
  \texttt{\elpiIn{app[c "p", app[c "f", uv 0], lam x\ app[c "g", x, app[uv 1, x]]].}}
  \label{eq:elpi1}
\end{equation}

This second encoding of the \ol terms is now structured and as a drawback we are
restricting the unification of the \ol, that is, terms that originally unify
at the \ol level, do not unify in the \ml.

For example, let \coqIn{a} and \coqIn{b} two defined constants and let's try to
unify the \ol term

\begin{equation}
  \texttt{\coqIn{p (f a) (fun x => g x b)}}
\end{equation}

\noindent corresponding to 

\begin{equation}
  \texttt{\elpiIn{app[c "p", app[c "f", c "a"], lam x\ app[c "g", x, c "b"]].}}
\end{equation}

\noindent with \cref{eq:coq1} (corresponding to \cref{eq:elpi1}). The
unification of the \ml is able to instantiate \elpiIn{uv 0} (cf \coqIn{X}) to
\elpiIn{c "a"}, but we are no longer capable to unify the sub-term
\elpiIn{app[uv 1, x]} (cf \coqIn{F}) with \elpiIn{c "b"}. 

The result of this translation of terms inside the \ml causes a certain lack of
powerfulness while symbolizing higher-order variables. Recall that we are
considering a \ml capable to deal with higher-order variables, however, the
sub-term \elpiIn{app[uv 1, x]} is not expressed into the canonical form where a
higher-order variable of the \ml is in the pattern fragment \cite{miller1991},
i.e. a variable applied to distinct names. Therefore, we need to preprocess the
received unification problem $t_1 = t_2$ by 
\begin{inlinelist}
  \item compiling the terms into a terms $t_1'$ and $t_2'$ understandable by the
  \ml
  \item finding a valid substitution for $t_1'$ and $t_2'$ 
  \item giving back a valid substitution $\theta$ for the \ol, such that $\theta$
  is the most general unifier for $T_1$ and $t_2$ in the logic of the \ol
\end{inlinelist}.

\section{Term compilation}

In order to present the the compilation of the \ol terms so that higher order
unification can be performed, we need a second and mor powerful representation
of the \ol terms so that variables have a scope. This specification is shown
in the code snippet below.  

\begin{mintedTcolorbox}{elpi}
  kind ml.tm type.
  type ml.app list ml.tm -> ml.tm.
  type ml.lam (ml.tm -> ml.tm) -> ml.tm.
  type ml.c string -> ml.tm.
  type ml.uv  nat -> list ml.tm -> ml.tm.
\end{mintedTcolorbox}

\noindent In particular a \elpiIn{ml.uv} term is meant as a unification variable
of the meta-language. Therefore, the unification between \elpiIn{ml.lam x\
ml.lam y\ ml.uv 1 [x, y]} and \elpiIn{ml.lam x\ ml.lam y\ ml.uv 0 [x]} is
supposed to be unified by the internal unification procedure of the \ml (for
this example, the substitution for \elpiIn{uv 0} is \elpiIn{ml.lam x\ ml.lam y\
ml.uv 2 [x]} whereas the substitution for \elpiIn{uv 1} is \elpiIn{ml.lam x\
ml.uv 2 [x]}).

Moreover, if \elpiIn{ml.uv} stands for meta-variables, the \elpiIn{app} and the
\elpiIn{lam} constructors are the nodes for the terms of the \ol. Therefore, we
cannot claim that \elpiIn{ml.lam x\ ml.app [ml.c "f", x]} and \elpiIn{ml.c "f"}
unify, since, even though the first is the $\eta$-expansion of the second, the
\ml does not know how to $\eta\beta$-reduce the terms of the \ol.

The compilation phase is quite straightforward, each constructor of type
\elpiIn{tm} is mapped to its corresponding version of type \elpiIn{ml.tm}. A
slight different approach is taken in the case of terms of the form \elpiIn{app
[uv N | L]}, where the term is translated into \elpiIn{tm.un M L}, that is, a
new meta-variable \elpiIn{M} with scope \elpiIn{L}.

This latter term transformation is untying the original variable \elpiIn{N} of
the \ol from the compiled term in the \ml. This means that when \elpiIn{M} is
instantiated into the \ml, we need to transfer the substitution to the \ol. In
order to bridge instantiation of meta-variables with the \ol variables, an ad
hoc \texttt{link} is crafted between the two variables.

----------------------------- END -----------------------------
\subsection{First-order unification}

Just as an introduction, we briefly show some small example of unification
between terms with only first-order unification variables. This way, we would
like the reader to become familiar between the communication of the two
languages.

Let's take as an example the following unification problem in the obj. lang.: 

\begin{equation}
  f\ x\ 1 \eqtau f\ Y\ Z
  \label{eq:unif-fo-coq}
\end{equation}

\noindent where $f$, $x$ and $1$ are defined constant and $Y$ and $Z$ are both
unification variables. By convention we use upper case letter for quantified
variables. Moreover, for this first representation we do not really focus on the
type of the manipulated objects, since they do not condition the unification
algorithm.

It is quite evident that a valid substitution for \cref{eq:unif-fo-coq} is $\theta =
\{Y \mapsto `x', Z \mapsto `1'\}$. Now let's consider the same problem translated in
the meta language.

\begin{equation}
  app[`f', `x', `1'] \eqtau app[`f', Y, Z]
  \label{eq:unif-fo-elpi}
\end{equation}

The unification of these terms is again quite simple since it is sufficient to
do a simple matching sub-term by sub-term so that variables can be instantiated.
We can therefore note that the same substitution $\theta$ will be produced.

\subsection{Higher-order unification}

The unification problem treated before was enough easy to be correctly
understood by both language representation. We want now to go a bit further and
reason with a more complex problem where a variable is a function of
higher-order. 

We propose two different higher-order unification problem in the following
equations where, in the former we have rigid-flexible unification and in the
latter we have a flexible-flexible unification.

\begin{equation}
  f\ x\ 1 \eqtau F\ x
  \label{eq:unif-ho-coq1}
\end{equation}

\begin{equation}
  G\ x\ y \eqtau H\ y\ x
  \label{eq:unif-ho-coq2}
\end{equation}

The two substitutions for the previous examples are $\theta_1 = \{F \mapsto fun\
x \Rightarrow f\ x\ 1\}$ and $\theta_2 = \{H \mapsto fun\ y\ x \Rightarrow G\ x\
y\}$. We can note that to be in the pattern fragment, a functional variable
should be applied to distinct names.

If we translate the problem before in the meta language, the unification
problems showed above become

\begin{equation}
  app[`f',\ `x',\ `1'] \eqtau app[F,\ `x']
  \label{eq:unif-ho-elpi1}
\end{equation}

\begin{equation}
  app[G,\ `x',\ `y'] \eqtau app[H,\ `y',\ `x']
  \label{eq:unif-ho-elpi2}
\end{equation}

Now, the new unification problems are no more expressed in the logic of the
meta language and, therefore, in both cases, unification fails. The
procedure we can adopt in order to transform a higher-order unification problem
of the object language into the logic of the meta language is to transform
the entry of the problem in a problem which can be understood by the meta
language. The procedure is made of two steps:

\begin{enumerate}
  \item In the first place, we need to recognize the structure of the pattern
        fragment expressed in the term received in entry. This means that we
        need to find all the sub-terms of the form `app[X | L]', where `X' is
        a flexible variable and `L' is a list of distinct names.
  \item For any sub-term representing a higher-order unification in the object 
        language, we build a fresh variable `X\texttt{'}' such that the names 
        `L' are not in the scope of `X\texttt{'}', we call `X\texttt{'}' the 
        twin variable of `X'.
  \item We solve the new goal where each pattern fragment problem is replaced
        with a problem using twin variables and after each of these problems, we
        add a new premise linking these twin variables. The linking is done
        using the following criteria: for each abstraction in the resulting term
        `X\texttt{'}', unify recursively `X' to a lambda abstraction in the
        object language.
\end{enumerate}

The previous algorithm can be applied to \cref{eq:unif-ho-coq1,eq:unif-ho-coq2}
to provide the wanting solution. In particular, \cref{eq:unif-ho-coq1} is
transformed into the unification problem:

\begin{equation}
  f\ x\ 1 \eqtau F'\ x,\ ho-link\ F'\ F
  \label{eq:unif-ho-elpi1'}
\end{equation}

\begin{equation}
  G'\ x\ y \eqtau H'\ y\ x, ho-link\ G'\ G, ho-link\ H'\ H
  \label{eq:unif-ho-elpi2'}
\end{equation}

For instance, the former unification problem produce the substitution $\theta_1
= \{F' \mapsto (x\backslash\ f\ x\ 1)\}$. The ho-link function is then applied
to transform the substitution of $F'$ into the corresponding term of the object
langue: $F \mapsto fun \_\ \_\ (x\backslash\ f\ x\ 1)$ which correspond to the
term $fun\ x \Rightarrow f\ x\ 1$. The latter unification problem gives the
substitution $\theta_2 = \{H' \mapsto (y\ x \backslash G'\ x\ y)\}$ in the
meta language. The first ho-link simply unify $G$ to $G'$ since $G'$ is
flexible, whereas $H$ is mapped to $fun\ y\ x \Rightarrow G'\ x\ y$.

The role of the ho-link is not only to instantiate the higher-order variable F
of the object language when F is flexible and the twin variable in the meta
language is rigid. It may happen that F has already been partially instantiated.
The unification problem below gives such an example in the object language:

\begin{equation}
  G\ x\ y \eqtau H\ y\ x, H\ x\ y \eqtau x 
  \label{eq:unif-ho-coq4}
\end{equation}

\noindent producing the following substitution $\theta = \{G \mapsto (fun\ x\
y\Rightarrow x); F \mapsto (fun\ x\ y\Rightarrow y)\}$. This unification problem
is translated into:

\begin{equation}
  \begin{split}
    G'\ x\ y &\eqtau H'\ y\ x,\ ho-link\ G'\ G,\ ho-link\ H'\ H\\
    H''\ x\ y &\eqtau x,\ ho-link\ H''\ H
  \end{split}
  \label{eq:unif-ho-elpi4}
\end{equation}

\noindent The first line produces the same substitution as before: $\theta = \{H'
\mapsto (x\ y \backslash G'\ y\ x)\}$, where $G'$ is unified with $G$ and $H$ is
instantiated to <<$fun\ x\ y \Rightarrow G'\ y\ x$>>. While executing the second
line, we see $H''$ instantiated to the function $(x\ y\backslash x)$ in the
meta language. The last ho-link is charged to link $H''$ with $H$ but this
time $H$ has already been partially instantiated. In particular the call to this
ho-link is as follows: $ho-link\ (x\ y\backslash x)\
(prod\ \_\ \_\ (x\backslash\ prod\ \_\ \_\ (y\backslash\ app [G', x, y])))$.

Since the two arguments have rigid heads, we start to traverse both terms
recursively by eating each lambda-abstraction. At the end of this procedure, the
remaining sub-terms are \todo{in our code this example though the eta mess
error} now $x$ and $app[G', x, y]$, 

\section{HO unification in typed languages}

TODO: ho-link need the type of original term to produce a typed term in the
object language, example: f x 1 = F x => type of F = (A -> Prof) if type of f is 
(A -> nat -> Prop)

\section{Proof automation from \coq to \elpi}

TODO: representing a logic programming language into an other: compile rules
keeping higher order unification

\subsection{Dealing with FO \textit{non-syntactical} unification}

\subsection{Dealing with HO unification}

\printbibliography

\appendix

\begin{table}
  \centering
  \begin{tabular}{c||c|c}
  Term        & \ol                    & \ml                                   \\
  \hline\hline
  Constant    & a                             & `a'                                     \\
  Application & f a\_1 a\_2 ... a\_n          & app{[}`f', `a\_1', `a\_2', ..., `a\_n'{]}     \\
  Abstraction & fun (x : T) $\Rightarrow$ f x & fun `x' T (x\textbackslash app{[}`f', `x'{]}) \\
  Variable    & X                             & X                                             \\
  \end{tabular}
  \caption{\ol terms to \ml terms representation}
  \label{table:coq2elpi}
\end{table}

\section{TC in \coq}
For instance, if
\texttt{XXX} is the type class representing the AAA, then ZZZ and WWW are
instances for XXX. In the code snippet below, we give such implementation in
\coq. 

\begin{mintedTcolorbox}[escapeinside=&&]{coq}
  Inductive sig (A : Type) (P : A -> Prop) : Type := ...

  Class Decision (P : Prop) := decide : {P} + {not P}.
  Class RelDecision {A B: Type} (R : A -> B -> Prop).
  Class ProofIrrel (A : Type) : Prop := proof_irrel (x y : A) : x = y.

  Instance decide_rel: forall (A B : Type) (R : A -> B -> Prop),
    RelDecision R -> forall (x : A) (y : B), Decision (R x y). Admitted.
  Instance True_pi : ProofIrrel True. Admitted.
  Instance sig_eq_dec: forall (A : Type) (P : A -> Prop),
    (forall x, ProofIrrel (P x)) -> RelDecision (@eq A) ->
    RelDecision (@eq (sig A P)). Admitted.
\end{mintedTcolorbox}

This small set of instances after a first phase of\todo{explain compilation of
pred and inst?} compilation is translated into the following \elpi rules:

\begin{mintedTcolorbox}{elpi}
  type tc-Decision term -> term -> o.
  type tc-RelDecision term -> term -> term -> term -> o.
  type tc-ProofIrrel term -> term -> o.

  tc-ProofIrrel (`True`) (`True_pi`).
  tc-Decision (app [R, X, Y]) 
    (app [`decide_rel`, A, B, R, P, X, Y]) :-
    tc-RelDecision A B R P.
  tc-RelDecision (app [`sig`, A, P]) 
    (app [`sig`, A, P]) 
    (app [`eq`, app [`sig`, A, P]]) 
    (app [`sig_eq_dec`, A, P, P1, P2]) :-
    pi-decl c0 `x` A =>
      tc-ProofIrrel (app [P, c0]) (app [P1, c0]), 
    tc-RelDecision A A (app [`eq`, A]) P2.
\end{mintedTcolorbox}

In this paper we do not really want to explain how the translation of the
class/instances is performed in our \ml, we prefer to focus our attention on
unification of terms of the \ol in our \ml. Although, in \cref{table:coq2elpi},
we provide a simple subset of the typing system used to represent the term of
the \ol in the \ml.

Type-class resolution starts from a query, that is a class applied to some
arguments. This \coq term is translated into a term of the \ml and the search
for a solution in the database is started. However, it may happen that the term
representation in the \ml may hide some unification properties that are true in
the \ol. In the example above, the goal \texttt{Decision (@eq T a b)} for some
\texttt{a} and \texttt{b} unifies with \texttt{Decision (R x y)} in the \ol but
not in its meta representation. Similarly, the goal \texttt{RelDecision (@eq
(sig T ?P))} where \texttt{?P}, under the hypothesis \texttt{RelDecision (@eq
nat)}, will trying to apply the rule for \texttt{sig\_eq\_dec}, we fall into an
higher order unification problem, where \texttt{P} is applied to the local name
\texttt{x}. However, the corresponding rule in the \ml exploit a first order
variable \texttt{P}. Therefore, after the refinement of the goal to
\texttt{sig\_eq\_dec}, the resolution immediately fail to solve the premise
\texttt{tc-ProofIrrel (app [P, c0]) (app [P1, c0])}.

\end{document}