\documentclass{rapport}

\usepackage{myTools}

\usepackage{macros}
 
\author{Enrico Tassi, Davide Fissore}
\title{HO unification from object language to meta language} 
\date{Month XX, 202Y}

\xspaceaddexceptions{]\}}

\begin{document}

\maketitle

\def\elpi{\proglang{elpi}}
\def\coqelpi{\proglang{coq-elpi}}
\def\lambdaprolog{\proglang{$\lambda$-prolog}}
\def\coq{\proglang{coq}}

\newcommand{\library}[1]{\textit{#1}\xspace}
\def\stdpp{\library{stdpp}}
\def\iris{\library{iris}}
% \tableofcontents

\newcommand*{\acronym}[1]{\texttt{#1}\xspace}

\def\ol{\acronym{ol}} % object language
\def\ml{\acronym{ml}} % meta language
\def\lf{\acronym{lf}} % logical framework
\def\ho{\acronym{ho}} % higher order
\def\Forall{$\forall$}

\newcommand*{\eqtau}{\ensuremath{\mathrel{\overset{\mathrm{\tau}}{=}}}}

\begin{comment}
\begin{abstract}


  % Unification is a fundamental process behind goal resolution in logic
  % programming. Two terms $t_1$ and $t_2$ unify up to $\eta\beta$-reduction if it
  % exist a substitution $\theta$ such that $\theta t_1 = \theta t_2$. A
  % substitution is a mapping from unification variables to terms and it is the most
  % general, if forall substitution $\theta'$, such that $\theta' t_1 = \theta'
  % t_2$, it exists a substitution $\theta''$ such that $\theta' = \theta \theta''$.
  % Unification has been widely studied in the 90s [here the refs]. In this paper we
  % want to give a framework to reason about unification in meta-programming.
  Meta-programming \cite{hill1994} is a programming technique in which a
  program, referred to as meta language (\ml), can treat an other program, knwon
  as the object language (\ol) as its data. This programming approach is used in
  various works \cite{cite1, cite2...} to construct logical frameworks (\lf)
  capable of automating proof resolution. In many of the
  previously mentioned works, the equational theory expressed by the \ol is
  weaker than the \ml one. Consequently, no effort is required to adjust the
  unification algorithm of the \ml to represent the unification process of 
  the \ol: the former algorithm encompassing the second one. In our
  specific scenario, however, we work with an \ol with a richer equational
  theory than our \ml. This paper introduces a framework that enables the \ml to
  comprehend the unification of the \ol in the context of higher-order 
  unification. Practical applications of these findings will be provided.

\end{abstract}
\end{comment}

\newcommand{\U}{\ensuremath{=_o}}
\newcommand{\Ue}{\ensuremath{=_\lambda}}
\newcommand{\Fo}{\ensuremath{\mathcal{F}_{\!o}}}
\newcommand{\Ho}{\ensuremath{\mathcal{H}_o}}

\begin{abstract}
Specifying and implementing a logic from scratch requires significant effort.
Logical Frameworks and Higher Order Logic Programming Languages provide
dedicated, high-level Meta Languages (ML) to facilitate this task in two
key ways: 1) variable binding and substitution are simplified when ML binders
represent object logic ones; 2) proof construction, and even proof search, is
greatly simplified by leveraging the unification procedure provided by the ML.
Notable examples of ML are Elf~\cite{elf}, Twelf~\cite{twelf},
$\lambda$Prolog~\cite{miller_nadathur_2012} and
Isabelle~\cite{10.1007/978-3-540-71067-7_7}
which have been utilized to implement various formal systems such as
First Order Logic~\cite{felty88cade},
Set Theory~\cite{10.1007/BF00881873} and
even Higher Order Logic~\cite{books/sp/NipkowPW02}.

The object logic we are interested in is Dependent Type Theory (DTT),
for which we aim to implement a unification procedure \U{} using the ML
Elpi~\cite{dunchev15lpar}, a dialect of $\lambda$Prolog.
Elpi comes equipped with the equational theory \Ue{}, comprising
$\eta\beta$ equivalence
and higher order unification restricted to the pattern
fragment~\cite{miller92jsc}.
We want \U{} to feature the same equational theory as \Ue{} but on the
object logic DTT.
Unfortunately the natural encoding of DTT in Elpi, which we refer to as \Fo{},
\marginpar{natural is not the right word}
``underuses'' \Ue{} by restricting it to first-order unification problems only. 
To address this issue, we propose a better-behaved encoding, \Ho{},
demonstrate how to map unification problems in \Fo{}
to related problems in \Ho{}, and illustrate
how to map back the unifiers found by \Ue{}, effectively implementing
 \U{} on top of \Ue{} for the natural encoding \Fo{}.
 
We apply this technique to the implementation of a type-class~\cite{wadler89}
solver for Coq~\cite{Coq-refman}.
Type-class solvers are proof search procedures based on back-chaining designated
lemmas, providing essential automation to widely used 
Coq libraries such as Stdpp/Iris~\cite{JUNG_KREBBERS_JOURDAN_BIZJAK_BIRKEDAL_DREYER_2018}
and TLC~\cite{10.1007/978-3-642-14052-5_15}. These two libraries
constitute our test bed.
\end{abstract}

\section{Introduction}

Specifying and implementing a logic from scratch requires significant effort.
Logical Frameworks and Higher Order Logic Programming Languages provide
dedicated, high-level Meta Languages (ML) to facilitate this task in two
key ways: 1) variable binding and substitution are simplified when ML binders
represent object logic ones; 2) proof construction, and even proof search, is
greatly simplified by leveraging the unification procedure provided by the ML.
Notable examples of ML are Elf~\cite{elf}, Twelf~\cite{twelf},
$\lambda$Prolog~\cite{miller_nadathur_2012} and
Isabelle~\cite{10.1007/978-3-540-71067-7_7}
which have been utilized to implement various formal systems such as
First Order Logic~\cite{felty88cade},
Set Theory~\cite{10.1007/BF00881873} and
even Higher Order Logic~\cite{books/sp/NipkowPW02}.

The object logic we are interested in is Dependent Type Theory (DTT),
and we want to code a type-class~\cite{wadler89}
solver for Coq~\cite{Coq-refman}.
Type-class solvers are proof search procedures based on back-chaining designated
lemmas, providing essential automation to widely used 
Coq libraries such as Stdpp/Iris~\cite{JUNG_KREBBERS_JOURDAN_BIZJAK_BIRKEDAL_DREYER_2018}
and TLC~\cite{10.1007/978-3-642-14052-5_15}. These two libraries
constitute our test bed.

For example, these 3 designated lemmas (Instances in the TC slang)
are supposed to be animated, backward chained, by the TC solver.
fin n is the type of numbers smaller than n, nfact the number of prime
factors and Finite/Decision properties designated as classes what are
automatically proved by Coq using the designated instances.

\begin{coqcode}
Instance fin_fin n : Finite (fin n).
Instance nfact_dec n nf : Decision (nfact n nf).
Instance forall_dec A P : Finite A ~$\to$~ ~$\forall$~x:A, Decision (P x) ~$\to$~ Decision (~$\forall$~x, P x).
\end{coqcode}

for example here

\begin{coqcode}
  Check _ : Decision (forall y: fin 7, nfact y 3).
\end{coqcode}

A natural encoding (others are discussed section xx)
uses c for constants, all for forall, and then app and lam
for the lambda calculus part.

\begin{elpicode}
finite (app[c"fin", N]).
decision (app [c"nfact",N,NF]).
decision (all A x\ app[P, x]) :- (pi x\ decision (app[P, x])), finite A.
\end{elpicode}

unfortunately this does not work since the last rule cannt
backchain on the encoded goal
  
\begin{elpicode}
decision (all (app[c"fin",c"7"]) y\ app[c"nfact", y, c"3"])
\end{elpicode}

indeed this unif problem has no solution

\begin{elpicode}
app[c"nfact", y, c"3"] = app[P, y]
\end{elpicode}

in this paper we study a more sophisticated encoding

\begin{elpicode}
decision (all A x\ Pm x) :- link Pm A P, (pi x\ decision (app[P, x])), finite A.
\end{elpicode}

This time Pm is HO for elpi, an the extra link is there to explain how to
get P out of it.

\begin{elpicode}
app[c"nfact", y, c"3"] = Pm y
Pm = y\app[c"nfact", y, c"3"]
P = lam (app[c"fin",c"7"]) a\ app[c"nfact", a, c"3"]
\end{elpicode}

We also see that this is not trivial, because in the rec call
we have now a beta redex.


\subsection{Alternative encodings} %%%%%%%%%%%%%%%%%%%%%%

our choice of encoding of DTT may look weird to the reader familiar with
LF, since used a shallow encoding of classes and binders, but not of the
``lambda calculus'' part of DTT. Here a more lightweight encoding
that unfortunately does not fit our use case

\begin{elpicode}
finite (fin N).
decision (nfact N NF).
decision (all A x\ P x) :- (pi x\ decision (P x)), finite A.
\end{elpicode}

but in DTT this is not always possible and not handy in our use case,
since the arity of constants is not fixed.

\begin{coqcode}
Fixpoint narr T n := if n is S m then T -> narr T m else T.
Definition nsum n : narr nat (n+1).
Check nsum 2   8 9 : nat.
Check nsum 3 7 8 9 : nat.
\end{coqcode}
  
moreover we use the same encoding for meta programming, or even just to provide
hand written rules. We want to access the syntax of OL, so our embedding cannot
be that shallow. We want to keep it shallow for the binders, but we need
a c, app and lam nodes.

another alternative

\begin{elpicode}
decision X :- unif X (all A x\ app[P, x]), (pi x\ decision (app[P, x])), finite A.
\end{elpicode}
    
gives up all half of what the ML gives us. moreover even if unif here embodies
he eq theory of DTT which is much stringer than the on of ML, we don't need 
it. according to our experience eta beta suffice, but HO is needed.
  


Note that this~\cite{felty93lics} is related and make the
discrepancy between the types of ML and DTT visible. In this case
one needs 4 application nodes. Moreover the objective is an encoding
of terms, proofs, not proof search. Also note the conv predicate,
akin to the unif we rule out.

This other paper~\cite{10.1007/978-3-031-38499-8_25} should also be cited.


\section{Introduction}


% meta programming
Meta programming is a powerful programming style that enable the incorporation
of an object language (\ol) into a meta language (\ml). This control over the
\ol lies at the core of meta-programming, facilitating a spectrum of operations
on the object language. Some of the principal program manipulations range
from interpretation to compilation.

% theorem prover and tc
Thanks to meta programming, it is feasible to express the equational theory of a
theorem prover, as indicated in \cite{X, Y, Z}, with the \ml serving as the
foundational infrastructure for this ecosystem. The process of proving a theorem, that is
solving a query using the jargon of logic programming, consist in verifying if a
proposition is a logical consequence of a given set of assumption. The benefit
of using a prologish verification style is that the proof resolution can be
automatized thanks to different search strategies, such as a depth first search
with backtracking. One prominent manifestation of this automated proof process is
type-class resolution\cite{wadler89, sozeau08}. Type classes serve as a typing
structure to introduce ad-hoc polymorphism in functional languages.
In \coq, the use of type classes has increasingly become a programming
style. Numerous libraries, such as \stdpp and
\iris are built upon this machinery.

% tc motivates this paper
The motivating example for this article is our investigation for an alternative
type-class solver for \coq in \elpi\todo{citation to elpi} through the \coqelpi
plugin. This plugin gives a deep embedding of \coq terms into \elpi syntax, but
challenges arise whe attempting to solve type-class goals represented into their
corresponding \elpi representation.

% syntax of coq terms in elpi
In particular, \coq terms are encoded with the following (very simplified)
data type

% \begin{elpicode}
%   kind term type.
%   type const gref -> term.
%   type app list term -> term.
%   type fun (term -> term) -> term.
%   type prod (term -> term) -> term.
% \end{elpicode}

\noindent %
\begin{tabular}{c|c}
  \begin{minipage}[c]{0.50\linewidth}
    \begin{elpicode}
      kind term type.
      type const gref -> term.
      type app list term -> term.
      type fun (term -> term) -> term.
      type prod (term -> term) -> term.
    \end{elpicode}
  \end{minipage}
  &
  \begin{minipage}[c]{0.48\linewidth}
    \begin{textcode}
      Example:
      a       ==> const `a
      f a     ==> app[const `f, const `a]
      ~$\lambda$~x => x ==> fun x\ x
      ~$\forall$x, F x~ ==> prod x\ app[F, x]
    \end{textcode}
  \end{minipage}
\end{tabular}


\noindent where a \coq constant is a gref\footnote{a gref is the opaque type for \coq
identifier in \elpi} inside the \elpiIn{const} constructor, the \coq application
is embedded in the \elpiIn{app} node, having the head and the arguments of the
application expressed as a list of terms. Lambda abstractions are translated
into the node \elpiIn{fun}, binding a term to another term. Finally forall
quantification on the form \coqIn{~$\forall$~x,F} in the \ol are translated
into \elpiIn{prod x\ F} within the \ml.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Examples
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Let's take the following example from the \stdpp library:

\noindent %
\begin{tabular}{c|c}
  \begin{minipage}[c]{0.50\linewidth}
    \begin{coqcode}
      Instance forall_dec A (P: A ~$\to$~ Prop):
        Finite A ~$\to$~ 
        ~$\forall$~x, Decision (P x) ~$\to$~
        Decision (~$\forall$~x, P x).
    \end{coqcode}
  \end{minipage}
  &
  \begin{minipage}[c]{0.46\linewidth}
    \begin{elpicode}
      tc-Decision (prod x\ app[P, x]) :- 
        % premise for Finite A
        % premise for $\forall$x, Decision (P x)
    \end{elpicode}
  \end{minipage}
\end{tabular}

\noindent In our type-class solver, the \coqIn{forall_dec} instance 
of \coq (on the left) is compiled into the \elpi rule (on the right). This 
compilation, derived
directly from the type of \coqIn{forall_dec}, conceals certain unification
properties that are accepted by the unification algorithm of the \ol but 
rejected by the unification algorithm of the \ml. The primary issue of this
compilation lies in how the subterm \coqIn{~$\forall$~x, P x} is rendered in
the \ml rule: \coqIn{P} is a higher-order variable and it
sees the binder \coqIn{x}. However, the rule in the \ml interprets \elpiIn{P} as a 
first-order variable, not seeing \elpiIn{x}. Additionally, this subterm is
nested within the \elpiIn{app} constructor, introducing a structural challenge 
to the unification process.

% Esempio HO in PF
\elpiInEq{tc-Decision (prod x\ const `nat)}%
% Esempio FO align
\elpiInEq{tc-Decision (prod x\ app[const `f, const `y, x])}

\noindent The two examples above, already expressed in the syntax of the \ml,
depict two terms that would successfully unify in the \ol, but encounter failure
in the \ml. Specifically, the first query fails because the \ml is not able to unify \elpiIn{const
`nat} with the term \elpiIn{app[P, x]} due to their distinct rigid heads. 

The second goal refers to an approximation of the unification\todo{maybe there's
something to cite} algorithm of the \ol. Spiegare l'approssimazione. E che
attraverso il nostro framework è possibile "spiegare" l'algorithm di unification
usato da ogni \ol nel ml desiderato. \todo{something to do here...}

Based on the definition provided earlier, the terms \elpiIn{app[const `f, const
`y, x]} and \elpiIn{app[P, x]} are expected to unify with substitution $\theta := \{P
\mapsto \texttt{\elpiIn{app [const `f, const `y]}} \}$. However this unification
is not possible in the \ml. This difficulty arises because, even though 
the two terms share the same same head
(the \elpiIn{app} node), their corresponding lists have different lengths.

% Implementation using ol unification on each argument
An immediate approach to address these unification problems\todo{mettere da qualche parte anche eta e beta}
would be to adopt a lazy strategy and construct highly general rules for each instance in the database.
This approach would result in a rule with the following structure:

\begin{center}
  \begin{minipage}[c]{0.46\linewidth}
    \begin{elpicode}
      tc-Decision X :- 
        ol.unify X (prod x\ app[P, x]),
        % premise for Finite A
        % premise for $\forall$x, Decision (P x)
    \end{elpicode}
  \end{minipage}
\end{center}

\noindent In this second implementation, any query to \elpiIn{tc-Decision}
will unify with the head of the rule above. The first
premise ensures that the arguments unify with what we expect from the
instance definition. Notably, in this case, the unification algorithm of
the \ol is leveraged successfully addressing the previously mentioned unification problems.

However, this approach has two main drawbacks. Firstly, the communication
between the \ol and the \ml may potentially be slow due to the transformation of
terms from one language to the other \todo{here I refer to constr->elpi and
elpi->constr}. Secondly, a lack of % the ability to
clauses discrimination based on the head of the clause is no longer
possible. For example, any indexing
algorithm designed to filter rules becomes ineffective in this scenario.

% Contribution
Finally 

% TODO: parlare non so ancora dove dell'encoding shallow
% dei terming ol in ml. Invece di usare i nodi app, prod etc... riusiamo
% la stessa sintassi del linguaggio oggetto. Questo potrebbe funzionare 
% bene nel caso di un ol con logica equazionale piu debole del ml, ma nel nostro
% caso non si può applicare. inoltre vogliamo tenere un encoding più strutturato
% per meglio analizzare i termini che ci arrivano nel ml.

% TODO: related work: chiedere a enrico

% nuova section dove si da la spec dei due linguaggi

% TODO: spiegare le proprietà di unification
  
\section{intro}

we are interested in using a meta language in LF style to write
automation, proof search. In various works... they achieve that
for a OL which is simpler than the LF, the equational theory is included
in the one of the ML. This is exploited to piggy back on the unif
of the ML.
the peculiarity of our setting is that the OL has a richer equational
theory of the ML, eg beta eta zeta bla bla. Moreover is HO logic, so
quantifies over functions, so unif variable range on that too.
We want to piggy back on the ML unif whenever the problem fits
in its domain, eg pattern fragment.
this is important for practical purposes.

\subsection{in a nutshell}
example, a rule for theorem
$$
forall f : A -> B, .. bla f .. -> prove (\forall x, f x)
bla g
$$
\begin{elpicode}
type app ...
prove (forall x\ app F x) :- ... bla F ...
\end{elpicode}
on goal \mint{elpi}|prove (forall x\ app (app g x) x))|
would fail since \mint{elpi}|F != app g x|.

of course one wants to avoid
\begin{elpicode}
prove P S S'' :- ol-unif P S (forall x\ app "F" x) S', ... assignment "F" S' F, bla F S' ...
\end{elpicode}

Now, ML has HO variables
\begin{elpicode}
type lam ..
prove (forall x\ F x) :- ... bla F ...
\end{elpicode}
this time  \mint{elpi}|F x != app (app g x) x| has solution
\mint{elpi}|F = a\ app (app g x) x| but F is not a term so
bla needs to be adapted,
\begin{elpicode}
prove (forall x\ F x) :- ... bla (lam F) ...
bla g.
\end{elpicode}
this is too simplistic since \mint{elpi}|g != lam x\ app g x|

\subsection{contribution}
\begin{itemize}
\item prover for HO OL in ML that uses unif
\item eta beta
\item test on stdpp and TLC
\end{itemize}


\section{Introduction}

Meta programming \cite{hill1994} is a programming technique in which a program
can treat an other program as its data. This latter program is called object
language (\ol for short), while the former is called meta language (\ml for
short). At the heart of meta programming lays the necessity of representing
terms of the \ol in the \ml so that a wide set of program
manipulations ranging from interpretation to compilation. 
% Furthermore, since a
% logic program is a set of clauses, the behavior of the \ol can be
% modified \texttt{in corsa}\todo{translate in english} by simply adding new rules inside the database of the meta program.

Meta programming has various application such as ... where thanks to meta
programming it is possible to represent the logic of a language into a formal
and formally verify the wanted properties. On the other hand, it is possible to
embed a logic programming language into another so that some tasks can be
delegated to \ml.

The latter situation motivates our works, since we are implementing a type-class
solver for the \ol \coq in the \ml \elpi (a variant \lambdaprolog). A type class
\cite{wadler89, sozeau08} is a typing structure allowing to introduce ad hoc
polymorphism in functional languages. We call <<instance>> an implementation of
a type class. The resolution of a type-class problem can be viewed as a logic
program where type classes represent predicates parametrized by their arguments
and where instances are rules for those predicates. 


% \section{Higher-order unification in \texorpdfstring{$L_\lambda$}{L\_lambda}}

% Higher-order unification is a unification problem known to be undecidable. The
% goal is to determine a most general unifier between two lambda terms, where at
% least one of contain a sub-term $F$ applied to a non empty list of arguments
% $a_1,\dots,a_n$ and $F$ is a variable. Some researches have been done in order to
% identify some easy patterns where it is possible to solve this kind of
% unification.

% In \cite{miller1991}, D. Miller provides a unification algorithm (the function
% $\eqtau$) for higher-order variable when they are in the so-called pattern
% fragment. 

esempietto in cui l'HO di elpi non risolve un problem HO del linguaggio
oggetto FO. Equazione XX


\begin{coqcode}
(* HO unif *)
Instance forall_dec A (P: A ~$\to$~ Prop) `{Finite A} `{~$\forall$~x, Decision (P x)} :
  Decision (~$\forall$~x, P x).
Instance and_dec P `{Decision P} Q `{Decision Q}:  Decision (P /\ Q).



(* FO approx *)
Instance decide_rel A B (R: A ~$\to$~ B ~$\to$~ Prop) `{RelDecision R} :
  forall x y, Decision (R x y).
Instance decide_eq_nat : RelDecision (@eq nat).
Check _ : Decision (@eq nat 2 3)


Instance _ : Inj add.
             Inj F -> Inj (fun x => F (G x))

             (fun x => add x)


  Decision (~$\forall$~x, P x).

\end{coqcode}

\subsection{Related work and alternative approaches}

LF e PL with binders (sempre HOAS).

citare FO logic et similia fatti in LP, twelf. qui l'unification dell'OL
e' facile. cercare se in twelf hanno fatto un po' di ordine superiore.

isabelle fa la stessa cosa, OL e HOL, che matcha il sistema di tipi.
qui l'unificazione e' la stessa, e fanno un ecoding shallow (senza app).

Noi abbiamo un OL piu complicato, i tipi non matchano, serve un nodo app
per due ragioni: meta programmazione e arieta variabile

(equazioni XX senza app e lam) XXX IDEA XXX

\section{main idea: FO encoding - HO encoding}


\begin{tabular}{c|c}
\begin{minipage}{.5\textwidth}
\begin{minted}{elpi}
kind fo_tm type.
type fo_app list fo_tm -> fo_tm.
type fo_lam (tm -> fo_tm) -> fo_tm.
type fo_uv  nat -> fo_tm.
type fo_c string -> fo_tm.





typeabbrev subst list (option tm).
type equal subst -> tm -> tm -> o.
\end{minted}
\end{minipage}
&
\begin{minipage}{.5\textwidth}
\begin{minted}{elpi}
kind tm type.
type app list tm -> tm.
type lam (tm -> tm) -> tm.
type uv  nat -> list tm -> tm.
type c string -> tm.

kind assmt type.
type abs (tm -> assmt) -> assmt.
type val tm -> assmt.

typeabbrev subst list (option assmt).
type equal subst -> tm -> tm -> o.
\end{minted}
\end{minipage}
\end{tabular}

le due sintassi, XX tradotto, unif passa, bisogna riportare la soluzione
nel mondo fo

this should hold in both encoding
%abella
\begin{minted}{elpi}
forall t1 t2 s, unif t1 t2 nil s -> equal s t1 t2
\end{minted}
we have unif only in the HO one, where equal is
weaker (but unif is stronger)

segnatura di decomp e unif, equalfo (fa beta, eta, deref)

\noindent
\begin{tabular}{c}
\begin{minipage}{.95\textwidth}
\begin{minted}{elpi}
% deref
equal S (uv N) T1 :- assigned? N S T, equal S T T1.
equal S T1 (uv N) :- assigned? N S T, equal S T1 T.
equal S (app [uv N|A]) T1 :- assigned? N S F, beta F A T, equal S T T1.
equal S T1 (app [uv N|A]) :- assigned? N S F, beta F A T, equal S T1 T.
% congruence
equal S (app L1) (app L2) :- forall2 (equal S) L1 L2.
equal S (lam F1) (lam F2) :- pi x\ equal S x x => equal S (F1 x) (F2 x).
equal _ (c X) (c X).
equal _ (uv N) (uv N).
% beta
equal S (app [lam X | TL]) T :- beta (lam X) TL T', equal S T' T.
equal S T (app [lam X | TL]) :- beta (lam X) TL T', equal S T T'.
% eta
equal S (lam F) T :- not (T = lam _),
  pi x\ beta T [x] (T' x), equal S (lam F) (lam T').
equal S T (lam F) :- not (T = lam _),
  pi x\ beta T [x] (T' x), equal S (lam T') (lam F).
\end{minted}
\end{minipage}
\\\hline
\begin{minipage}{.95\textwidth}
\begin{minted}{elpi}
% deref
equal S (uv N A) T1 :- assigned? N S F, beta-abs F A T, equal S T T1.
equal S T1 (uv N A) :- assigned? N S F, beta-abs F A T, equal S T1 T.
% congruence
equal S (app L1) (app L2) :- forall2 (equal S) L1 L2.
equal S (lam F1) (lam F2) :- pi x\ equal S x x => equal S (F1 x) (F2 x).
equal _ (c X) (c X).
equal _ (uv N A1) (uv N A2) :- forall2 (equal S) A1 A2. %fixme in the code
\end{minted}
\end{minipage}

\end{tabular}

equal fo is congruence, deref, beta, eta (for the OL).
equal ho is congruence, deref (for the OL).
unif (fo or ho) should cover pattern fragment, i.e. well behaved unif.

ho, and unif ho, is the LF/ML language/unif. here we describe fo and ho
with a deeply embedded syntax, but the idea is that uv can be mapped to
an actual unif variable.

of course we could write a unif for the ho that had beta and eta,
but if we use the one of the LF it can't have eta beta of the OL baked in.

\subsection{implementation}

l'HO encoding e' esattamente lambda Prolog/elpi, il compilatore
in pratica potrebbe essere scritto in un meta language, qui lo si presenta in
elpi stesso. HO e FO in questo paper sono deep embedded in elpi per parlarne,
ma in pratica il nostro solever, prendere XX, scrivere la clausola compilata.

\begin{elpicode}
prove (app[c "decidable", all x\ P x]) Proof :- ho-link P P', prove (... P' ...).
\end{elpicode}

qui P nel paper diventa uv N [x] per un certo N.

\section{recovering HO}

\begin{elpicode}
  p (all x\ app[F,x]) = p (all x\ app[f,x,x])
\end{elpicode}

fallisce perche le liste non hanno la stessa lunghezza.


compile

\begin{elpicode}
  p (all x\ F' x) = p (all x\ app[f,x,x]) , link F F'.
  F' = x\ app[f,x,x]
  F = lam a\ app[f,a,a].
\end{elpicode}

\begin{elpicode}
  type comp fo.tm -> ho.tm -> list link -> list link -> ho.subst -> ho.subst -> o.
  comp (fo.c X)   (ho.c X) L L S S.
  comp (fo.app [fo.uv N|Argsss]) TT L L3 S S3 :- %!,
    % TODO: here split-pf to enter dist. names into N
    % split-pf Argsss [] PF NPF,
    split-pf Argsss [] PF [], NPF = [], % TODO: compile to (uv N L) + link-fo-app
    print "In PF" PF NPF, 
    if (NPF = []) (TT = ho.uv M PF1) (TT = ho.app [ho.uv M PF1 | NPF1]),
    % pattern-fragment Args,
    fold4 comp PF PF1 L L1 S S1,
    fold4 comp NPF NPF1 L1 L2 S1 S2,
    ho.new S2 M S3,
    % TODO: maybe len can be given by split-pf
    len PF Len,
    L3 = [link N M Len| L2].
  % TODO: if don't want to modify unif, we compile `fo.app [fo.c f, c0, c0, ho.c a]` into 
  % `ho.app [ho.app[f, c0, c0], ho.c a]
  comp (fo.app A) (ho.app A1) L L1 S S1 :- fold4 comp A A1 L L1 S S1.
  comp (fo.lam F) (ho.lam F1) L L1 S S1 :- 
    (pi x y\ (pi A S\ comp x y A A S S) => comp (F x) (F1 y) L L1 S S1).
  comp (fo.uv N) (ho.uv M []) L [link N M z|L] S S1 :- ho.new S M S1.

  decmop...
\end{elpicode}


\section{recovering eta}

\begin{elpicode}
q (all x\ F x) = q (all x\ app[f,x]) /\ p f = p F
F = fun a => app [f,a] ----> F = f
\end{elpicode}

l'utene da p su f, mentre l'istanza pe q forza F a fun .. 

\section{recovering beta}

\begin{elpicode}
  q (all x\ F x) = q (all x\ app[f,x,x]) /\ p1 (app[f,a,a]) = p1 (app[F,a])
  F = fun y => app [f,y,y] ----> (app[F,a]) ~> app[f, a, a].
\end{elpicode}
  
qui la sintesi di F puo generare un beta redex, quindi ci mettiamo
p1 F1, e decomp beta F [a] F1.

\section{recovering eta-beta within unification (non linear variables)}

se i problemi di cui sopra avvengono nello stesso termine

\begin{elpicode}
  q2 (all x\ F x) (app[F,a]) = q2 (all x\ app[f,x,x]) (app[f,a,a])
\end{elpicode}

bisogna slegare le due F e poi unificare le soluzioni tra di loro

\section{heuristic / binary app}

fo approx / sub pattern fragment

\begin{elpicode}
  p (all x\app[F,x,a]) (app[F,b]) = p (all x\app[f,x,x,a]) (app[f,b,b])
  p (all x\G x) F' = 
  G = x\ f x x a
  F = lam x\f x x
  F' = (app[f,b,b])
  link (F a) F'
  link G F
\end{elpicode}


% questo esempio recupera l'app binaria perche

\begin{elpicode}
  (app (app F x) a) = (app (f x x) a)
\end{elpicode}




\section{XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX}

Even though type-class resolution is the motivating example of this paper, we
provide a general framework allowing to solve reproduce the same unification
properties of the \ol into the \ml. In other word, if two terms unify in the
\ol, then they still unify in the \ml. 

In the following, we consider the \ol being able to quantify over higher-order
variables and accepts $\eta-\beta$-reductions. The same unification properties
are considered valid for the \ml.

There exist two different ways to encode the \ol in the \ml, we can either deep
embed the \ol such that any term of the \ol is represented with a corresponding
predicate. For example, if \texttt{f} is a function of type \coqIn{A -> B} in
the \ol, then the \ml has the predicate \texttt{p} defined as \elpiIn{type p A'
-> B' -> o}, where \elpiIn{A'} and \elpiIn{B'} are types corresponding
respectively to \coqIn{A} and \coqIn{B} in the \ol. In a theorem prover like
\coq, we can translate theorems like the following statement

\begin{equation}
  \texttt{\coqIn{forall F X, p (f X) (fun x => g x (F x)).}}
  \label{eq:coq1}
\end{equation}

where \texttt{p, f} and \texttt{g} are defined constants of the language, into

\begin{equation}
  \texttt{\elpiIn{p (f X) (x\ g x (F x)).}}
\end{equation}

\noindent However, even if this encoding is quite appealing since it allows to
mirror enough straightforwardly the terms of the \ol, we loose the possibility
the manipulate the terms of the \ol into the \ml. In other words, we have no
syntax allowing to know if the current term is a constant, an application, a
lambda abstraction and so on. This is mainly due to the absence of a syntax in
the encoding of the \ol terms. Moreover, another motivation for using syntax to
represent terms of the \ol is that  the typing system of the \ol could
potentially be more expressive than the typing system of the \ml\footnote{This
is the case for \coq wrt \elpi, since in we have no immediate way to encode
the dependent types of \coq into \elpi}.

To simplify the understanding of our encoding, in the following code snippet
we give the typing schema of the \ol terms represented into terms of the \ml. 

\begin{mintedTcolorbox}{elpi}
  kind tm type.
  type app list tm -> tm.
  type lam (tm -> tm) -> tm.
  type c string -> tm.
  type uv  nat -> tm.
\end{mintedTcolorbox}

In particular, the type \elpiIn{tm} is the type of the terms of the \ol. The
function applications of the \ol are represented as a list of \elpiIn{tm}
prefixed by the constructor \elpiIn{app}. The \elpiIn{lam} constructor,
represent lambda abstractions of the \ol binding a \elpiIn{tm} into an other
\elpiIn{tm}. Constants as strings inside the constructor \elpiIn{c}. Lastly,
unification variables are integers inside the constructor \elpiIn{uv}, where the
integer is the index of the current variable wrt a list of optional \elpiIn{tm},
standing for the substitution mapping of the \ol.

This second encoding of the \ol into our \ml translate \cref{eq:coq1} into
the term:

\elpiInEq[eq:elpi1]{app[c "p", app[c "f", uv 0], lam x\ app[c "g", x, app[uv 1, x]]].}

This second encoding of the \ol terms is now structured and as a drawback we are
restricting the unification of the \ol, that is, terms that originally unify
at the \ol level, do not unify in the \ml.

For example, let \coqIn{a} and \coqIn{b} two defined constants and let's try to
unify the \ol term

\begin{equation}
  \texttt{\coqIn{p (f a) (fun x => g x b)}}
\end{equation}

\noindent corresponding to 

\begin{equation}
  \texttt{\elpiIn{app[c "p", app[c "f", c "a"], lam x\ app[c "g", x, c "b"]].}}
  \label{eq:elpi2}
\end{equation}

\noindent with \cref{eq:coq1} (corresponding to \cref{eq:elpi1}). The
unification of the \ml is able to instantiate \elpiIn{uv 0} (cf \coqIn{X}) to
\elpiIn{c "a"}, but we are no longer capable to unify the sub-term
\elpiIn{app[uv 1, x]} (cf \coqIn{F}) with \elpiIn{c "b"}. 

The result of this translation of terms inside the \ml causes a certain lack of
powerfulness while symbolizing higher-order variables. Recall that we are
considering a \ml capable to deal with higher-order variables, however, the
sub-term \elpiIn{app[uv 1, x]} is not expressed into the canonical form where a
higher-order variable of the \ml is in the pattern fragment \cite{miller1991},
i.e. a variable applied to distinct names. Therefore, we need to preprocess the
received unification problem $t_1 = t_2$ by 
\begin{inlinelist}
  \item compiling the terms into a terms $t_1'$ and $t_2'$ understandable by the
  \ml
  \item finding a valid substitution for $t_1'$ and $t_2'$ 
  \item giving back a valid substitution $\theta$ for the \ol, such that $\theta$
  is the most general unifier for $T_1$ and $t_2$ in the logic of the \ol
\end{inlinelist}.

\section{Term compilation}

In order to present the the compilation of the \ol terms, so that higher order
unification can be performed, we need a second and more powerful representation
of the \ol terms so that variables have a scope. This specification is shown
in the code snippet below.  

\begin{mintedTcolorbox}{elpi}
  kind ml.tm type.
  type ml.app list ml.tm -> ml.tm.
  type ml.lam (ml.tm -> ml.tm) -> ml.tm.
  type ml.c string -> ml.tm.
  type ml.uv nat -> list ml.tm -> ml.tm.
\end{mintedTcolorbox}

\noindent In particular a \elpiIn{ml.uv} term is meant as a unification variable
of the meta-language. Therefore, the unification between 

\elpiInEqq{ml.lam x\ ml.lam y\ ml.uv 1 [x, y]}

and

\elpiInEqq{ml.lam x\ ml.lam y\ ml.uv 0 [x]}

is supposed to procedure of the substitution \elpiIn{ml.lam x\ ml.lam y\ ml.uv 2
[x]} for \elpiIn{uv 0} and the substitution \elpiIn{ml.lam x\ ml.uv 2 [x]}) for
\elpiIn{uv 1}.

Moreover, if \elpiIn{ml.uv} stands for meta-variables, the \elpiIn{app} and the
\elpiIn{lam} constructors are the nodes for the terms of the \ol. Therefore, we
cannot claim that \elpiIn{ml.lam x\ ml.app [ml.c "f", x]} and \elpiIn{ml.c "f"}
unify, since, even though the first is the $\eta$-expansion of the second, the
\ml does not know how to $\eta\beta$-reduce terms of the \ol.

In our encoding, we explicitly encode the meta-variables with the \elpiIn{ml.uv}
constructor. This is because we prefer to have the full control of the \ml,
including the meta-variables instantiation. This way we are able to concretely
touch the substitution performed by the \ml. In a further section, we show that
there is no difference between our custom \ml language and any other \ml. Of
course, a full control on the unification behind meta-variable assmt ask to
drag the substitution mapping of the \ml and update it each time a variable is
refined.

The compilation phase is quite straightforward, each constructor of type
\elpiIn{tm} is mapped to its corresponding version of type \elpiIn{ml.tm}. A
slight different approach is taken in the case of terms of the form \elpiIn{app
[uv N | L]}, where the term is translated into \elpiIn{tm.un M L}, that is, a
new meta-variable \elpiIn{M} with scope \elpiIn{L}.

This latter term transformation is untying the original variable \elpiIn{N} of
the \ol from the compiled term in the \ml. This means that when \elpiIn{M} is
instantiated into the \ml, we need to transfer the substitution to the \ol. In
order to bridge instantiation of meta-variables with the \ol variables, an ad
hoc \texttt{link} is crafted between the two variables.

A link, \elpiIn{type link nat -> nat -> link}, takes two integers: the first 
stands for the index of variables in the \ol and the second is the index of 
the meta-variables.

For example, if we take back the example in \cref{eq:elpi2}, and want to compile
it, we obtain the new term:

\elpiInEq{app[c "p", app[c "f", c "a"], lam x\ app[c "g", x, c "b"]].}



----------------------------- END -----------------------------
\subsection{First-order unification}

Just as an introduction, we briefly show some small example of unification
between terms with only first-order unification variables. This way, we would
like the reader to become familiar between the communication of the two
languages.

Let's take as an example the following unification problem in the obj. lang.: 

\begin{equation}
  f\ x\ 1 \eqtau f\ Y\ Z
  \label{eq:unif-fo-coq}
\end{equation}

\noindent where $f$, $x$ and $1$ are defined constant and $Y$ and $Z$ are both
unification variables. By convention we use upper case letter for quantified
variables. Moreover, for this first representation we do not really focus on the
type of the manipulated objects, since they do not condition the unification
algorithm.

It is quite evident that a valid substitution for \cref{eq:unif-fo-coq} is $\theta =
\{Y \mapsto `x', Z \mapsto `1'\}$. Now let's consider the same problem translated in
the meta language.

\begin{equation}
  app[`f', `x', `1'] \eqtau app[`f', Y, Z]
  \label{eq:unif-fo-elpi}
\end{equation}

The unification of these terms is again quite simple since it is sufficient to
do a simple matching sub-term by sub-term so that variables can be instantiated.
We can therefore note that the same substitution $\theta$ will be produced.

\subsection{Higher-order unification}

The unification problem treated before was enough easy to be correctly
understood by both language representation. We want now to go a bit further and
reason with a more complex problem where a variable is a function of
higher-order. 

We propose two different higher-order unification problem in the following
equations where, in the former we have rigid-flexible unification and in the
latter we have a flexible-flexible unification.

\begin{equation}
  f\ x\ 1 \eqtau F\ x
  \label{eq:unif-ho-coq1}
\end{equation}

\begin{equation}
  G\ x\ y \eqtau H\ y\ x
  \label{eq:unif-ho-coq2}
\end{equation}

The two substitutions for the previous examples are $\theta_1 = \{F \mapsto fun\
x \Rightarrow f\ x\ 1\}$ and $\theta_2 = \{H \mapsto fun\ y\ x \Rightarrow G\ x\
y\}$. We can note that to be in the pattern fragment, a functional variable
should be applied to distinct names.

If we translate the problem before in the meta language, the unification
problems showed above become

\begin{equation}
  app[`f',\ `x',\ `1'] \eqtau app[F,\ `x']
  \label{eq:unif-ho-elpi1}
\end{equation}

\begin{equation}
  app[G,\ `x',\ `y'] \eqtau app[H,\ `y',\ `x']
  \label{eq:unif-ho-elpi2}
\end{equation}

Now, the new unification problems are no more expressed in the logic of the
meta language and, therefore, in both cases, unification fails. The
procedure we can adopt in order to transform a higher-order unification problem
of the object language into the logic of the meta language is to transform
the entry of the problem in a problem which can be understood by the meta
language. The procedure is made of two steps:

\begin{enumerate}
  \item In the first place, we need to recognize the structure of the pattern
        fragment expressed in the term received in entry. This means that we
        need to find all the sub-terms of the form `app[X | L]', where `X' is
        a flexible variable and `L' is a list of distinct names.
  \item For any sub-term representing a higher-order unification in the object 
        language, we build a fresh variable `X\texttt{'}' such that the names 
        `L' are not in the scope of `X\texttt{'}', we call `X\texttt{'}' the 
        twin variable of `X'.
  \item We solve the new goal where each pattern fragment problem is replaced
        with a problem using twin variables and after each of these problems, we
        add a new premise linking these twin variables. The linking is done
        using the following criteria: for each abstraction in the resulting term
        `X\texttt{'}', unify recursively `X' to a lambda abstraction in the
        object language.
\end{enumerate}

The previous algorithm can be applied to \cref{eq:unif-ho-coq1,eq:unif-ho-coq2}
to provide the wanting solution. In particular, \cref{eq:unif-ho-coq1} is
transformed into the unification problem:

\begin{equation}
  f\ x\ 1 \eqtau F'\ x,\ ho-link\ F'\ F
  \label{eq:unif-ho-elpi1'}
\end{equation}

\begin{equation}
  G'\ x\ y \eqtau H'\ y\ x, ho-link\ G'\ G, ho-link\ H'\ H
  \label{eq:unif-ho-elpi2'}
\end{equation}

For instance, the former unification problem produce the substitution $\theta_1
= \{F' \mapsto (x\backslash\ f\ x\ 1)\}$. The ho-link function is then applied
to transform the substitution of $F'$ into the corresponding term of the object
langue: $F \mapsto fun \_\ \_\ (x\backslash\ f\ x\ 1)$ which correspond to the
term $fun\ x \Rightarrow f\ x\ 1$. The latter unification problem gives the
substitution $\theta_2 = \{H' \mapsto (y\ x \backslash G'\ x\ y)\}$ in the
meta language. The first ho-link simply unify $G$ to $G'$ since $G'$ is
flexible, whereas $H$ is mapped to $fun\ y\ x \Rightarrow G'\ x\ y$.

The role of the ho-link is not only to instantiate the higher-order variable F
of the object language when F is flexible and the twin variable in the meta
language is rigid. It may happen that F has already been partially instantiated.
The unification problem below gives such an example in the object language:

\begin{equation}
  G\ x\ y \eqtau H\ y\ x, H\ x\ y \eqtau x 
  \label{eq:unif-ho-coq4}
\end{equation}

\noindent producing the following substitution $\theta = \{G \mapsto (fun\ x\
y\Rightarrow x); F \mapsto (fun\ x\ y\Rightarrow y)\}$. This unification problem
is translated into:

\begin{equation}
  \begin{split}
    G'\ x\ y &\eqtau H'\ y\ x,\ ho-link\ G'\ G,\ ho-link\ H'\ H\\
    H''\ x\ y &\eqtau x,\ ho-link\ H''\ H
  \end{split}
  \label{eq:unif-ho-elpi4}
\end{equation}

\noindent The first line produces the same substitution as before: $\theta = \{H'
\mapsto (x\ y \backslash G'\ y\ x)\}$, where $G'$ is unified with $G$ and $H$ is
instantiated to <<$fun\ x\ y \Rightarrow G'\ y\ x$>>. While executing the second
line, we see $H''$ instantiated to the function $(x\ y\backslash x)$ in the
meta language. The last ho-link is charged to link $H''$ with $H$ but this
time $H$ has already been partially instantiated. In particular the call to this
ho-link is as follows: $ho-link\ (x\ y\backslash x)\
(prod\ \_\ \_\ (x\backslash\ prod\ \_\ \_\ (y\backslash\ app [G', x, y])))$.

Since the two arguments have rigid heads, we start to traverse both terms
recursively by eating each lambda-abstraction. At the end of this procedure, the
remaining sub-terms are \todo{in our code this example though the eta mess
error} now $x$ and $app[G', x, y]$, 

\section{HO unification in typed languages}

TODO: ho-link need the type of original term to produce a typed term in the
object language, example: f x 1 = F x => type of F = (A -> Prof) if type of f is 
(A -> nat -> Prop)

\section{Proof automation from \coq to \elpi}

TODO: representing a logic programming language into an other: compile rules
keeping higher order unification

\subsection{Dealing with FO \textit{non-syntactical} unification}

\subsection{Dealing with HO unification}

\printbibliography

\appendix

\begin{table}
  \centering
  \begin{tabular}{c||c|c}
  Term        & \ol                    & \ml                                   \\
  \hline\hline
  Constant    & a                             & `a'                                     \\
  Application & f a\_1 a\_2 ... a\_n          & app{[}`f', `a\_1', `a\_2', ..., `a\_n'{]}     \\
  Abstraction & fun (x : T) $\Rightarrow$ f x & fun `x' T (x\textbackslash app{[}`f', `x'{]}) \\
  Variable    & X                             & X                                             \\
  \end{tabular}
  \caption{\ol terms to \ml terms representation}
  \label{table:coq2elpi}
\end{table}

\section{TC in \coq}
For instance, if
\texttt{XXX} is the type class representing the AAA, then ZZZ and WWW are
instances for XXX. In the code snippet below, we give such implementation in
\coq. 

\begin{mintedTcolorbox}[escapeinside=&&]{coq}
  Inductive sig (A : Type) (P : A -> Prop) : Type := ...

  Class Decision (P : Prop) := decide : {P} + {not P}.
  Class RelDecision {A B: Type} (R : A -> B -> Prop).
  Class ProofIrrel (A : Type) : Prop := proof_irrel (x y : A) : x = y.

  Instance decide_rel: forall (A B : Type) (R : A -> B -> Prop),
    RelDecision R -> forall (x : A) (y : B), Decision (R x y). Admitted.
  Instance True_pi : ProofIrrel True. Admitted.
  Instance sig_eq_dec: forall (A : Type) (P : A -> Prop),
    (forall x, ProofIrrel (P x)) -> RelDecision (@eq A) ->
    RelDecision (@eq (sig A P)). Admitted.
\end{mintedTcolorbox}

This small set of instances after a first phase of\todo{explain compilation of
pred and inst?} compilation is translated into the following \elpi rules:

\begin{mintedTcolorbox}{elpi}
  type tc-Decision term -> term -> o.
  type tc-RelDecision term -> term -> term -> term -> o.
  type tc-ProofIrrel term -> term -> o.

  tc-ProofIrrel (`True`) (`True_pi`).
  tc-Decision (app [R, X, Y]) 
    (app [`decide_rel`, A, B, R, P, X, Y]) :-
    tc-RelDecision A B R P.
  tc-RelDecision (app [`sig`, A, P]) 
    (app [`sig`, A, P]) 
    (app [`eq`, app [`sig`, A, P]]) 
    (app [`sig_eq_dec`, A, P, P1, P2]) :-
    pi-decl c0 `x` A =>
      tc-ProofIrrel (app [P, c0]) (app [P1, c0]), 
    tc-RelDecision A A (app [`eq`, A]) P2.
\end{mintedTcolorbox}

In this paper we do not really want to explain how the translation of the
class/instances is performed in our \ml, we prefer to focus our attention on
unification of terms of the \ol in our \ml. Although, in \cref{table:coq2elpi},
we provide a simple subset of the typing system used to represent the term of
the \ol in the \ml.

Type-class resolution starts from a query, that is a class applied to some
arguments. This \coq term is translated into a term of the \ml and the search
for a solution in the database is started. However, it may happen that the term
representation in the \ml may hide some unification properties that are true in
the \ol. In the example above, the goal \texttt{Decision (@eq T a b)} for some
\texttt{a} and \texttt{b} unifies with \texttt{Decision (R x y)} in the \ol but
not in its meta representation. Similarly, the goal \texttt{RelDecision (@eq
(sig T ?P))} where \texttt{?P}, under the hypothesis \texttt{RelDecision (@eq
nat)}, will trying to apply the rule for \texttt{sig\_eq\_dec}, we fall into an
higher order unification problem, where \texttt{P} is applied to the local name
\texttt{x}. However, the corresponding rule in the \ml exploit a first order
variable \texttt{P}. Therefore, after the refinement of the goal to
\texttt{sig\_eq\_dec}, the resolution immediately fail to solve the premise
\texttt{tc-ProofIrrel (app [P, c0]) (app [P1, c0])}.

\end{document}