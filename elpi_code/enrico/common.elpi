kind nat type.
type z nat.
type s nat -> nat.

kind bool type.
type tt bool.
type ff bool.

type assigned? nat -> list A -> A -> o.
assigned? z (X :: _) Y  :- not (var X), X = Y.
assigned? (s N) (_ :: L) X :- assigned? N L X.

type assign nat -> list A -> A -> o.
assign z (X :: _) Y  :- std.assert! (var X) "assign", X = Y.
assign (s N) (_ :: L) X :- assign N L X.

type nth nat -> list A -> A -> o.
nth z (X :: _) Y  :- X = Y.
nth (s N) (_ :: L) X :- nth N L X.

type exists (A -> o) -> list A -> o.
exists F [X|XS] :- F X ; exists F XS.

type forall2 (A -> A -> o) -> list A -> list A -> o.
forall2 _ [] [].
forall2 F [X|XS] [Y|YS] :- F X Y, forall2 F XS YS.

type fold2 (A -> A -> B -> B -> o) -> list A -> list A -> B -> B -> o.
fold2 _ [] [] A A.
fold2 F [X|XS] [Y|YS] A A1 :- F X Y A A0, fold2 F XS YS A0 A1.

type all list o -> o.
all [].
all [P|PS] :- P, all PS.

type copyl list A -> list A -> o.
copyl L [] :- var L, !.
copyl [X|L] [X|L1] :- copyl L L1.

type forall (X -> o) -> list X -> o.
forall _ [].
forall P [X|XS] :- P X, forall P XS.

type len list A -> nat -> o.
len [] z.
len [_|L] (s X) :- len L X.

pred pattern-fragment i:list A.
pattern-fragment L :- distinct_names L.

kind test type -> type.
type test A -> A -> bool -> test A.
type declare-test (test A -> o) -> test A -> o.

type runtests list o -> bool -> o.
runtests [] B :- var B, print "ALL GOOD!".
runtests [] _ :- print "SOME TEST FAIL!", fail.
runtests [declare-test F (test L R B as T)|TS] ERR :- print "\n------------\n\n\n",
  if (B = tt) (Rel = "===") (Rel = "=/="),
  if (F T) (print "ok" L Rel R, runtests TS ERR)
           (print "\n<<<<<\nko" L Rel R "\n>>>>>\n", ERR = tt, runtests TS ERR).
