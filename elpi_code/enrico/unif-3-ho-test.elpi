macro @X L :- ho3.uv z L.
macro @Y L :- ho3.uv (s z) L.
macro @Z L :- ho3.uv (s (s z)) L.
macro @f :- ho3.c "f".
macro @g :- ho3.c "g".
macro @h :- ho3.c "h".
macro @a :- ho3.c "a".
macro @b :- ho3.c "b".
macro @c :- ho3.c "c".
shorten ho3.{ app , lam }.

type ho3.test-shallow test-shallow ho3.tm -> o.
ho3.test-shallow (test-shallow L R tt) :- ho3.unif L R S, std.assert! (ho3.equal L R S) "bug". %, print "Sigma=" S.
ho3.test-shallow (test-shallow L R ff) :- not(ho3.unif L R _).

type ho3c1.test-shallow test-shallow ho3.tm -> o.
ho3c1.test-shallow (test-shallow L R tt) :- std.do! [
  comp1.comp L L1 SO SE,
  comp1.comp R R1 SO SE,
  L1 = R1,
  std.assert! (ho3.validSO SO) "invalid SO",
  std.assert! (ho3.equal L R SO) "bug",
].
ho3c1.test-shallow (test-shallow L R ff) :-
  comp1.comp L L1 SO SE,
  comp1.comp R R1 SO SE,
  not(L1 = R1).

type ho3c2.test-shallow test-shallow ho3.tm -> o.
ho3c2.test-shallow (test-shallow L R tt) :- std.do! [
  comp2.comp L L1 SO [] Links',
  comp2.comp R R1 SO Links' Links,
  L1 = R1,
  all Links,
  comp2.decompSO SO,
  std.assert! (ho3.validSO SO) "invalid SO",
  std.assert! (ho3.equal L R SO) "bug",
].
ho3c2.test-shallow (test-shallow L R ff) :- std.spy-do![
  comp2.comp L L1 SO [] Links',
  comp2.comp R R1 SO Links' Links,
  not(std.spy(print "A", L1 = R1, print "B", std.spy(all Links), print "BB"))].

macro @ok X Y :- declare-test-shallow ho3.test-shallow (test-shallow X Y tt).
macro @ko X Y :- declare-test-shallow ho3.test-shallow (test-shallow X Y ff).

macro @okc1 X Y :- declare-test-shallow ho3c1.test-shallow (test-shallow X Y tt).
macro @koc1 X Y :- declare-test-shallow ho3c1.test-shallow (test-shallow X Y ff).

macro @okc2 X Y :- declare-test-shallow ho3c2.test-shallow (test-shallow X Y tt).
macro @koc2 X Y :- declare-test-shallow ho3c2.test-shallow (test-shallow X Y ff).

@ok (app [@f, @X []]) (app [@f, @a]).
@ok (app [@X [], @a]) (app [@f, @a]).
@ko (app [@f, @X []]) (@X []).
@ko (app [@f, @X [], @X []]) (app [@f, @a, @b]).
@ok (app [@f, @X [], @Y [], @X []]) (app [@f, (app [@f, @Y []]), @b, (app [@f, @b])]).
@ok (lam x\ (app [@f, @X []])) (lam x\ (app [@f, @a])).

@ok   (lam x\ lam y\ @X [x, y]) (lam x\ lam y\ app [@f, y]).
@okc1 (lam x\ lam y\ @X [x, y]) (lam x\ lam y\ app [@f, y]).
% we want this, the solution for X could be eta-contracted.
% if we are smart in the HO link, we might recover it
@ko (app [(lam x\ lam y\ @X [x, y]),
          (lam x\ @X [x]) % X = lam a\lam b\app [f, b]
                          % beta (lam a\lam b\app [f, b]) [x] (lam b\app [f, b])
                          % boom: (lam b\app [f, b]) != f
         ])
    (app [(lam x\ lam y\ app [@f, y]),
          lam x\ @f]).

%@koc1 assert failure since we asign twice SO
%  assign z [ho3.lam c1 \ ho3.lam c2 \ X14 c1 c2 | X19]
%           (ho3.lam c1 \ c2 \ X14 c1 c2)
@okc2 (app [(lam x\ lam y\ app[@X [x] , y]),
            (lam x\ @X [x])
         ])
    (app [(lam x\ lam y\ app [@f, y]),
          lam x\ @f]).
@okc2 (app [(lam x\ lam y\ @X [x, y]),
            (lam x\ @X [x])
         ])
    (app [(lam x\ lam y\ app [@f, y]),
          lam x\ @f]).

@okc2 (lam x\ lam y\ @X [x, y]) (lam x\ lam y\ @X [y, x]).
@okc2 (lam x\ lam y\ app[@X [], x, y]) (lam x\ lam y\ app[@X [], y, x]).

@okc2 (lam a\ lam x\ lam y\ app [@X [a], x, y]) (lam a\ lam x\ lam y\ app [@X [a], y, x]).

% here we have a beta in FO
@okc2 (app [@X [], app [@X [], @a]]) (app [lam (x\ app[@f, x, x]), app[@f, @a, @a]]).
@okc2 (app [lam (x\ app[@f, x, x]), app[@f, @a, @a]]) (app [@X [], app [@X [], @a]]).
@okc2 (app [@X [], app [@X [], @a]]) (app [lam (x\ app[@f, x]), app[@f, @a]]).
@okc2 (app [lam (x\ app[@f, x]), app[@f, @a]]) (app [@X [], app [@X [], @a]]).
@okc2 (app [@X [], @X []]) (app [lam (x\ app[@f, x]), @f]).

@okc2 (app [@X [], @X []]) (app[@Y [], @f]).
@okc2 (app [@X [], @a]) (app[@f, @a]). % Here we make aprrox first order
@koc2 (app [@X [], @a]) (app[@f, @b]). % Note this not pass since we are not in PF
@koc2 (app [@X [], @a]) @f.            % Same here

% Here no compilation is done, only test-shallow for equal function
% @okc2 (app [lam (x\ app[@f, x]), @a]) (app [@f, @a]).
% @okc2 (lam (x\ app[@f, x])) @f.

% It is a weird test-shallow (not possible in elpi?) but it works, since by definition
% app[@X [], x, y] === @X [y, x]
@okc2 (lam x\ lam y\ app[@X [], x, y]) (lam x\ lam y\ @X [y, x]).

@koc2 (lam x\ lam y\ app[@X [], x]) (lam x\ lam y\ @X [y, x]).

