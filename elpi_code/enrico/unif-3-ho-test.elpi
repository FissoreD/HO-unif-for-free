macro @X L :- ho3.uv z L.
macro @Y L :- ho3.uv (s z) L.
macro @Z L :- ho3.uv (s (s z)) L.
macro @f :- ho3.c "f".
macro @g :- ho3.c "g".
macro @h :- ho3.c "h".
macro @a :- ho3.c "a".
macro @b :- ho3.c "b".
macro @c :- ho3.c "c".
shorten ho3.{ app , lam }.

type ho3.test test ho3.tm -> o.
ho3.test (test L R tt) :- ho3.unif L R S, std.assert! (ho3.equal L R S) "bug". %, print "Sigma=" S.
ho3.test (test L R ff) :- not(ho3.unif L R _).

type ho3c1.test test ho3.tm -> o.
ho3c1.test (test L R tt) :- std.do! [
  comp1.comp L L1 SO SE,
  comp1.comp R R1 SO SE,
  L1 = R1,
  std.assert! (ho3.validSO SO) "invalid SO",
  std.assert! (ho3.equal L R SO) "bug",
].
ho3c1.test (test L R ff) :-
  comp1.comp L L1 SO SE,
  comp1.comp R R1 SO SE,
  not(L1 = R1).

type ho3c2.test test ho3.tm -> o.
ho3c2.test (test L R tt) :- std.spy-do! [
  comp2.comp L L1 SO [] Links',
  comp2.comp R R1 SO Links' Links,
  L1 = R1,
  all Links,
  comp2.decompSO SO,
  std.assert! (ho3.validSO SO) "invalid SO",
  std.assert! (ho3.equal L R SO) "bug",
].
ho3c2.test (test L R ff) :-
  comp2.comp L L1 SO [] Links',
  comp2.comp R R1 SO Links' Links,
  not(L1 = R1, all Links).

macro @ok X Y :- declare-test ho3.test (test X Y tt).
macro @ko X Y :- declare-test ho3.test (test X Y ff).

macro @okc1 X Y :- declare-test ho3c1.test (test X Y tt).
macro @koc1 X Y :- declare-test ho3c1.test (test X Y ff).

macro @okc2 X Y :- declare-test ho3c2.test (test X Y tt).
macro @koc2 X Y :- declare-test ho3c2.test (test X Y ff).

@ok (app [@f, @X []]) (app [@f, @a]).
@ok (app [@X [], @a]) (app [@f, @a]).
@ko (app [@f, @X []]) (@X []).
@ko (app [@f, @X [], @X []]) (app [@f, @a, @b]).
@ok (app [@f, @X [], @Y [], @X []]) (app [@f, (app [@f, @Y []]), @b, (app [@f, @b])]).
@ok (lam x\ (app [@f, @X []])) (lam x\ (app [@f, @a])).

@ok   (lam x\ lam y\ @X [x, y]) (lam x\ lam y\ app [@f, y]).
@okc1 (lam x\ lam y\ @X [x, y]) (lam x\ lam y\ app [@f, y]).
% we want this, the solution for X could be eta-contracted.
% if we are smart in the HO link, we might recover it
@ko (app [(lam x\ lam y\ @X [x, y]),
          (lam x\ @X [x]) % X = lam a\lam b\app [f, b]
                          % beta (lam a\lam b\app [f, b]) [x] (lam b\app [f, b])
                          % boom: (lam b\app [f, b]) != f
         ])
    (app [(lam x\ lam y\ app [@f, y]),
          lam x\ @f]).

%@koc1 assert failure since we asign twice SO
%  assign z [ho3.lam c1 \ ho3.lam c2 \ X14 c1 c2 | X19]
%           (ho3.lam c1 \ c2 \ X14 c1 c2)
@okc2 (app [(lam x\ lam y\ app[@X [x] , y]),
            (lam x\ @X [x])
         ])
    (app [(lam x\ lam y\ app [@f, y]),
          lam x\ @f]).
@okc2 (app [(lam x\ lam y\ @X [x, y]),
            (lam x\ @X [x])
         ])
    (app [(lam x\ lam y\ app [@f, y]),
          lam x\ @f]).

@okc2 (lam x\ lam y\ @X [x, y]) (lam x\ lam y\ @X [y, x]).
@okc2 (lam x\ lam y\ app[@X [], x, y]) (lam x\ lam y\ app[@X [], y, x]).

@okc2 (lam a\ lam x\ lam y\ app [@X [a], x, y]) (lam a\ lam x\ lam y\ app [@X [a], y, x]).

% TODO: Note this does not typecheck, but we do not detect it...
% @okc2 (lam x\ lam y\ app[@X [], x, y]) (lam x\ lam y\ @X [y, x]).

% here we have a beta in FO
@okc2 (app [@X [], app [@X [], @a]]) (app [lam (x\ app[@f, x, x]), app[@f, @a, @a]]).
@okc2 (app [@X [], app [@X [], @a]]) (app [lam (x\ app[@f, x]), app[@f, @a]]).
@okc2 (app [@X [], @X []]) (app [lam (x\ app[@f, x]), @f]).

% Here no compilation is done, only test for equal function
okc2 (app [lam (x\ app[@f, x]), @a]) (app [@f, @a]).
okc2 (lam (x\ app[@f, x])) @f.


% TODO:
% (app[X,a]) --> X = lam --> beta problem, we could compile this to
% Z + link-beta (app X a) Z anche se X a non Ã¨ pattern...
