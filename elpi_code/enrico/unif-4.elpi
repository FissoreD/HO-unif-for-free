
namespace try4 {

%%%%%%%%%%%%%%%%%%% the OL %%%%%%%%%%%%%%%%%%%%%
namespace fo {

kind tm type.
type app list tm -> tm.
type lam (tm -> tm) -> tm.
type uv  nat -> tm.
type c string -> tm.

typeabbrev subst list (option tm).

% [equal Subst T1 T2] check if two terms are equal for the OL
% note: T1 and T2 are never flexible elpi variables
type equal subst -> tm -> tm -> o.
equal _ X Y :- (var X ; var Y), halt "flex".
equal S (uv N) T1 :- assigned? N S T, equal S T T1.
equal S T1 (uv N) :- assigned? N S T, equal S T1 T.
equal S (app [uv N|Args]) T1 :- assigned? N S F, beta F Args T, equal S T T1.
equal S T1 (app [uv N|Args]) :- assigned? N S F, beta F Args T, equal S T1 T.
equal S (app L1) (app L2) :- forall2 (equal S) L1 L2.
equal S (lam F1) (lam F2) :- pi x\ equal S x x => equal S (F1 x) (F2 x).
equal _ (c X) (c X).
equal _ (uv N) (uv N).

% eta
equal S (lam F) T :- not (T = lam _), 
  pi x\ beta T [x] (T' x), equal S (lam F) (lam T').
equal S T (lam F) :- not (T = lam _), 
  pi x\ beta T [x] (T' x), equal S (lam T') (lam F).

% beta
equal S (app [lam X | TL]) T :- beta (lam X) TL T', equal S T' T.
equal S T (app [lam X | TL]) :- beta (lam X) TL T', equal S T T'.

% [alloc-subst S T] foraech var in T, alloc an uv N at place N in S
type alloc-subst subst -> tm -> o.
alloc-subst S (uv N) :- nth N S none.
alloc-subst S (lam F) :- pi x\ alloc-subst S x => alloc-subst S (F x).
alloc-subst _ (c _).
alloc-subst S (app L) :- forall (alloc-subst S) L.

type beta tm -> list tm -> tm -> o.
beta A [] A.
beta (lam Bo) [H | L] R :- beta (Bo H) L R.
beta (app A) L (app X) :- std.append A L X.
beta (uv N) L (app [uv N | L]).
beta (c H) L (app [c H | L]).

% [new S N S'] return S' which is S with none at pos N
type new subst -> nat -> subst -> o.
new [] z [none].
new [X|XS] (s N) [X|YS] :- new XS N YS.

type mk-app tm -> list tm -> tm -> o.
mk-app T L S :- beta T L S.
}

%%%%%%%%%%%%%%%%%%% the ML %%%%%%%%%%%%%%%%%%%%%

namespace ho {

typeabbrev subst list (option assignment).

kind assignment type.
type abs (tm -> assignment) -> assignment.
type val tm -> assignment.

kind tm type.
type app list tm -> tm.
type lam (tm -> tm) -> tm.
type uv  nat -> list tm -> tm.
type c string -> tm.

% [unif T1 T2 SOld SNew] check if T1 and T2 unify looking into SOld. SNew is the final substution
type unif tm -> tm -> subst -> subst ->  o.
unif (uv N Args) T S S1 :- assigned? N S F, beta-abs F Args T1, unif T1 T S S1.
unif T (uv N Args) S S1 :- assigned? N S F, beta-abs F Args T1, unif T T1 S S1.
unif (uv N A) (uv N A) S S :- pattern-fragment A.

unif (uv N Args1) (uv M Args2) S S3 :- pattern-fragment Args1, pattern-fragment Args2, 
  std.spy(new S W S1, prunexx W Args1 Args2 Ass, assign N S1 Ass S2, assign M S2 Ass S3).

unif (uv N Args) T S S1 :- not (T = uv _ _), print "In here", std.spy-do![not (occ N S T), pattern-fragment Args, bind Args T T1, assign N S T1 S1].
unif T (uv N Args) S S1 :- not (T = uv _ _), not (std.spy(occ N S T)), pattern-fragment Args, bind Args T T1, assign N S T1 S1.

% unif (app [uv N L | Args]) T S S1 :- unif (uv N {std.append L Args}) T S S1.
% unif T (app [uv N L | Args]) S S1 :- unif T (uv N {std.append L Args}) S S1.
unif (app L1) (app L2) S S1 :- fold2 unif L1 L2 S S1.
unif (lam F1) (lam F2) S S1 :- pi x\ (pi S\ unif x x S S) => unif (F1 x) (F2 x) S S1.
unif (c X) (c X) S S.

% Vorremmo saperli unificare, ma non ci sono nella nostra specifica (CoqTerms non unificano eta-beta in Elpi)
% % eta
% unif T (lam F) S S1 :- not (T = lam _), 
%   pi x\ beta T [x] (F' x), unif (lam F') (lam F) S S1.
% unif T (lam F) S S1 :- not (T = lam _), 
%   pi x\ beta T [x] (F' x), unif (lam F') (lam F) S S1.

% % beta
% unif (app [lam F | TL]) T S S1 :- beta (lam F) TL T', unif T' T S S1.
% unif T (app [lam F | TL]) S S1 :- beta (lam F) TL T', unif T T' S S1.

type prunexx nat -> list tm -> list tm -> assignment -> o.
prunexx N A1 A2 T :-
  prune-aux N A1 A2 [] T _.


type prunex nat -> list tm -> list tm -> subst -> subst -> o.
prunex N A1 A2 S S2 :-
  new S M S1,
  prune-aux M A1 A2 [] F ff,
  assign N S1 F S2.
prunex _ _ _ S S.

type prune-aux nat -> list tm -> list tm -> list tm -> assignment -> bool -> o.
prune-aux N [] [] ACC (val (uv N Args)) tt :- std.rev ACC Args.
prune-aux N [X|XS] [X|YS] ACC (abs F) O :- pi x\ prune-aux N XS YS [x|ACC] (F x) O.
prune-aux N [_|XS] [_|YS] ACC (abs F) _ :- pi x\ prune-aux N XS YS ACC (F x) tt.

type beta-abs assignment -> list tm -> tm -> o.
beta-abs (abs Bo) [H | L] R :- beta-abs (Bo H) L R.
beta-abs (val A)  [] A.
beta-abs (val (app A))  L (app X) :- std.append A L X.
beta-abs (val (uv N A)) L (uv N X) :- std.append A L X.
beta-abs (val (c H))    L (app [c H | L]).

type beta tm -> list tm -> tm -> o.
beta A [] A.
beta (lam Bo) [H | L] R :- beta (Bo H) L R.
beta (app A) L (app X) :- std.append A L X.
beta (uv N A) L (uv N A') :- std.append A L A'.
beta (c H) L (app [c H | L]).

type occ.aux nat -> subst -> tm -> o.
occ.aux N _S (uv N _).
occ.aux N S (uv M Args) :- assigned? M S F, beta-abs F Args T, occ.aux N S T.
occ.aux N S (app L) :- exists (occ.aux N S) L.
occ.aux N S (lam F) :- pi x\ occ.aux N S (F x).

type occ  nat -> subst -> tm -> o.
occ N _S (uv N _) :- !, fail.
occ N S (uv M Args) :- assigned? M S F, !, beta-abs F Args T, occ N S T.
occ N S T :- occ.aux N S T.

type copy tm -> tm -> o.
copy (app L) (app L') :- forall2 copy L L'.
copy (lam T) (lam T') :- pi x\ copy x x => copy (T x) (T' x).
copy (uv N L) (uv N L') :- forall2 copy L L'.
copy (c C) (c C).

type bind list tm -> tm -> assignment -> o.
bind [] T (val T') :- copy T T'.
bind [X | TL] T (abs T') :- pi x\ copy X x => bind TL T (T' x).

type new subst -> nat -> subst -> o.
new [] z [none].
new [X|XS] (s N) [X|YS] :- new XS N YS.

type unif-assignment assignment -> assignment -> subst -> subst -> o.
unif-assignment (val T1) (val T2) H H1 :- unif T1 T2 H H1.
unif-assignment (abs F1) (abs F2) H H1 :- pi x\ (pi S\ unif x x S S) => unif-assignment (F1 x) (F2 x) H H1.

}

namespace comp {

kind link type.
type link nat -> nat -> nat -> link.

type comp fo.tm -> ho.tm -> list link -> list link -> ho.subst -> ho.subst -> o.
comp (fo.c X)   (ho.c X) L L S S.
comp (fo.app [fo.uv N|Args]) (ho.uv M Args1) L L2 S S2 :-
  pattern-fragment Args,
  fold4 comp Args Args1 L L1 S S1,
  ho.new S1 M S2,
  len Args Len,
  L2 = [link N M Len| L1].
comp (fo.app A) (ho.app A1) L L1 S S1 :- fold4 comp A A1 L L1 S S1.
comp (fo.lam F) (ho.lam F1) L L1 S S1 :- 
  (pi x y\ (pi A S\ comp x y A A S S) => comp (F x) (F1 y) L L1 S S1).
comp (fo.uv N) (ho.uv M []) L [link N M z|L] S S1 :- ho.new S M S1.

type solve-link list link -> list link -> ho.subst -> ho.subst -> o.
solve-link [link N M Len|L] LR HO HO1 :- take-link L (link N M' _) L1, !, std.spy-do! [
  same-assign M M' Len W HO HO2,
  solve-link [link N W Len|L1] LR HO2 HO1,
].
solve-link [L|LS] [L|LS'] HO HO1 :- solve-link LS LS' HO HO1.
solve-link [] [] X X.

type same-assign nat -> nat -> nat -> nat -> ho.subst -> ho.subst -> o.
same-assign M M' Len W HO HO2 :- std.spy-do![
  if (assigned? M HO T, W = M) true (eta Len M [] T),
  if (assigned? M' HO T', W = M') true (eta Len M' [] T'),
  ho.unif-assignment T T' HO HO2].

% [eta Arity VarName Acc Ass]
type eta nat -> nat -> list ho.tm -> ho.assignment -> o.
eta z     N Acc (ho.val (ho.uv N Acc')) :- std.rev Acc Acc'.
eta (s M) N Acc (ho.abs F) :- pi x\ eta M N [x | Acc] (F x).

type take-link list link -> link -> list link -> o.
take-link [L|XS] L XS.
take-link [L|XS] L' [L|YS] :- not(L = L'), take-link XS L' YS.

type decompl list link -> list link -> ho.subst -> fo.subst -> fo.subst -> o.
decompl [link N M _|L] LK HO FO FO1 :-
  assigned? M HO T,
  decomp-assign LK HO T T' FO FO',
  assign N FO' T' FO2,
  decompl L LK HO FO2 FO1.
decompl [] _ _ X X.

% we use links just to know if the variables are new
type decomp-assign list link -> ho.subst -> ho.assignment -> fo.tm -> fo.subst -> fo.subst -> o.
% decomp-assign LK HO (ho.abs F) F1 S S1 :-
%   pi x y\ (pi S\ decomp LK HO x y S S) => decomp-assign LK HO (F x) F1 S S1.

decomp-assign LK HO (ho.abs F) (fo.lam F1) S S1 :-
  pi x y\ (pi S\ decomp LK HO x y S S) => decomp-assign LK HO (F x) (F1 y) S S1.

decomp-assign LK HO (ho.val T) T1 S S1 :- decomp LK HO T T1 S S1.

type decomp list link -> ho.subst -> ho.tm -> fo.tm -> fo.subst -> fo.subst -> o.
decomp _ _ (ho.c X)   (fo.c X) S S.
decomp LK HO (ho.app L) SolOL S S1 :- 
  fold2 (decomp LK HO) L [HD|TL] S S1,
  fo.mk-app HD TL SolOL.
decomp LK HO (ho.lam F) (fo.lam F1) S S1 :-
  pi x y\ (pi S\ decomp LK HO x y S S) => decomp LK HO (F x) (F1 y) S S1.
decomp LK HO (ho.uv N Args) SolOL S S1 :-
  fold2 (decomp LK HO) Args Args1 S S2,
  if (take-link LK (link X N _) _) (S1 = S2)
     (fo.new S2 X S1',
      if (assigned? N HO T)
         (decomp-assign LK HO T T' S1' S1'', assign X S1'' T' S1)
         (S1 = S1')),
  fo.mk-app (fo.uv X) Args1 SolOL.

/*
type eta-contract tm -> tm -> o.
eta-contract X X :- var X, !.
eta-contract (c X) (c X).
eta-contract (app L) (app L1) :- forall2 eta-contract L L1.
eta-contract (lam F) T :- contract [] (lam F) T.
eta-contract (lam F) (lam F1) :- pi x\ (pi X Y\ eta-contract X Y :- name X, X = Y) => eta-contract (F x) (F1 x).
eta-contract (uv X Args) (uv X Args).

type contract list tm -> tm -> tm -> o.
% contract A B _ :- print A B, fail.
contract L X T :- var X, !, fail.
contract L (lam F) T :- 
  pi x\ contract [x|L] (F x) T. % also checks H Prefix does not see x
contract L (app [H|Args]) T :- 
  %print "Base case",
  std.rev L LRev, std.appendR Prefix LRev Args,
  if (Prefix = []) (T = H) (T = app [H|Prefix]).
*/
    
}}

macro @X :- try4.fo.uv z.
macro @Y :- try4.fo.uv (s z).
macro @Z :- try4.fo.uv (s (s z)).
macro @f :- try4.fo.c "f".
macro @g :- try4.fo.c "g".
macro @h :- try4.fo.c "h".
macro @a :- try4.fo.c "a".
macro @b :- try4.fo.c "b".
macro @c :- try4.fo.c "c".
macro @app L :- try4.fo.app L.
macro @lam L :- try4.fo.lam L.

type unfold-pair-comp 
  pair try4.fo.tm try4.fo.tm -> 
  pair try4.ho.tm try4.ho.tm -> 
  list try4.comp.link ->
  list try4.comp.link ->
  try4.ho.subst -> try4.ho.subst -> o.
unfold-pair-comp (pr L R) (pr LH RH) LLL Link S HO :-
  std.assert! (try4.comp.comp L LH LLL Link0 S HO0) "b1",
  std.assert! (try4.comp.comp R RH Link0 Link HO0 HO) "b2".
  
type unif-fold-pair 
  list (pair try4.ho.tm try4.ho.tm) ->
  try4.ho.subst -> try4.ho.subst -> o.
unif-fold-pair [] S S.
unif-fold-pair [pr T1 T2 | TL] S1 S3 :-
  try4.ho.unif T1 T2 S1 S2,
  unif-fold-pair TL S2 S3.

type forall-pair (try4.fo.tm -> o) -> 
  list (pair try4.fo.tm try4.fo.tm) -> o.
forall-pair _ [].
forall-pair F [pr A B | TL] :- F A, F B, forall-pair F TL.
  

type xtest test try4.fo.tm -> o.
xtest (test LR tt) :- std.spy-do! [
  map-fold2 unfold-pair-comp LR [] [] LRH Link HO,
  unif-fold-pair LRH HO SOL,
  try4.comp.solve-link Link LinkU SOL SOL1,
  forall-pair (try4.fo.alloc-subst FOSol) LR,
  len FOSol _,
  std.assert! (try4.comp.decompl LinkU LinkU SOL1 FOSol FOSol1) "b3",
  std.forall LR (x\ sigma A B\ pr A B = x, try4.fo.equal FOSol1 A B),
  % try4.ho.unif LRH RH HO SOL, 
  % try4.comp.solve-link Link LinkU SOL SOL1,
  % try4.fo.alloc-subst FOSol L,
  % try4.fo.alloc-subst FOSol R,
  % len FOSol _, % close
  % std.assert! (try4.comp.decompl LinkU LinkU SOL1 FOSol FOSol1) "b3",
  % print "FO Subst" FOSol1,
  % try4.fo.equal FOSol1 L R,
].

xtest (test LR ff) :- std.spy-do! [  
  map-fold2 unfold-pair-comp LR [] [] LRH Link HO,
  not(unif-fold-pair LRH HO SOL, try4.comp.solve-link Link _ SOL _)
].

macro @ok X Y :- declare-test xtest (test [pr X Y] tt).
macro @ko X Y :- declare-test xtest (test [pr X Y] ff).

macro @okl X Y :- declare-test xtest (test L tt).
macro @kol X Y :- declare-test xtest (test L ff).

% @ok (@app [@f, @X]) (@app [@f, @a]).
% @ok (@app [@X, @a]) (@app [@f, @a]).
% @ok (@lam x\ @app [@X, x, @a]) (@lam x\ @app [@f, x, @a]).

% @ko (@app [@f, @X]) @X.
% @ko (@app [@f, @X, @X]) (@app [@f, @a, @b]).
% @ok (@app [@f, @X, @Y, @X]) (@app [@f, (@app [@f, @Y]), @b, (@app [@f, @b])]).
% @ok (@lam x\ (@app [@f, @X])) (@lam x\ (@app [@f, @a])).

% @ok (@lam x\ @lam y\ @app [@X, x, y]) (@lam x\ @lam y\ @app [@X, x, y]).

% @ok (@lam x\ @lam y\ @app [@X, x, y]) (@lam x\ @lam y\ @app [@f, y]).
@ok (@lam x\ @lam y\ @app [@X, x, y]) (@lam x\ @lam y\ @app [@X, y, x]).

% @ko (@lam x\ @app [@X, x, @a]) (@lam x\ @app [@f, x, x, @a]). % think
