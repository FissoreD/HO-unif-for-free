
namespace try4 {

%%%%%%%%%%%%%%%%%%% the OL %%%%%%%%%%%%%%%%%%%%%
namespace fo {

kind tm type.
type app list tm -> tm.
type lam (tm -> tm) -> tm.
type uv  nat -> tm.
type c string -> tm.

typeabbrev subst list (option tm).

% [equal Subst T1 T2] check if two terms are equal for the OL
% note: T1 and T2 are never flexible elpi variables
type equal subst -> tm -> tm -> o.
equal _ X Y :- (var X ; var Y), halt "flex".
equal S (uv N) T1 :- assigned? N S T, equal S T T1.
equal S T1 (uv N) :- assigned? N S T, equal S T1 T.
equal S (app [uv N|Args]) T1 :- assigned? N S F, beta F Args T, equal S T T1.
equal S T1 (app [uv N|Args]) :- assigned? N S F, beta F Args T, equal S T1 T.
equal S (app L1) (app L2) :- forall2 (equal S) L1 L2.
equal S (lam F1) (lam F2) :- pi x\ equal S x x => equal S (F1 x) (F2 x).
equal _ (c X) (c X).
equal _ (uv N) (uv N).

% eta
equal S (lam F) T :- not (T = lam _), 
  pi x\ beta T [x] (T' x), equal S (lam F) (lam T').
equal S T (lam F) :- not (T = lam _), 
  pi x\ beta T [x] (T' x), equal S (lam T') (lam F).

% beta
equal S (app [lam X | TL]) T :- beta (lam X) TL T', equal S T' T.
equal S T (app [lam X | TL]) :- beta (lam X) TL T', equal S T T'.

% [alloc-subst T S S'] foraech var in T, alloc an uv N at place N in S' (that extends S)
type alloc-subst tm -> subst -> subst -> o.
alloc-subst (uv N) S S :- len S M, M >n N.
alloc-subst (uv N) S S' :- len S M, M >=n N, std.append S [none] S'.
alloc-subst (lam F) S S' :- pi x\ (pi S\alloc-subst x S S) => alloc-subst (F x) S S'.
alloc-subst (c _) S S.
alloc-subst (app L) S S1 :- fold alloc-subst L S S1.

type beta tm -> list tm -> tm -> o.
beta A [] A.
beta (lam Bo) [H | L] R :- beta (Bo H) L R.
beta (app A) L (app X) :- std.append A L X.
beta (uv N) L (app [uv N | L]).
beta (c H) L (app [c H | L]).

% [new S N S'] return S' which is S with none at pos N
type new subst -> nat -> subst -> o.
new [] z [none].
new [X|XS] (s N) [X|YS] :- new XS N YS.

type mk-app tm -> list tm -> tm -> o.
mk-app T L S :- beta T L S.
}

%%%%%%%%%%%%%%%%%%% the ML %%%%%%%%%%%%%%%%%%%%%

namespace ho {

typeabbrev subst list (option assignment).

kind assignment type.
type abs (tm -> assignment) -> assignment.
type val tm -> assignment.

kind tm type.
type app list tm -> tm.
type lam (tm -> tm) -> tm.
type uv  nat -> list tm -> tm.
type c string -> tm.

% [unif T1 T2 SOld SNew] check if T1 and T2 unify looking into SOld. SNew is the final substution
type unif tm -> tm -> subst -> subst ->  o.
% TODO: QUESTION HERE WE MAY GENERATE KIND OF ETA EXPANSION IN HO.SUBST WITH BETA-ABS
unif (uv N Args) T S S1 :- assigned? N S F, beta-abs F Args T1, unif T1 T S S1.
unif T (uv N Args) S S1 :- assigned? N S F, beta-abs F Args T1, unif T T1 S S1.
unif (uv N A) (uv N A) S S :- pattern-fragment A.

unif (uv N Args1) (uv M Args2) S S3 :- pattern-fragment Args1, pattern-fragment Args2, 
  std.spy(new S W S1, prunexx W Args1 Args2 Ass, assign N S1 Ass S2, assign M S2 Ass S3).

unif (uv N Args) T S S1 :- not (T = uv _ _), print "In here", std.spy-do![not (occ N S T), pattern-fragment Args, bind Args T T1, assign N S T1 S1].
unif T (uv N Args) S S1 :- not (T = uv _ _), not (std.spy(occ N S T)), pattern-fragment Args, bind Args T T1, assign N S T1 S1.

% TODO: here we make FO unification -> should be moved in 
% unif (app [uv N L | Args]) (app L1) S S1 :-
%   std.appendR Hd Args L1,
%   unif (uv N L) (app Hd) S S1.


unif (app L1) (app L2) S S1 :- fold2 unif L1 L2 S S1.
unif (lam F1) (lam F2) S S1 :- pi x\ (pi S\ unif x x S S) => unif (F1 x) (F2 x) S S1.
unif (c X) (c X) S S.

% Vorremmo saperli unificare, ma non ci sono nella nostra specifica (CoqTerms non unificano eta-beta in Elpi)
% % eta
% unif T (lam F) S S1 :- not (T = lam _), 
%   pi x\ beta T [x] (F' x), unif (lam F') (lam F) S S1.
% unif T (lam F) S S1 :- not (T = lam _), 
%   pi x\ beta T [x] (F' x), unif (lam F') (lam F) S S1.

% % beta
% unif (app [lam F | TL]) T S S1 :- beta (lam F) TL T', unif T' T S S1.
% unif T (app [lam F | TL]) S S1 :- beta (lam F) TL T', unif T T' S S1.

type prunexx nat -> list tm -> list tm -> assignment -> o.
prunexx N A1 A2 T :-
  prune-aux N A1 A2 [] T _.


type prunex nat -> list tm -> list tm -> subst -> subst -> o.
prunex N A1 A2 S S2 :-
  new S M S1,
  prune-aux M A1 A2 [] F ff,
  assign N S1 F S2.
prunex _ _ _ S S.

type prune-aux nat -> list tm -> list tm -> list tm -> assignment -> bool -> o.
prune-aux N [] [] ACC (val (uv N Args)) tt :- std.rev ACC Args.
prune-aux N [X|XS] [X|YS] ACC (abs F) O :- pi x\ prune-aux N XS YS [x|ACC] (F x) O.
prune-aux N [_|XS] [_|YS] ACC (abs F) _ :- pi x\ prune-aux N XS YS ACC (F x) tt.

type beta-abs assignment -> list tm -> tm -> o.
beta-abs (abs Bo) [H | L] R :- beta-abs (Bo H) L R.
beta-abs (val A)  [] A.
beta-abs (val (app A))  L (app X) :- std.append A L X.
beta-abs (val (uv N A)) L (uv N X) :- std.append A L X.
beta-abs (val (c H))    L (app [c H | L]).

type beta tm -> list tm -> tm -> o.
beta A [] A.
beta (lam Bo) [H | L] R :- beta (Bo H) L R.
beta (app A) L (app X) :- std.append A L X.
beta (uv N A) L (uv N A') :- std.append A L A'.
beta (c H) L (app [c H | L]).

type occ.aux nat -> subst -> tm -> o.
occ.aux N _S (uv N _).
occ.aux N S (uv M Args) :- assigned? M S F, beta-abs F Args T, occ.aux N S T.
occ.aux N S (app L) :- exists (occ.aux N S) L.
occ.aux N S (lam F) :- pi x\ occ.aux N S (F x).

type occ  nat -> subst -> tm -> o.
occ N _S (uv N _) :- !, fail.
occ N S (uv M Args) :- assigned? M S F, !, beta-abs F Args T, occ N S T.
occ N S T :- occ.aux N S T.

type copy tm -> tm -> o.
copy (app L) (app L') :- forall2 copy L L'.
copy (lam T) (lam T') :- pi x\ copy x x => copy (T x) (T' x).
copy (uv N L) (uv N L') :- forall2 copy L L'.
copy (c C) (c C).

type bind list tm -> tm -> assignment -> o.
bind [] T (val T') :- copy T T'.
bind [X | TL] T (abs T') :- pi x\ copy X x => bind TL T (T' x).

type new subst -> nat -> subst -> o.
new [] z [none].
new [X|XS] (s N) [X|YS] :- new XS N YS.

type unif-assignment assignment -> assignment -> subst -> subst -> o.
unif-assignment (val T1) (val T2) H H1 :- unif T1 T2 H H1.
unif-assignment (abs F1) (abs F2) H H1 :- pi x\ (pi S\ unif x x S S) => unif-assignment (F1 x) (F2 x) H H1.
% unif-assignment (val T) (abs F) H H1 :- unif-assignment (abs x\ val {beta-abs (val T) [x]}) (abs F) H H1.
% unif-assignment (abs F) (val T) H H1 :- print "HERE", std.spy-do![unif-assignment (abs F) (abs x\ val {beta-abs (val T) [x]}) H H1].

}

namespace comp {

kind link type.
type link nat -> nat -> nat -> link.

% type not-in list A -> A -> o.
% not-in [] _.
% not-in [X | TL] _ :- not (X = T), not-in TL _.

type not-in A -> list A -> o.
not-in _ [].
not-in T [X | TL] :- not (X = T), not-in T TL.

type split-pf list A -> list A -> list A -> list A -> o.
split-pf [] _ [] [].
split-pf [X | L] ACC [X | PF] NPF :- name X, not-in X ACC, !, 
  split-pf L [X | ACC] PF NPF.
split-pf L _ [] L.

type comp fo.tm -> ho.tm -> list link -> list link -> ho.subst -> ho.subst -> o.
comp (fo.c X)   (ho.c X) L L S S.
comp (fo.app [fo.uv N|Argsss]) TT L L3 S S3 :- !,
  % TODO: here split-pf to enter dist. names into N
  split-pf Argsss [] PF NPF,
  print "In PF" PF NPF, 
  if (NPF = []) (TT = ho.uv M PF1) (TT = ho.app [ho.uv M PF1 | NPF1]),
  % pattern-fragment Args,
  fold4 comp PF PF1 L L1 S S1,
  fold4 comp NPF NPF1 L1 L2 S1 S2,
  ho.new S2 M S3,
  % TODO: maybe len can be given by split-pf
  len PF Len,
  L3 = [link N M Len| L2].
% TODO: if don't want to modify unif, we compile `fo.app [fo.c f, c0, c0, ho.c a]` into 
% `ho.app [ho.app[f, c0, c0], ho.c a]
comp (fo.app A) (ho.app A1) L L1 S S1 :- fold4 comp A A1 L L1 S S1.
comp (fo.lam F) (ho.lam F1) L L1 S S1 :- 
  (pi x y\ (pi A S\ comp x y A A S S) => comp (F x) (F1 y) L L1 S S1).
comp (fo.uv N) (ho.uv M []) L [link N M z|L] S S1 :- ho.new S M S1.

type solve-link list link -> list link -> ho.subst -> ho.subst -> o.
solve-link [link N M Len|L] LR HO HO1 :- take-link L (link N M' _) L1, !, std.spy-do! [
  same-assign M M' Len W HO HO2,
  solve-link [link N W Len|L1] LR HO2 HO1,
].
solve-link [L|LS] [L|LS'] HO HO1 :- solve-link LS LS' HO HO1.
solve-link [] [] X X.

type same-assign nat -> nat -> nat -> nat -> ho.subst -> ho.subst -> o.
same-assign M M' Len W HO HO2 :- std.spy-do![
  if (assigned? M HO T, W = M) true (eta Len M [] T),
  if (assigned? M' HO T', W = M') true (eta Len M' [] T'),
  ho.unif-assignment T T' HO HO2].

% [eta Arity VarName Acc Ass]
type eta nat -> nat -> list ho.tm -> ho.assignment -> o.
eta z     N Acc (ho.val (ho.uv N Acc')) :- std.rev Acc Acc'.
eta (s M) N Acc (ho.abs F) :- pi x\ eta M N [x | Acc] (F x).

type take-link list link -> link -> list link -> o.
take-link [L|XS] L XS.
take-link [L|XS] L' [L|YS] :- not(L = L'), take-link XS L' YS.

type assign-equal fo.subst -> nat -> fo.subst -> fo.tm -> fo.subst -> o.
assign-equal _ z (none :: L) Y (some Y :: L).
assign-equal S z (some A :: L) B (some A :: L) :- fo.equal S A B. 
assign-equal S (s N) (X :: L) Y (X :: L1) :- assign-equal S N L Y L1.

type decompl list link -> list link -> ho.subst -> fo.subst -> fo.subst -> o.
decompl [link N M Arity|L] LK HO FO FO1 :-
  assigned? M HO T,
  % HERE the assign-equal
  decomp-assign LK HO T T' FO FO',
  % TODO: QUESTION: here we are assigning a solution to fo.subst, maybe we 
  %                 could authorize eta redexes between FO[N] and T'
  print "Assigning" N "to" T' "with arity" Arity,
  assign-equal FO' N FO' T' FO2,
  decompl L LK HO FO2 FO1.
decompl [] _ _ X X.

% we use links just to know if the variables are new
type decomp-assign list link -> ho.subst -> ho.assignment -> fo.tm -> fo.subst -> fo.subst -> o.
% decomp-assign LK HO (ho.abs F) F1 S S1 :-
%   pi x y\ (pi S\ decomp LK HO x y S S) => decomp-assign LK HO (F x) F1 S S1.

decomp-assign LK HO (ho.abs F) (fo.lam F1) S S1 :-
  pi x y\ (pi S\ decomp LK HO x y S S) => decomp-assign LK HO (F x) (F1 y) S S1.

decomp-assign LK HO (ho.val T) T1 S S1 :- decomp LK HO T T1 S S1.

type decomp list link -> ho.subst -> ho.tm -> fo.tm -> fo.subst -> fo.subst -> o.
decomp _ _ (ho.c X)   (fo.c X) S S.
decomp LK HO (ho.app L) SolOL S S1 :- 
  fold2 (decomp LK HO) L [HD|TL] S S1,
  fo.mk-app HD TL SolOL.
decomp LK HO (ho.lam F) (fo.lam F1) S S1 :-
  pi x y\ (pi S\ decomp LK HO x y S S) => decomp LK HO (F x) (F1 y) S S1.
decomp LK HO (ho.uv N Args) SolOL S S1 :-
  fold2 (decomp LK HO) Args Args1 S S2,
  if (take-link LK (link X N _) _) (S1 = S2)
     (fo.new S2 X S1',
      if (assigned? N HO T)
         (decomp-assign LK HO T T' S1' S1'', assign X S1'' T' S1)
         (S1 = S1')),
  fo.mk-app (fo.uv X) Args1 SolOL.

/*
type eta-contract tm -> tm -> o.
eta-contract X X :- var X, !.
eta-contract (c X) (c X).
eta-contract (app L) (app L1) :- forall2 eta-contract L L1.
eta-contract (lam F) T :- contract [] (lam F) T.
eta-contract (lam F) (lam F1) :- pi x\ (pi X Y\ eta-contract X Y :- name X, X = Y) => eta-contract (F x) (F1 x).
eta-contract (uv X Args) (uv X Args).

type contract list tm -> tm -> tm -> o.
% contract A B _ :- print A B, fail.
contract L X T :- var X, !, fail.
contract L (lam F) T :- 
  pi x\ contract [x|L] (F x) T. % also checks H Prefix does not see x
contract L (app [H|Args]) T :- 
  %print "Base case",
  std.rev L LRev, std.appendR Prefix LRev Args,
  if (Prefix = []) (T = H) (T = app [H|Prefix]).
*/
    
}}

macro @X :- try4.fo.uv z.
macro @Y :- try4.fo.uv (s z).
macro @Z :- try4.fo.uv (s (s z)).
macro @f :- try4.fo.c "f".
macro @g :- try4.fo.c "g".
macro @h :- try4.fo.c "h".
macro @a :- try4.fo.c "a".
macro @b :- try4.fo.c "b".
macro @c :- try4.fo.c "c".
macro @app L :- try4.fo.app L.
macro @lam L :- try4.fo.lam L.

% type unfold-pair-comp 
%   pair try4.fo.tm try4.fo.tm -> 
%   pair try4.ho.tm try4.ho.tm -> 
%   list try4.comp.link ->
%   list try4.comp.link ->
%   try4.ho.subst -> try4.ho.subst -> o.
% unfold-pair-comp (pr L R) (pr LH RH) LLL Link S HO :-
%   std.assert! (try4.comp.comp L LH LLL Link0 S HO0) "b1",
%   std.assert! (try4.comp.comp R RH Link0 Link HO0 HO) "b2".
  
% type unif-fold-pair 
%   list (pair try4.ho.tm try4.ho.tm) ->
%   try4.ho.subst -> try4.ho.subst -> o.
% unif-fold-pair [] S S.
% unif-fold-pair [pr T1 T2 | TL] S1 S3 :-
%   try4.ho.unif T1 T2 S1 S2,
%   unif-fold-pair TL S2 S3.

% type forall-pair (try4.fo.tm -> o) -> 
%   list (pair try4.fo.tm try4.fo.tm) -> o.
% forall-pair _ [].
% forall-pair F [pr A B | TL] :- F A, F B, forall-pair F TL.
  

% xtest (test LR tt) :- std.spy-do! [
%   map-fold2 unfold-pair-comp LR [] [] LRH Link HO,
%   unif-fold-pair LRH HO SOL,
%   try4.comp.solve-link Link LinkU SOL SOL1,
%   forall-pair (try4.fo.alloc-subst FOSol) LR,
%   len FOSol _,
%   std.assert! (try4.comp.decompl LinkU LinkU SOL1 FOSol FOSol1) "b3",
%   std.forall LR (x\ sigma A B\ pr A B = x, try4.fo.equal FOSol1 A B),
%   % try4.ho.unif LRH RH HO SOL, 
%   % try4.comp.solve-link Link LinkU SOL SOL1,
%   % try4.fo.alloc-subst FOSol L,
%   % try4.fo.alloc-subst FOSol R,
%   % len FOSol _, % close
%   % std.assert! (try4.comp.decompl LinkU LinkU SOL1 FOSol FOSol1) "b3",
%   % print "FO Subst" FOSol1,
%   % try4.fo.equal FOSol1 L R,
% ].

type eval-unif 
  list (pair try4.fo.tm try4.fo.tm) -> 
  try4.ho.subst -> try4.ho.subst ->
  list try4.comp.link ->
  try4.fo.subst -> try4.fo.subst -> o.
eval-unif [] S S [] FO FO.
eval-unif [pr L R | TL] HO_Subs1 HO_SubsNN LNN FOSol FOSol3 :- std.spy-do![
  std.assert! (try4.comp.comp L LH [] L1 HO_Subs1 HO_Subs2) "b1",
  std.assert! (try4.comp.comp R RH L1 L2 HO_Subs2 HO_Subs3) "b2",
  try4.ho.unif LH RH HO_Subs3 HO_Subs4,
  try4.comp.solve-link L2 L3 HO_Subs4 HO_Subs5,
  try4.fo.alloc-subst L FOSol FOSol1,
  try4.fo.alloc-subst R FOSol1 FOSol2,
  eval-unif TL HO_Subs5 HO_SubsNN L4 FOSol2 FOSol3,
  std.append L3 L4 LNN].

type xtest test try4.fo.tm -> o.
xtest (test LR tt) :- std.spy-do![
  eval-unif LR [] SOL1 Links [] FOSol,
  std.assert! (try4.comp.decompl Links Links SOL1 FOSol FOSol1) "b3",
  print "FO Subst" FOSol1,
  std.forall LR (x\ sigma L R\ pr L R = x, try4.fo.equal FOSol1 L R),
].
xtest (test LR ff) :- std.spy-do! [
  not(eval-unif LR [] _S _L [] _FO)
].

macro @ok X Y :- declare-test xtest (test [pr X Y] tt).
macro @ko X Y :- declare-test xtest (test [pr X Y] ff).

macro @okl X :- declare-test xtest (test X tt).
macro @kol X :- declare-test xtest (test X ff).

% @ok (@app [@f, @X]) (@app [@f, @a]).
% @ok (@app [@X, @a]) (@app [@f, @a]).
% @ok (@lam x\ @app [@X, x, @a]) (@lam x\ @app [@f, x, @a]).

% @ko (@app [@f, @X]) @X.
% @ko (@app [@f, @X, @X]) (@app [@f, @a, @b]).
% @ok (@app [@f, @X, @Y, @X]) (@app [@f, (@app [@f, @Y]), @b, (@app [@f, @b])]).
% @ok (@lam x\ (@app [@f, @X])) (@lam x\ (@app [@f, @a])).

% @ok (@lam x\ @lam y\ @app [@X, x, y]) (@lam x\ @lam y\ @app [@X, x, y]).

% @ok (@lam x\ @lam y\ @app [@X, x, y]) (@lam x\ @lam y\ @app [@f, y]).
% @ok (@lam x\ @lam y\ @app [@X, x, y]) (@lam x\ @lam y\ @app [@X, y, x]).

% @ok (@lam x\ @app [@X, x]) (@lam x\ @app [@f, x, x, @a]).
%@ok (@lam x\ @app [@X, x, @a]) (@lam x\ @app [@f, x, x, @a]). % think

@okl [
  (pr (@lam x\ @app [@X, x]) (@lam x\ @app [@f, x])), 
  (pr @f @X)].