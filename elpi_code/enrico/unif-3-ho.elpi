
namespace ho3 {

kind tm type.
type app list tm -> tm.
type lam (tm -> tm) -> tm.
type uv  nat -> list tm -> tm.
type c string -> tm.

type unif tm -> tm -> list tm -> o.
unif (uv N Args) T S :- assigned? N S F, beta F Args T1, unif T1 T S.
unif T (uv N Args) S :- assigned? N S F, beta F Args T1, unif T T1 S.
unif (uv N Args) T S :- not(assigned? N S _), not (occ N T), pattern-fragment Args, bind Args T T1, assign N S T1.
unif T (uv N Args) S :- not(assigned? N S _), not (occ N T), pattern-fragment Args, bind Args T T1, assign N S T1.
unif (app L1) (app L2) S :- forall2 (x\y\unif x y S) L1 L2.
unif (lam F1) (lam F2) S :- pi x\ unif (F1 x) (F2 x) S.
unif (c X) (c X) _.

type beta tm -> list tm -> tm -> o.
beta A [] A.
beta (lam Bo) [H | L] R :- beta (Bo H) L R.
beta (app A) L (app X) :- std.append A L X.
beta (uv N A) L (uv N X) :- std.append A L X.
beta (c H) L (app [c H | L]).

type occ nat -> tm -> o.
occ N (uv N _).
occ N (app L) :- exists (occ N) L.
occ N (lam F) :- pi x\ occ N (F x).

type copy tm -> tm -> o.
copy (app L) (app L') :- forall2 copy L L'.
copy (lam T) (lam T') :- pi x\ copy x x => copy (T x) (T' x).
copy (uv N L) (uv N L') :- forall2 copy L L'.
copy (c C) (c C).

type bind list tm -> tm -> tm -> o.
bind [] T T' :- copy T T'.
bind [X | TL] T (lam T') :- pi x\ copy X x => bind TL T (T' x).

type equal tm -> tm -> list tm -> o.
equal (uv N Args) T1 S :-assigned? N S F, beta F Args T, equal T T1 S.
equal T1 (uv N Args) S :- assigned? N S F, beta F Args T, equal T1 T S.
equal (app L1) (app L2) S :- forall2 (x\y\equal x y S) L1 L2.
equal (lam F1) (lam F2) S :- pi x\ equal x x S => equal (F1 x) (F2 x) S.
equal (c X) (c X) _.
equal (uv N L1) (uv N L2) S :- forall2 (x\y\equal x y S) L1 L2.


}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

namespace comp1 {

shorten ho3.{ lam, app, uv, c, copy }.
typeabbrev tm ho3.tm.

type comp tm -> tm -> list tm -> list A -> o.
comp (c X) (c X) _ _.
comp (app L) (app L1) SO SM :- forall2 (x\y\comp x y SO SM) L L1.
comp (lam F) (lam F1) SO SM :- pi x\ comp x x SO SM => comp (F x) (F1 x) SO SM.
comp (uv N L) XL SO SM :- std.do! [
  pattern-fragment L, var XL X _, prune XL L,
  assign N SM X,
  ho-link L X T, assign N SO T,
].

type ho-link list tm -> A -> tm -> o.
ho-link [] T T.
ho-link [_|VS] T (lam T') :- pi x\ ho-link VS (T x) (T' x).

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

namespace comp2 {

shorten ho3.{ lam, app, uv, c, copy }.
typeabbrev tm ho3.tm.

type pi-close (tm -> list o) -> list o -> o.
pi-close (x\ []) [].
pi-close (x\ [A x | TL x]) [pi x\ A x | TL'] :- 
  pi-close TL TL'.

type comp tm -> tm -> list tm -> list o -> list o -> o.
comp (c X) (c X) _ L L.
comp (app A) (app A1) SO L L1 :- fold2 (x\y\comp x y SO) A A1 L L1.
comp (lam F) (lam F1) SO L L2 :- 
  (pi x\ (pi A\ comp x x SO A A) => comp (F x) (F1 x) SO L (L1 x)),
  pi-close L1 L2.
comp (uv N S) XV SO L L1 :- std.do! [
  pattern-fragment S, var XV X _, prune XV S,
  nth N SO T, len S A, L1 = [ho-link-eta A T X| L],
].

type ho-link nat -> tm -> A -> o.
ho-link z T T.
ho-link (s A) (lam F) (x\X x) :- pi x\ ho-link A (F x) (X x).

type ho-link-eta nat -> tm -> A -> o.
ho-link-eta A T X :- 
  print "--------------------- Make ho-link between" T "and" X,
  ho-link A T' X, 
  print "After HO-link, T' is" T',
  eta-contract T' T,
  print "The final T is" T.

type eta-contract tm -> tm -> o.
eta-contract (c X) (c X).
eta-contract (app L) (app L1) :- forall2 eta-contract L L1.
eta-contract (lam F) T :- contract [] (lam F) T.
eta-contract (lam F) (lam F1) :- pi x\ eta-contract x x => eta-contract (F x) (F1 x).
eta-contract (uv X Args) (uv X Args).

type contract list tm -> tm -> tm -> o.
% contract A B _ :- print A B, fail.
contract L X T :- var X, !, fail.
contract L (lam F) T :- 
  pi x\ contract [x|L] (F x) T. % also checks H Prefix does not see x
contract L (app [H|Args]) T :- 
  print "Base case",
  std.rev L LRev, std.appendR Prefix LRev Args,
  if (Prefix = []) (T = H) (T = app [H|Prefix]).
}

% TODO: comp3 (app [uv ... |...]) -> X + ho-link-beta
