
namespace ho3 {

kind tm type.
type app list tm -> tm.
type lam (tm -> tm) -> tm.
type uv  nat -> list tm -> tm.
type c string -> tm.

type unif tm -> tm -> list tm -> o.
unif (uv N Args) T S :- assigned? N S F, beta F Args T1, unif T1 T S.
unif T (uv N Args) S :- assigned? N S F, beta F Args T1, unif T T1 S.
unif (uv N Args) T S :- not(assigned? N S _), not (occ N T), pattern-fragment Args, bind Args T T1, assign N S T1.
unif T (uv N Args) S :- not(assigned? N S _), not (occ N T), pattern-fragment Args, bind Args T T1, assign N S T1.
unif (app L1) (app L2) S :- forall2 (x\y\unif x y S) L1 L2.
unif (lam F1) (lam F2) S :- pi x\ unif (F1 x) (F2 x) S.
unif (c X) (c X) _.

type beta tm -> list tm -> tm -> o.
beta A [] A.
beta (lam Bo) [H | L] R :- beta (Bo H) L R.
beta (app A) L (app X) :- std.append A L X.
beta (uv N A) L (uv N X) :- std.append A L X.

type occ nat -> tm -> o.
occ N (uv N _).
occ N (app L) :- exists (occ N) L.
occ N (lam F) :- pi x\ occ N (F x).

type copy tm -> tm -> o.
copy (app L) (app L') :- forall2 copy L L'.
copy (lam T) (lam T') :- pi x\ copy x x => copy (T x) (T' x).
copy (uv N L) (uv N L') :- forall2 copy L L'.
copy (c C) (c C).

type bind list tm -> tm -> tm -> o.
bind [] T T' :- copy T T'.
bind [X | TL] T (lam T') :- pi x\ copy X x => bind TL T (T' x).

type equal tm -> tm -> list tm -> o.
equal (uv N Args) T1 S :- assigned? N S F, beta F Args T, equal T T1 S.
equal T1 (uv N Args) S :- assigned? N S F, beta F Args T, equal T1 T S.
equal (app L1) (app L2) S :- forall2 (x\y\equal x y S) L1 L2.
equal (lam F1) (lam F2) S :- pi x\ equal x x S => equal (F1 x) (F2 x) S.
equal (c X) (c X) _.
equal (uv N L1) (uv N L2) S :- forall2 (x\y\equal x y S) L1 L2.


}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

namespace comp1 {

shorten ho3.{ lam, app, uv, c, copy }.
typeabbrev tm ho3.tm.

type comp tm -> tm -> list tm -> list A -> o.
comp (c X) (c X) _ _.
comp (app L) (app L1) SO SM :- forall2 (x\y\comp x y SO SM) L L1.
comp (lam F) (lam F1) SO SM :- pi x\ comp x x SO SM => comp (F x) (F1 x) SO SM.
comp (uv N L) XL SO SM :- std.do! [
  pattern-fragment L, var XL X _, prune XL L,
  assign N SM X,
  ho-link L X T, assign N SO T,
].

type ho-link list tm -> A -> tm -> o.
ho-link [] T T.
ho-link [_|VS] T (lam T') :- pi x\ ho-link VS (T x) (T' x).

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

namespace comp2 {

shorten ho3.{ lam, app, uv, c, copy }.
typeabbrev tm ho3.tm.

type comp tm -> tm -> list tm -> list o -> list o -> o.
comp (c X) (c X) _ L L.
comp (app A) (app A1) SO L L1 :- fold2 (x\y\comp x y SO) A A1 L L1.
comp (lam F) (lam F1) SO L L1 :- pi x\ (pi A\ comp x x SO A A) => comp (F x) (F1 x) SO L L1. % TODO pi
comp (uv N S) XV SO L L1 :- std.do! [
  pattern-fragment S, var XV X _, prune XV S,
  nth N SO T, len S A, L1 = [ho-link-eta A T X| L],
].

type ho-link nat -> tm -> A -> o.
ho-link z T T.
ho-link (s A) (lam F) (x\X x) :- pi x\ ho-link A (F x) (X x).

ho-link-eta :- ho-link, eta-contract.

}
