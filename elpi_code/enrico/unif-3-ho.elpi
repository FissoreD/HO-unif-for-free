
namespace ho3 {

kind tm type.
type app list tm -> tm.
type lam (tm -> tm) -> tm.
type uv  nat -> list tm -> tm.
type c string -> tm.

type unif tm -> tm -> list tm -> o.
unif (uv N Args) T S :- assigned? N S F, beta F Args T1, unif T1 T S.
unif T (uv N Args) S :- assigned? N S F, beta F Args T1, unif T T1 S.
unif (uv N Args) T S :- not(assigned? N S _), not (occ N T), bind Args T T1, assign N S T1.
unif T (uv N Args) S :- not(assigned? N S _), not (occ N T), bind Args T T1, assign N S T1.
unif (app L1) (app L2) S :- forall2 (x\y\unif x y S) L1 L2.
unif (lam F1) (lam F2) S :- pi x\ unif (F1 x) (F2 x) S.
unif (c X) (c X) _.

type beta tm -> list tm -> tm -> o.
beta A [] A.
beta (lam Bo) [H | L] R :- beta (Bo H) L R.
beta (app A) L (app X) :- std.append A L X.
beta (uv N A) L (uv N X) :- std.append A L X.

type forall2 (A -> A -> o) -> list A -> list A -> o.
forall2 _ [] [].
forall2 F [X|XS] [Y|YS] :- F X Y, forall2 F XS YS.

type occ nat -> tm -> o.
occ N (uv N _).
occ N (app L) :- exists (occ N) L.
occ N (lam F) :- pi x\ occ N (F x).

type exists (A -> o) -> list A -> o.
exists F [X|XS] :- F X ; exists F XS.

pred copy i:tm, o:tm.
copy (app L) (app L') :- forall2 copy L L'.
copy (lam T) (lam T') :- pi x\ copy x x => copy (T x) (T' x).
copy (uv N L) (uv N L') :- forall2 copy L L'.
copy (c C) (c C).

pred bind i:list tm, i:tm, o:tm.
bind [] T T' :- copy T T'.
bind [X | TL] T (lam T') :- pi x\ copy X x => bind TL T (T' x).

type equal tm -> tm -> list tm -> o.
equal (uv N Args) T1 S :- assigned? N S F, beta F Args T, equal T T1 S.
equal T1 (uv N Args) S :- assigned? N S F, beta F Args T, equal T1 T S.
equal (app L1) (app L2) S :- forall2 (x\y\equal x y S) L1 L2.
equal (lam F1) (lam F2) S :- pi x\ equal x x S => equal (F1 x) (F2 x) S.
equal (c X) (c X) _.
equal (uv N L1) (uv N L2) S :- forall2 (x\y\equal x y S) L1 L2.


}