
namespace ho3 {

kind tm type.
type app list tm -> tm.
type lam (tm -> tm) -> tm.
type uv  nat -> list tm -> tm.
type c string -> tm.

type unif tm -> tm -> list tm -> o.
unif (uv N Args) T S :- assigned? N S F, beta F Args T1, unif T1 T S.
unif T (uv N Args) S :- assigned? N S F, beta F Args T1, unif T T1 S.
unif (uv N Args) T S :- not(assigned? N S _), not (occ N T), pattern-fragment Args, bind Args T T1, assign N S T1.
unif T (uv N Args) S :- not(assigned? N S _), not (occ N T), pattern-fragment Args, bind Args T T1, assign N S T1.
unif (app L1) (app L2) S :- forall2 (x\y\unif x y S) L1 L2.
unif (lam F1) (lam F2) S :- pi x\ unif (F1 x) (F2 x) S.
unif (c X) (c X) _.

type beta tm -> list tm -> tm -> o.
beta A [] A.
beta (lam Bo) [H | L] R :- beta (Bo H) L R.
beta (app A) L (app X) :- std.append A L X.
beta (uv N A) L (uv N X) :- std.append A L X.
beta (c H) L (app [c H | L]).

type occ nat -> tm -> o.
occ N (uv N _).
occ N (app L) :- exists (occ N) L.
occ N (lam F) :- pi x\ occ N (F x).

type copy tm -> tm -> o.
copy (app L) (app L') :- forall2 copy L L'.
copy (lam T) (lam T') :- pi x\ copy x x => copy (T x) (T' x).
copy (uv N L) (uv N L') :- forall2 copy L L'.
copy (c C) (c C).

type bind list tm -> tm -> tm -> o.
bind [] T T' :- copy T T'.
bind [X | TL] T (lam T') :- pi x\ copy X x => bind TL T (T' x).

type validSO list tm -> o.
validSO L :- var L.
validSO [X|XS] :- (ground_term X ; var X), validSO XS.

type equal tm -> tm -> list tm -> o.
equal X Y _ :- (var X ; var Y), halt "flex".
equal (uv N Args) T1 S :-assigned? N S F, beta F Args T, equal T T1 S.
equal T1 (uv N Args) S :- assigned? N S F, beta F Args T, equal T1 T S.
equal (app L1) (app L2) S :- forall2 (x\y\equal x y S) L1 L2.
equal (lam F1) (lam F2) S :- pi x\ equal x x S => equal (F1 x) (F2 x) S.
equal (c X) (c X) _.
equal (uv N L1) (uv N L2) S :- forall2 (x\y\equal x y S) L1 L2.


}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

namespace comp1 {

shorten ho3.{ lam, app, uv, c, copy }.
typeabbrev tm ho3.tm.

type comp tm -> tm -> list tm -> list A -> o.
comp (c X) (c X) _ _.
comp (app L) (app L1) SO SM :- forall2 (x\y\comp x y SO SM) L L1.
comp (lam F) (lam F1) SO SM :- pi x\ comp x x SO SM => comp (F x) (F1 x) SO SM.
comp (uv N S) XV SO SM :- std.do! [
  pattern-fragment S, var XV _ _, prune XV S, var XV X _,

  assign N SM X,
  ho-link S X T, nth N SO T,
].

type ho-link list tm -> A -> tm -> o.
ho-link [] T T.
ho-link [_|VS] T (lam T') :- pi x\ ho-link VS (T x) (T' x).

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

namespace comp2 {

shorten ho3.{ lam, app, uv, c, copy }.
typeabbrev tm ho3.tm.

type pi-close (tm -> list o) -> list o -> o.
pi-close (x\ []) [].
pi-close (x\ [A | TL x]) [A | TL'] :- 
  pi-close TL TL'.
pi-close (x\ [A x | TL x]) [pi x\ A x | TL'] :- 
  pi-close TL TL'.

% [comp T TComp Theta OldLinks NewLinks] 
% - T        : the term in the OL
% - TComp    : the compiled version of T
% - Theta    : the set of substitution in the OL
% - OldLinks : the links before the compil
% - NewLinks : the links after the compil
type comp tm -> tm -> list A -> list o -> list o -> o.
comp (c X) (c X) _ L L.
comp (app A) (app A1) SO L L1 :- fold2 (x\y\comp x y SO) A A1 L L1.
comp (lam F) (lam F1) SO L L2 :- 
  (pi x\ (pi A\ comp x x SO A A) => comp (F x) (F1 x) SO L (L1 x)),
  pi-close L1 L2.
comp (uv N S) XV SO L L1 :- std.do! [
  pattern-fragment S, prune XV S, var XV X _,
  nth N SO T, len S Arity, 
  L1 = [ho-link-eta Arity T X | L],
].

% [ho-link Arity T TM]
% - Arity : the arity of the terms to build
% - T     : the term of the OL
% - TM    : the term of LP
type ho-link nat -> tm -> A -> o.
ho-link z X X.
ho-link (s A) (lam F) (x\X x) :- pi x\ ho-link A (F x) (X x).

% [decomp Theta T]
% - Theta : the substitution of the OL
% - T     : the term being analized 
%           in particular, if T contains any uvar of the ML, then this uvar is
%           replaced with an uvar of the OL
type decomp list tm -> tm -> o.
decomp SO XV :- var XV _ S, !, new SO N, XV = (uv N S).
decomp _ X :- name X.
decomp SO (app L) :- std.forall L (decomp SO).
decomp SO (lam F)  :- pi x\ decomp SO (F x).
decomp SO (c X).
decomp SO (uv N S).

type decompSO list tm -> o.
decompSO SO :-
  copyl SO S1,
  forall (decomp SO) S1.

copyl L [] :- var L, !.
copyl [X|L] [X|L1] :- copyl L L1.

type new list tm -> nat -> o.
new L z :- var L, !, L = [FRESH_|TAIL_].
new [_|L] (s N) :- new L N.

type ho-link-eta nat -> tm -> A -> o.
ho-link-eta A T X :- 
  % print "--------------------- Make ho-link between" T "and" X,
  ho-link A T' X, 
  %print "After HO-link, T' is" T',
  eta-contract T' T.
  %print "The final T is" T.

type eta-contract tm -> tm -> o.
eta-contract X X :- var X, !.
eta-contract (c X) (c X).
eta-contract (app L) (app L1) :- forall2 eta-contract L L1.
eta-contract (lam F) T :- contract [] (lam F) T.
eta-contract (lam F) (lam F1) :- pi x\ (pi X Y\ eta-contract X Y :- name X, X = Y) => eta-contract (F x) (F1 x).
eta-contract (uv X Args) (uv X Args).

type contract list tm -> tm -> tm -> o.
% contract A B _ :- print A B, fail.
contract _ X _ :- var X, !, fail.
contract L (lam F) T :- 
  pi x\ contract [x|L] (F x) T. % also checks H Prefix does not see x
contract L (app [H|Args]) T :-
  std.rev L LRev, std.appendR Prefix LRev Args,
  if (Prefix = []) (T = H) (T = app [H|Prefix]).
%TODO: uv N Args
}

% TODO: comp3 (app [uv ... |...]) -> X + ho-link-beta
