kind tm type.

type app list tm -> tm.
type abs (tm -> tm) -> tm.
type uv int -> tm.
type const int -> tm.

typeabbrev theta (list tm).

pred copy i:tm, o:tm.
copy (app L) (app L') :- std.map L copy L'.
copy (abs T) (abs T') :- pi x\ copy (T x) (T' x).
copy (uv N) (uv N).
copy (const C) (const C).
copy X X :- name X, !.
copy L _ :- halt "Error in copy" L.

pred bind i:list tm, i:tm, o:tm.
bind [] T T' :- copy T T'.
bind [X | TL] T (abs T') :-
  pi x\ copy X x => bind TL T (T' x).

pred nth i:int, i:tm, i:theta, o:theta.
nth 0 T [] [T] :- !.
% TODO: nth should be unification between X and T ?
nth 0 T [X | TL] [T | TL] :- !, std.assert! (X = T) "nth: Error in unificaton".

nth N T [] [X_|TL] :- N > 0, !, M is N - 1, nth M T [] TL.
nth N T [X|TL] [X|TL'] :- N > 0, !, M is N - 1, nth M T TL TL'.

pred pattern-fragment i:list tm.
pattern-fragment L :- distinct_names L.

pred mk-app i:tm, i:list tm, o:tm.
mk-app A [] A :- !.
mk-app (abs Bo) [H | L] R :- !,
  mk-app (Bo H) L R.
mk-app (app A) L (app X) :- !, std.append A L X.
mk-app HD TL (app [HD | TL]).

pred unif i:tm, i:tm, i:theta, o:theta.
% (Uvar, T)
unif (uv N) Tm T T' :- !,
  nth N Tm T T'.

% (AppUvar, T)
unif (app [uv N | L]) Tm T T' :- !,
  pattern-fragment L, 
  bind L Tm Tm',
  nth N Tm' T T'.

% (Beta, T)
unif (app [abs B | L]) X' T T' :- !,
  mk-app (abs B) L X,
  unif X X' T T'.

% (Eta, T)
unif (abs X) X' T T' :-
  not (X' = abs _), !,
  pi x\ sigma X''\
    mk-app X' [x] X'',
    unif (X x) X'' T T'.

% Reciproque

% (T, Uvar) 
unif Tm (uv N) T T' :- !,
  unif (uv N) Tm T T'.

% (T, AppUvar)
unif Tm (app [uv N | L]) T T' :- !,
  unif (app [uv N | L]) Tm T T'.

% (T, Beta)
unif X' (app [abs B | L]) T T' :- !,
  unif (app [abs B | L]) X' T T'.

% (T, Eta)
unif X' (abs X) T T' :-
  not (X' = abs _), !,
  unif (abs X) X' T T'.

% Classic
unif (app L) (app L') T T' :-
  std.fold2 L L' T unif T'. 
unif (abs L) (abs L') T T' :-
  pi x\ unif (L x) (L' x) T T'.
unif (const C) (const C) T T.
unif A A T T :- name A, !.

unif A _ _ _ :- halt A.